// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: usercmd.proto

#include "usercmd.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CInButtonStatePB::CInButtonStatePB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buttonstate1_)*/uint64_t{0u}
  , /*decltype(_impl_.buttonstate2_)*/uint64_t{0u}
  , /*decltype(_impl_.buttonstate3_)*/uint64_t{0u}} {}
struct CInButtonStatePBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CInButtonStatePBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CInButtonStatePBDefaultTypeInternal() {}
  union {
    CInButtonStatePB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CInButtonStatePBDefaultTypeInternal _CInButtonStatePB_default_instance_;
PROTOBUF_CONSTEXPR CTicklessMoveStep::CTicklessMoveStep(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.button_)*/0
  , /*decltype(_impl_.pressed_)*/false
  , /*decltype(_impl_.when_)*/0} {}
struct CTicklessMoveStepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CTicklessMoveStepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CTicklessMoveStepDefaultTypeInternal() {}
  union {
    CTicklessMoveStep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CTicklessMoveStepDefaultTypeInternal _CTicklessMoveStep_default_instance_;
PROTOBUF_CONSTEXPR CBaseUserCmdPB::CBaseUserCmdPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tickless_moves_)*/{}
  , /*decltype(_impl_.buttons_pb_)*/nullptr
  , /*decltype(_impl_.viewangles_)*/nullptr
  , /*decltype(_impl_.command_number_)*/0
  , /*decltype(_impl_.tick_count_)*/0
  , /*decltype(_impl_.forwardmove_)*/0
  , /*decltype(_impl_.leftmove_)*/0
  , /*decltype(_impl_.upmove_)*/0
  , /*decltype(_impl_.impulse_)*/0
  , /*decltype(_impl_.weaponselect_)*/0
  , /*decltype(_impl_.random_seed_)*/0
  , /*decltype(_impl_.mousedx_)*/0
  , /*decltype(_impl_.mousedy_)*/0
  , /*decltype(_impl_.hasbeenpredicted_)*/false
  , /*decltype(_impl_.pawn_entity_handle_)*/16777215u} {}
struct CBaseUserCmdPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CBaseUserCmdPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CBaseUserCmdPBDefaultTypeInternal() {}
  union {
    CBaseUserCmdPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CBaseUserCmdPBDefaultTypeInternal _CBaseUserCmdPB_default_instance_;
PROTOBUF_CONSTEXPR CUserCmdBasePB::CUserCmdBasePB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr} {}
struct CUserCmdBasePBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CUserCmdBasePBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CUserCmdBasePBDefaultTypeInternal() {}
  union {
    CUserCmdBasePB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CUserCmdBasePBDefaultTypeInternal _CUserCmdBasePB_default_instance_;
PROTOBUF_CONSTEXPR CHLXUserCmdPB::CHLXUserCmdPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr} {}
struct CHLXUserCmdPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CHLXUserCmdPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CHLXUserCmdPBDefaultTypeInternal() {}
  union {
    CHLXUserCmdPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CHLXUserCmdPBDefaultTypeInternal _CHLXUserCmdPB_default_instance_;
PROTOBUF_CONSTEXPR CDota2UserCmdPB::CDota2UserCmdPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.crosshairtrace_)*/nullptr
  , /*decltype(_impl_.spectator_query_unit_entindex_)*/0
  , /*decltype(_impl_.cameraposition_x_)*/0
  , /*decltype(_impl_.cameraposition_y_)*/0
  , /*decltype(_impl_.clickbehavior_)*/0u
  , /*decltype(_impl_.statspanel_)*/0u
  , /*decltype(_impl_.shoppanel_)*/0u
  , /*decltype(_impl_.stats_dropdown_)*/0u
  , /*decltype(_impl_.stats_dropdown_sort_)*/0u} {}
struct CDota2UserCmdPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDota2UserCmdPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDota2UserCmdPBDefaultTypeInternal() {}
  union {
    CDota2UserCmdPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDota2UserCmdPBDefaultTypeInternal _CDota2UserCmdPB_default_instance_;
PROTOBUF_CONSTEXPR CCitadelUserCmdPB::CCitadelUserCmdPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.vec_camera_position_)*/nullptr
  , /*decltype(_impl_.ang_camera_angles_)*/nullptr
  , /*decltype(_impl_.execute_ability_indices_)*/0
  , /*decltype(_impl_.in_shop_)*/false
  , /*decltype(_impl_.camera_roaming_speed_)*/0
  , /*decltype(_impl_.spec_target_)*/-1} {}
struct CCitadelUserCmdPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCitadelUserCmdPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCitadelUserCmdPBDefaultTypeInternal() {}
  union {
    CCitadelUserCmdPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCitadelUserCmdPBDefaultTypeInternal _CCitadelUserCmdPB_default_instance_;
PROTOBUF_CONSTEXPR CSGOInputHistoryEntryPB::CSGOInputHistoryEntryPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.view_angles_)*/nullptr
  , /*decltype(_impl_.shoot_position_)*/nullptr
  , /*decltype(_impl_.target_head_pos_check_)*/nullptr
  , /*decltype(_impl_.target_pos_check_)*/nullptr
  , /*decltype(_impl_.render_tick_count_)*/0
  , /*decltype(_impl_.render_tick_fraction_)*/0
  , /*decltype(_impl_.player_tick_count_)*/0
  , /*decltype(_impl_.player_tick_fraction_)*/0
  , /*decltype(_impl_.target_ent_index_)*/0} {}
struct CSGOInputHistoryEntryPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSGOInputHistoryEntryPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSGOInputHistoryEntryPBDefaultTypeInternal() {}
  union {
    CSGOInputHistoryEntryPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSGOInputHistoryEntryPBDefaultTypeInternal _CSGOInputHistoryEntryPB_default_instance_;
PROTOBUF_CONSTEXPR CSGOUserCmdPB::CSGOUserCmdPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.input_history_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.attack1_start_history_index_)*/-1
  , /*decltype(_impl_.attack2_start_history_index_)*/-1} {}
struct CSGOUserCmdPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSGOUserCmdPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSGOUserCmdPBDefaultTypeInternal() {}
  union {
    CSGOUserCmdPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSGOUserCmdPBDefaultTypeInternal _CSGOUserCmdPB_default_instance_;
PROTOBUF_CONSTEXPR CMsgVRHandInfo::CMsgVRHandInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vposition_)*/nullptr
  , /*decltype(_impl_.angles_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.localposition_)*/nullptr
  , /*decltype(_impl_.localangles_)*/nullptr
  , /*decltype(_impl_.filteredposition_)*/nullptr
  , /*decltype(_impl_.filteredangles_)*/nullptr
  , /*decltype(_impl_.filteredvelocity_)*/nullptr
  , /*decltype(_impl_.filteredangularvel_)*/nullptr
  , /*decltype(_impl_.filteredthrowvel_)*/nullptr
  , /*decltype(_impl_.sampletime_)*/0
  , /*decltype(_impl_.triggeranalogvalue_)*/0
  , /*decltype(_impl_.gripanalogvalue_)*/0
  , /*decltype(_impl_.finger0_)*/0
  , /*decltype(_impl_.finger1_)*/0
  , /*decltype(_impl_.finger2_)*/0
  , /*decltype(_impl_.finger3_)*/0
  , /*decltype(_impl_.finger4_)*/0
  , /*decltype(_impl_.fingersplay0_)*/0
  , /*decltype(_impl_.fingersplay1_)*/0
  , /*decltype(_impl_.fingersplay2_)*/0
  , /*decltype(_impl_.fingersplay3_)*/0
  , /*decltype(_impl_.trackpadanalogvaluex_)*/0
  , /*decltype(_impl_.trackpadanalogvaluey_)*/0
  , /*decltype(_impl_.joystickanalogvaluex_)*/0
  , /*decltype(_impl_.joystickanalogvaluey_)*/0} {}
struct CMsgVRHandInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgVRHandInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgVRHandInfoDefaultTypeInternal() {}
  union {
    CMsgVRHandInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgVRHandInfoDefaultTypeInternal _CMsgVRHandInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgVRController::CMsgVRController(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.active_)*/false
  , /*decltype(_impl_.supports_skeleton_)*/false} {}
struct CMsgVRControllerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgVRControllerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgVRControllerDefaultTypeInternal() {}
  union {
    CMsgVRController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgVRControllerDefaultTypeInternal _CMsgVRController_default_instance_;
PROTOBUF_CONSTEXPR CUserMsgVRCore::CUserMsgVRCore(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hmd_controllers_)*/{}
  , /*decltype(_impl_.middle_eye_local_)*/nullptr
  , /*decltype(_impl_.viewangles_local_)*/nullptr
  , /*decltype(_impl_.active_)*/false
  , /*decltype(_impl_.targeting_mode_)*/false
  , /*decltype(_impl_.controller_type_)*/0u} {}
struct CUserMsgVRCoreDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CUserMsgVRCoreDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CUserMsgVRCoreDefaultTypeInternal() {}
  union {
    CUserMsgVRCore _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CUserMsgVRCoreDefaultTypeInternal _CUserMsgVRCore_default_instance_;
PROTOBUF_CONSTEXPR VrInputDigitalActionData::VrInputDigitalActionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.activeorigin_)*/uint64_t{0u}
  , /*decltype(_impl_.active_)*/false
  , /*decltype(_impl_.state_)*/false
  , /*decltype(_impl_.changed_)*/false
  , /*decltype(_impl_.updatetime_)*/0} {}
struct VrInputDigitalActionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VrInputDigitalActionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VrInputDigitalActionDataDefaultTypeInternal() {}
  union {
    VrInputDigitalActionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VrInputDigitalActionDataDefaultTypeInternal _VrInputDigitalActionData_default_instance_;
PROTOBUF_CONSTEXPR VrInputAnalogActionData::VrInputAnalogActionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.delta_)*/nullptr
  , /*decltype(_impl_.activeorigin_)*/uint64_t{0u}
  , /*decltype(_impl_.active_)*/false
  , /*decltype(_impl_.updatetime_)*/0} {}
struct VrInputAnalogActionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VrInputAnalogActionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VrInputAnalogActionDataDefaultTypeInternal() {}
  union {
    VrInputAnalogActionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VrInputAnalogActionDataDefaultTypeInternal _VrInputAnalogActionData_default_instance_;
PROTOBUF_CONSTEXPR VrInputSkeletalActionData::VrInputSkeletalActionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.activeorigin_)*/uint64_t{0u}
  , /*decltype(_impl_.active_)*/false} {}
struct VrInputSkeletalActionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VrInputSkeletalActionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VrInputSkeletalActionDataDefaultTypeInternal() {}
  union {
    VrInputSkeletalActionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VrInputSkeletalActionDataDefaultTypeInternal _VrInputSkeletalActionData_default_instance_;
PROTOBUF_CONSTEXPR VrSkeletalSummaryData::VrSkeletalSummaryData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fingercurl_)*/{}
  , /*decltype(_impl_.fingersplay_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VrSkeletalSummaryDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VrSkeletalSummaryDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VrSkeletalSummaryDataDefaultTypeInternal() {}
  union {
    VrSkeletalSummaryData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VrSkeletalSummaryDataDefaultTypeInternal _VrSkeletalSummaryData_default_instance_;
PROTOBUF_CONSTEXPR VrSkeletalData::VrSkeletalData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.compressed_bone_transforms_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.skeletal_action_data_)*/nullptr
  , /*decltype(_impl_.skeletal_summary_data_)*/nullptr
  , /*decltype(_impl_.bone_count_)*/0u
  , /*decltype(_impl_.bone_transform_source_)*/0u} {}
struct VrSkeletalDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VrSkeletalDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VrSkeletalDataDefaultTypeInternal() {}
  union {
    VrSkeletalData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VrSkeletalDataDefaultTypeInternal _VrSkeletalData_default_instance_;
PROTOBUF_CONSTEXPR CUerMsgVRActions::CUerMsgVRActions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.digital_action_data_)*/{}
  , /*decltype(_impl_.analog_action_data_)*/{}
  , /*decltype(_impl_.skeleton_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CUerMsgVRActionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CUerMsgVRActionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CUerMsgVRActionsDefaultTypeInternal() {}
  union {
    CUerMsgVRActions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CUerMsgVRActionsDefaultTypeInternal _CUerMsgVRActions_default_instance_;
PROTOBUF_CONSTEXPR VRSampleUserCmdPB::VRSampleUserCmdPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.hmd_)*/nullptr
  , /*decltype(_impl_.actions_)*/nullptr} {}
struct VRSampleUserCmdPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VRSampleUserCmdPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VRSampleUserCmdPBDefaultTypeInternal() {}
  union {
    VRSampleUserCmdPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VRSampleUserCmdPBDefaultTypeInternal _VRSampleUserCmdPB_default_instance_;
static ::_pb::Metadata file_level_metadata_usercmd_2eproto[19];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_usercmd_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_usercmd_2eproto = nullptr;

const uint32_t TableStruct_usercmd_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_.buttonstate1_),
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_.buttonstate2_),
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_.buttonstate3_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CTicklessMoveStep, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CTicklessMoveStep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CTicklessMoveStep, _impl_.button_),
  PROTOBUF_FIELD_OFFSET(::CTicklessMoveStep, _impl_.pressed_),
  PROTOBUF_FIELD_OFFSET(::CTicklessMoveStep, _impl_.when_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.command_number_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.tick_count_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.buttons_pb_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.viewangles_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.forwardmove_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.leftmove_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.upmove_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.impulse_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.weaponselect_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.random_seed_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.mousedx_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.mousedy_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.hasbeenpredicted_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.pawn_entity_handle_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.tickless_moves_),
  2,
  3,
  0,
  1,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CUserCmdBasePB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CUserCmdBasePB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CUserCmdBasePB, _impl_.base_),
  0,
  PROTOBUF_FIELD_OFFSET(::CHLXUserCmdPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CHLXUserCmdPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CHLXUserCmdPB, _impl_.base_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _impl_.spectator_query_unit_entindex_),
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _impl_.crosshairtrace_),
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _impl_.cameraposition_x_),
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _impl_.cameraposition_y_),
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _impl_.clickbehavior_),
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _impl_.statspanel_),
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _impl_.shoppanel_),
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _impl_.stats_dropdown_),
  PROTOBUF_FIELD_OFFSET(::CDota2UserCmdPB, _impl_.stats_dropdown_sort_),
  0,
  2,
  1,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::CCitadelUserCmdPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCitadelUserCmdPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCitadelUserCmdPB, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::CCitadelUserCmdPB, _impl_.vec_camera_position_),
  PROTOBUF_FIELD_OFFSET(::CCitadelUserCmdPB, _impl_.ang_camera_angles_),
  PROTOBUF_FIELD_OFFSET(::CCitadelUserCmdPB, _impl_.execute_ability_indices_),
  PROTOBUF_FIELD_OFFSET(::CCitadelUserCmdPB, _impl_.in_shop_),
  PROTOBUF_FIELD_OFFSET(::CCitadelUserCmdPB, _impl_.camera_roaming_speed_),
  PROTOBUF_FIELD_OFFSET(::CCitadelUserCmdPB, _impl_.spec_target_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.view_angles_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.shoot_position_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.render_tick_count_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.render_tick_fraction_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.player_tick_count_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.player_tick_fraction_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.target_ent_index_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.target_head_pos_check_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.target_pos_check_),
  0,
  1,
  4,
  5,
  6,
  7,
  8,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_.input_history_),
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_.attack1_start_history_index_),
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_.attack2_start_history_index_),
  0,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.vposition_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.angles_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.velocity_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.localposition_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.localangles_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.sampletime_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.filteredposition_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.filteredangles_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.filteredvelocity_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.filteredangularvel_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.filteredthrowvel_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.triggeranalogvalue_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.gripanalogvalue_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.finger0_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.finger1_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.finger2_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.finger3_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.finger4_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.fingersplay0_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.fingersplay1_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.fingersplay2_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.fingersplay3_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.trackpadanalogvaluex_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.trackpadanalogvaluey_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.joystickanalogvaluex_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRHandInfo, _impl_.joystickanalogvaluey_),
  0,
  1,
  2,
  3,
  4,
  10,
  5,
  6,
  7,
  8,
  9,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  PROTOBUF_FIELD_OFFSET(::CMsgVRController, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgVRController, _impl_.active_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRController, _impl_.supports_skeleton_),
  PROTOBUF_FIELD_OFFSET(::CMsgVRController, _impl_.info_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CUserMsgVRCore, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CUserMsgVRCore, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CUserMsgVRCore, _impl_.active_),
  PROTOBUF_FIELD_OFFSET(::CUserMsgVRCore, _impl_.targeting_mode_),
  PROTOBUF_FIELD_OFFSET(::CUserMsgVRCore, _impl_.controller_type_),
  PROTOBUF_FIELD_OFFSET(::CUserMsgVRCore, _impl_.middle_eye_local_),
  PROTOBUF_FIELD_OFFSET(::CUserMsgVRCore, _impl_.viewangles_local_),
  PROTOBUF_FIELD_OFFSET(::CUserMsgVRCore, _impl_.hmd_controllers_),
  2,
  3,
  4,
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::VrInputDigitalActionData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VrInputDigitalActionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VrInputDigitalActionData, _impl_.activeorigin_),
  PROTOBUF_FIELD_OFFSET(::VrInputDigitalActionData, _impl_.active_),
  PROTOBUF_FIELD_OFFSET(::VrInputDigitalActionData, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::VrInputDigitalActionData, _impl_.changed_),
  PROTOBUF_FIELD_OFFSET(::VrInputDigitalActionData, _impl_.updatetime_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::VrInputAnalogActionData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VrInputAnalogActionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VrInputAnalogActionData, _impl_.activeorigin_),
  PROTOBUF_FIELD_OFFSET(::VrInputAnalogActionData, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::VrInputAnalogActionData, _impl_.delta_),
  PROTOBUF_FIELD_OFFSET(::VrInputAnalogActionData, _impl_.active_),
  PROTOBUF_FIELD_OFFSET(::VrInputAnalogActionData, _impl_.updatetime_),
  2,
  0,
  1,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::VrInputSkeletalActionData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VrInputSkeletalActionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VrInputSkeletalActionData, _impl_.active_),
  PROTOBUF_FIELD_OFFSET(::VrInputSkeletalActionData, _impl_.activeorigin_),
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::VrSkeletalSummaryData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VrSkeletalSummaryData, _impl_.fingercurl_),
  PROTOBUF_FIELD_OFFSET(::VrSkeletalSummaryData, _impl_.fingersplay_),
  PROTOBUF_FIELD_OFFSET(::VrSkeletalData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VrSkeletalData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VrSkeletalData, _impl_.skeletal_action_data_),
  PROTOBUF_FIELD_OFFSET(::VrSkeletalData, _impl_.skeletal_summary_data_),
  PROTOBUF_FIELD_OFFSET(::VrSkeletalData, _impl_.bone_count_),
  PROTOBUF_FIELD_OFFSET(::VrSkeletalData, _impl_.bone_transform_source_),
  PROTOBUF_FIELD_OFFSET(::VrSkeletalData, _impl_.compressed_bone_transforms_),
  1,
  2,
  3,
  4,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CUerMsgVRActions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CUerMsgVRActions, _impl_.digital_action_data_),
  PROTOBUF_FIELD_OFFSET(::CUerMsgVRActions, _impl_.analog_action_data_),
  PROTOBUF_FIELD_OFFSET(::CUerMsgVRActions, _impl_.skeleton_),
  PROTOBUF_FIELD_OFFSET(::VRSampleUserCmdPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VRSampleUserCmdPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VRSampleUserCmdPB, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::VRSampleUserCmdPB, _impl_.hmd_),
  PROTOBUF_FIELD_OFFSET(::VRSampleUserCmdPB, _impl_.actions_),
  0,
  1,
  2,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::CInButtonStatePB)},
  { 12, 21, -1, sizeof(::CTicklessMoveStep)},
  { 24, 45, -1, sizeof(::CBaseUserCmdPB)},
  { 60, 67, -1, sizeof(::CUserCmdBasePB)},
  { 68, 75, -1, sizeof(::CHLXUserCmdPB)},
  { 76, 92, -1, sizeof(::CDota2UserCmdPB)},
  { 102, 115, -1, sizeof(::CCitadelUserCmdPB)},
  { 122, 137, -1, sizeof(::CSGOInputHistoryEntryPB)},
  { 146, 156, -1, sizeof(::CSGOUserCmdPB)},
  { 160, 192, -1, sizeof(::CMsgVRHandInfo)},
  { 218, 227, -1, sizeof(::CMsgVRController)},
  { 230, 242, -1, sizeof(::CUserMsgVRCore)},
  { 248, 259, -1, sizeof(::VrInputDigitalActionData)},
  { 264, 275, -1, sizeof(::VrInputAnalogActionData)},
  { 280, 288, -1, sizeof(::VrInputSkeletalActionData)},
  { 290, -1, -1, sizeof(::VrSkeletalSummaryData)},
  { 298, 309, -1, sizeof(::VrSkeletalData)},
  { 314, -1, -1, sizeof(::CUerMsgVRActions)},
  { 323, 332, -1, sizeof(::VRSampleUserCmdPB)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CInButtonStatePB_default_instance_._instance,
  &::_CTicklessMoveStep_default_instance_._instance,
  &::_CBaseUserCmdPB_default_instance_._instance,
  &::_CUserCmdBasePB_default_instance_._instance,
  &::_CHLXUserCmdPB_default_instance_._instance,
  &::_CDota2UserCmdPB_default_instance_._instance,
  &::_CCitadelUserCmdPB_default_instance_._instance,
  &::_CSGOInputHistoryEntryPB_default_instance_._instance,
  &::_CSGOUserCmdPB_default_instance_._instance,
  &::_CMsgVRHandInfo_default_instance_._instance,
  &::_CMsgVRController_default_instance_._instance,
  &::_CUserMsgVRCore_default_instance_._instance,
  &::_VrInputDigitalActionData_default_instance_._instance,
  &::_VrInputAnalogActionData_default_instance_._instance,
  &::_VrInputSkeletalActionData_default_instance_._instance,
  &::_VrSkeletalSummaryData_default_instance_._instance,
  &::_VrSkeletalData_default_instance_._instance,
  &::_CUerMsgVRActions_default_instance_._instance,
  &::_VRSampleUserCmdPB_default_instance_._instance,
};

const char descriptor_table_protodef_usercmd_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rusercmd.proto\032\026networkbasetypes.proto\""
  "T\n\020CInButtonStatePB\022\024\n\014buttonstate1\030\001 \001("
  "\004\022\024\n\014buttonstate2\030\002 \001(\004\022\024\n\014buttonstate3\030"
  "\003 \001(\004\"B\n\021CTicklessMoveStep\022\016\n\006button\030\001 \001"
  "(\005\022\017\n\007pressed\030\002 \001(\010\022\014\n\004when\030\003 \001(\002\"\205\003\n\016CB"
  "aseUserCmdPB\022\026\n\016command_number\030\001 \001(\005\022\022\n\n"
  "tick_count\030\002 \001(\005\022%\n\nbuttons_pb\030\003 \001(\0132\021.C"
  "InButtonStatePB\022\037\n\nviewangles\030\004 \001(\0132\013.CM"
  "sgQAngle\022\023\n\013forwardmove\030\005 \001(\002\022\020\n\010leftmov"
  "e\030\006 \001(\002\022\016\n\006upmove\030\007 \001(\002\022\017\n\007impulse\030\010 \001(\005"
  "\022\024\n\014weaponselect\030\t \001(\005\022\023\n\013random_seed\030\n "
  "\001(\005\022\017\n\007mousedx\030\013 \001(\005\022\017\n\007mousedy\030\014 \001(\005\022\030\n"
  "\020hasbeenpredicted\030\r \001(\010\022$\n\022pawn_entity_h"
  "andle\030\016 \001(\r:\01016777215\022*\n\016tickless_moves\030"
  "\022 \003(\0132\022.CTicklessMoveStep\"/\n\016CUserCmdBas"
  "ePB\022\035\n\004base\030\001 \001(\0132\017.CBaseUserCmdPB\".\n\rCH"
  "LXUserCmdPB\022\035\n\004base\030\001 \001(\0132\017.CBaseUserCmd"
  "PB\"\243\002\n\017CDota2UserCmdPB\022\035\n\004base\030\001 \001(\0132\017.C"
  "BaseUserCmdPB\022%\n\035spectator_query_unit_en"
  "tindex\030\002 \001(\005\022#\n\016crosshairtrace\030\003 \001(\0132\013.C"
  "MsgVector\022\030\n\020cameraposition_x\030\004 \001(\005\022\030\n\020c"
  "ameraposition_y\030\005 \001(\005\022\025\n\rclickbehavior\030\006"
  " \001(\r\022\022\n\nstatspanel\030\007 \001(\r\022\021\n\tshoppanel\030\010 "
  "\001(\r\022\026\n\016stats_dropdown\030\t \001(\r\022\033\n\023stats_dro"
  "pdown_sort\030\n \001(\r\"\355\001\n\021CCitadelUserCmdPB\022\035"
  "\n\004base\030\001 \001(\0132\017.CBaseUserCmdPB\022(\n\023vec_cam"
  "era_position\030\002 \001(\0132\013.CMsgVector\022&\n\021ang_c"
  "amera_angles\030\003 \001(\0132\013.CMsgQAngle\022\037\n\027execu"
  "te_ability_indices\030\004 \001(\005\022\017\n\007in_shop\030\005 \001("
  "\010\022\034\n\024camera_roaming_speed\030\006 \001(\002\022\027\n\013spec_"
  "target\030\007 \001(\005:\002-1\"\277\002\n\027CSGOInputHistoryEnt"
  "ryPB\022 \n\013view_angles\030\002 \001(\0132\013.CMsgQAngle\022#"
  "\n\016shoot_position\030\003 \001(\0132\013.CMsgVector\022\031\n\021r"
  "ender_tick_count\030\004 \001(\005\022\034\n\024render_tick_fr"
  "action\030\005 \001(\002\022\031\n\021player_tick_count\030\006 \001(\005\022"
  "\034\n\024player_tick_fraction\030\007 \001(\002\022\030\n\020target_"
  "ent_index\030\010 \001(\005\022*\n\025target_head_pos_check"
  "\030\t \001(\0132\013.CMsgVector\022%\n\020target_pos_check\030"
  "\n \001(\0132\013.CMsgVector\"\261\001\n\rCSGOUserCmdPB\022\035\n\004"
  "base\030\001 \001(\0132\017.CBaseUserCmdPB\022/\n\rinput_his"
  "tory\030\002 \003(\0132\030.CSGOInputHistoryEntryPB\022\'\n\033"
  "attack1_start_history_index\030\006 \001(\005:\002-1\022\'\n"
  "\033attack2_start_history_index\030\007 \001(\005:\002-1\"\343"
  "\005\n\016CMsgVRHandInfo\022\036\n\tvposition\030\001 \001(\0132\013.C"
  "MsgVector\022\033\n\006angles\030\002 \001(\0132\013.CMsgQAngle\022\035"
  "\n\010velocity\030\003 \001(\0132\013.CMsgVector\022\"\n\rlocalpo"
  "sition\030\004 \001(\0132\013.CMsgVector\022 \n\013localangles"
  "\030\005 \001(\0132\013.CMsgQAngle\022\022\n\nsampletime\030\006 \001(\002\022"
  "%\n\020filteredposition\030\007 \001(\0132\013.CMsgVector\022#"
  "\n\016filteredangles\030\010 \001(\0132\013.CMsgQAngle\022%\n\020f"
  "ilteredvelocity\030\t \001(\0132\013.CMsgVector\022\'\n\022fi"
  "lteredangularvel\030\n \001(\0132\013.CMsgVector\022%\n\020f"
  "ilteredthrowvel\030\013 \001(\0132\013.CMsgVector\022\032\n\022tr"
  "iggeranalogvalue\030\014 \001(\002\022\027\n\017gripanalogvalu"
  "e\030\r \001(\002\022\017\n\007finger0\030\016 \001(\002\022\017\n\007finger1\030\017 \001("
  "\002\022\017\n\007finger2\030\020 \001(\002\022\017\n\007finger3\030\021 \001(\002\022\017\n\007f"
  "inger4\030\022 \001(\002\022\024\n\014fingersplay0\030\023 \001(\002\022\024\n\014fi"
  "ngersplay1\030\024 \001(\002\022\024\n\014fingersplay2\030\025 \001(\002\022\024"
  "\n\014fingersplay3\030\026 \001(\002\022\034\n\024trackpadanalogva"
  "luex\030\027 \001(\002\022\034\n\024trackpadanalogvaluey\030\030 \001(\002"
  "\022\034\n\024joystickanalogvaluex\030\031 \001(\002\022\034\n\024joysti"
  "ckanalogvaluey\030\032 \001(\002\"\\\n\020CMsgVRController"
  "\022\016\n\006active\030\001 \001(\010\022\031\n\021supports_skeleton\030\002 "
  "\001(\010\022\035\n\004info\030\003 \001(\0132\017.CMsgVRHandInfo\"\313\001\n\016C"
  "UserMsgVRCore\022\016\n\006active\030\001 \001(\010\022\026\n\016targeti"
  "ng_mode\030\002 \001(\010\022\027\n\017controller_type\030\003 \001(\r\022%"
  "\n\020middle_eye_local\030\004 \001(\0132\013.CMsgVector\022%\n"
  "\020viewangles_local\030\005 \001(\0132\013.CMsgQAngle\022*\n\017"
  "hmd_controllers\030\006 \003(\0132\021.CMsgVRController"
  "\"t\n\030VrInputDigitalActionData\022\024\n\014activeor"
  "igin\030\001 \001(\004\022\016\n\006active\030\002 \001(\010\022\r\n\005state\030\003 \001("
  "\010\022\017\n\007changed\030\004 \001(\010\022\022\n\nupdatetime\030\005 \001(\002\"\216"
  "\001\n\027VrInputAnalogActionData\022\024\n\014activeorig"
  "in\030\001 \001(\004\022\035\n\010position\030\002 \001(\0132\013.CMsgVector\022"
  "\032\n\005delta\030\003 \001(\0132\013.CMsgVector\022\016\n\006active\030\004 "
  "\001(\010\022\022\n\nupdatetime\030\005 \001(\002\"A\n\031VrInputSkelet"
  "alActionData\022\016\n\006active\030\001 \001(\010\022\024\n\014activeor"
  "igin\030\002 \001(\004\"@\n\025VrSkeletalSummaryData\022\022\n\nf"
  "ingercurl\030\001 \003(\002\022\023\n\013fingersplay\030\002 \003(\002\"\330\001\n"
  "\016VrSkeletalData\0228\n\024skeletal_action_data\030"
  "\001 \001(\0132\032.VrInputSkeletalActionData\0225\n\025ske"
  "letal_summary_data\030\002 \001(\0132\026.VrSkeletalSum"
  "maryData\022\022\n\nbone_count\030\003 \001(\r\022\035\n\025bone_tra"
  "nsform_source\030\004 \001(\r\022\"\n\032compressed_bone_t"
  "ransforms\030\005 \001(\014\"\243\001\n\020CUerMsgVRActions\0226\n\023"
  "digital_action_data\030\001 \003(\0132\031.VrInputDigit"
  "alActionData\0224\n\022analog_action_data\030\002 \003(\013"
  "2\030.VrInputAnalogActionData\022!\n\010skeleton\030\003"
  " \003(\0132\017.VrSkeletalData\"t\n\021VRSampleUserCmd"
  "PB\022\035\n\004base\030\001 \001(\0132\017.CBaseUserCmdPB\022\034\n\003hmd"
  "\030\002 \001(\0132\017.CUserMsgVRCore\022\"\n\007actions\030\003 \001(\013"
  "2\021.CUerMsgVRActionsB\005H\001\200\001\000"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_usercmd_2eproto_deps[1] = {
  &::descriptor_table_networkbasetypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_usercmd_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_usercmd_2eproto = {
    false, false, 3666, descriptor_table_protodef_usercmd_2eproto,
    "usercmd.proto",
    &descriptor_table_usercmd_2eproto_once, descriptor_table_usercmd_2eproto_deps, 1, 19,
    schemas, file_default_instances, TableStruct_usercmd_2eproto::offsets,
    file_level_metadata_usercmd_2eproto, file_level_enum_descriptors_usercmd_2eproto,
    file_level_service_descriptors_usercmd_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_usercmd_2eproto_getter() {
  return &descriptor_table_usercmd_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_usercmd_2eproto(&descriptor_table_usercmd_2eproto);

// ===================================================================

class CInButtonStatePB::_Internal {
 public:
  using HasBits = decltype(std::declval<CInButtonStatePB>()._impl_._has_bits_);
  static void set_has_buttonstate1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_buttonstate2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_buttonstate3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CInButtonStatePB::CInButtonStatePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CInButtonStatePB)
}
CInButtonStatePB::CInButtonStatePB(const CInButtonStatePB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CInButtonStatePB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buttonstate1_){}
    , decltype(_impl_.buttonstate2_){}
    , decltype(_impl_.buttonstate3_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.buttonstate1_, &from._impl_.buttonstate1_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.buttonstate3_) -
    reinterpret_cast<char*>(&_impl_.buttonstate1_)) + sizeof(_impl_.buttonstate3_));
  // @@protoc_insertion_point(copy_constructor:CInButtonStatePB)
}

inline void CInButtonStatePB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buttonstate1_){uint64_t{0u}}
    , decltype(_impl_.buttonstate2_){uint64_t{0u}}
    , decltype(_impl_.buttonstate3_){uint64_t{0u}}
  };
}

CInButtonStatePB::~CInButtonStatePB() {
  // @@protoc_insertion_point(destructor:CInButtonStatePB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CInButtonStatePB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInButtonStatePB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CInButtonStatePB::Clear() {
// @@protoc_insertion_point(message_clear_start:CInButtonStatePB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.buttonstate1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.buttonstate3_) -
        reinterpret_cast<char*>(&_impl_.buttonstate1_)) + sizeof(_impl_.buttonstate3_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInButtonStatePB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 buttonstate1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_buttonstate1(&has_bits);
          _impl_.buttonstate1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 buttonstate2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_buttonstate2(&has_bits);
          _impl_.buttonstate2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 buttonstate3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_buttonstate3(&has_bits);
          _impl_.buttonstate3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInButtonStatePB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInButtonStatePB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 buttonstate1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_buttonstate1(), target);
  }

  // optional uint64 buttonstate2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_buttonstate2(), target);
  }

  // optional uint64 buttonstate3 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_buttonstate3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInButtonStatePB)
  return target;
}

size_t CInButtonStatePB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInButtonStatePB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 buttonstate1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_buttonstate1());
    }

    // optional uint64 buttonstate2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_buttonstate2());
    }

    // optional uint64 buttonstate3 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_buttonstate3());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInButtonStatePB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CInButtonStatePB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInButtonStatePB::GetClassData() const { return &_class_data_; }


void CInButtonStatePB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CInButtonStatePB*>(&to_msg);
  auto& from = static_cast<const CInButtonStatePB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CInButtonStatePB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.buttonstate1_ = from._impl_.buttonstate1_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.buttonstate2_ = from._impl_.buttonstate2_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.buttonstate3_ = from._impl_.buttonstate3_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInButtonStatePB::CopyFrom(const CInButtonStatePB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInButtonStatePB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInButtonStatePB::IsInitialized() const {
  return true;
}

void CInButtonStatePB::InternalSwap(CInButtonStatePB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CInButtonStatePB, _impl_.buttonstate3_)
      + sizeof(CInButtonStatePB::_impl_.buttonstate3_)
      - PROTOBUF_FIELD_OFFSET(CInButtonStatePB, _impl_.buttonstate1_)>(
          reinterpret_cast<char*>(&_impl_.buttonstate1_),
          reinterpret_cast<char*>(&other->_impl_.buttonstate1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CInButtonStatePB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[0]);
}

// ===================================================================

class CTicklessMoveStep::_Internal {
 public:
  using HasBits = decltype(std::declval<CTicklessMoveStep>()._impl_._has_bits_);
  static void set_has_button(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pressed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_when(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CTicklessMoveStep::CTicklessMoveStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CTicklessMoveStep)
}
CTicklessMoveStep::CTicklessMoveStep(const CTicklessMoveStep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CTicklessMoveStep* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.button_){}
    , decltype(_impl_.pressed_){}
    , decltype(_impl_.when_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.button_, &from._impl_.button_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.when_) -
    reinterpret_cast<char*>(&_impl_.button_)) + sizeof(_impl_.when_));
  // @@protoc_insertion_point(copy_constructor:CTicklessMoveStep)
}

inline void CTicklessMoveStep::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.button_){0}
    , decltype(_impl_.pressed_){false}
    , decltype(_impl_.when_){0}
  };
}

CTicklessMoveStep::~CTicklessMoveStep() {
  // @@protoc_insertion_point(destructor:CTicklessMoveStep)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CTicklessMoveStep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CTicklessMoveStep::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CTicklessMoveStep::Clear() {
// @@protoc_insertion_point(message_clear_start:CTicklessMoveStep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.button_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.when_) -
        reinterpret_cast<char*>(&_impl_.button_)) + sizeof(_impl_.when_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CTicklessMoveStep::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 button = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_button(&has_bits);
          _impl_.button_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool pressed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pressed(&has_bits);
          _impl_.pressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float when = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_when(&has_bits);
          _impl_.when_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTicklessMoveStep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CTicklessMoveStep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 button = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_button(), target);
  }

  // optional bool pressed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_pressed(), target);
  }

  // optional float when = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_when(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CTicklessMoveStep)
  return target;
}

size_t CTicklessMoveStep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CTicklessMoveStep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 button = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_button());
    }

    // optional bool pressed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional float when = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CTicklessMoveStep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CTicklessMoveStep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CTicklessMoveStep::GetClassData() const { return &_class_data_; }


void CTicklessMoveStep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CTicklessMoveStep*>(&to_msg);
  auto& from = static_cast<const CTicklessMoveStep&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CTicklessMoveStep)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.button_ = from._impl_.button_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pressed_ = from._impl_.pressed_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.when_ = from._impl_.when_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CTicklessMoveStep::CopyFrom(const CTicklessMoveStep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CTicklessMoveStep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTicklessMoveStep::IsInitialized() const {
  return true;
}

void CTicklessMoveStep::InternalSwap(CTicklessMoveStep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CTicklessMoveStep, _impl_.when_)
      + sizeof(CTicklessMoveStep::_impl_.when_)
      - PROTOBUF_FIELD_OFFSET(CTicklessMoveStep, _impl_.button_)>(
          reinterpret_cast<char*>(&_impl_.button_),
          reinterpret_cast<char*>(&other->_impl_.button_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CTicklessMoveStep::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[1]);
}

// ===================================================================

class CBaseUserCmdPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CBaseUserCmdPB>()._impl_._has_bits_);
  static void set_has_command_number(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tick_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CInButtonStatePB& buttons_pb(const CBaseUserCmdPB* msg);
  static void set_has_buttons_pb(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& viewangles(const CBaseUserCmdPB* msg);
  static void set_has_viewangles(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_forwardmove(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_leftmove(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_upmove(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_impulse(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_weaponselect(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_random_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_mousedx(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_mousedy(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_hasbeenpredicted(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_pawn_entity_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

const ::CInButtonStatePB&
CBaseUserCmdPB::_Internal::buttons_pb(const CBaseUserCmdPB* msg) {
  return *msg->_impl_.buttons_pb_;
}
const ::CMsgQAngle&
CBaseUserCmdPB::_Internal::viewangles(const CBaseUserCmdPB* msg) {
  return *msg->_impl_.viewangles_;
}
void CBaseUserCmdPB::clear_viewangles() {
  if (_impl_.viewangles_ != nullptr) _impl_.viewangles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CBaseUserCmdPB::CBaseUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CBaseUserCmdPB)
}
CBaseUserCmdPB::CBaseUserCmdPB(const CBaseUserCmdPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CBaseUserCmdPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tickless_moves_){from._impl_.tickless_moves_}
    , decltype(_impl_.buttons_pb_){nullptr}
    , decltype(_impl_.viewangles_){nullptr}
    , decltype(_impl_.command_number_){}
    , decltype(_impl_.tick_count_){}
    , decltype(_impl_.forwardmove_){}
    , decltype(_impl_.leftmove_){}
    , decltype(_impl_.upmove_){}
    , decltype(_impl_.impulse_){}
    , decltype(_impl_.weaponselect_){}
    , decltype(_impl_.random_seed_){}
    , decltype(_impl_.mousedx_){}
    , decltype(_impl_.mousedy_){}
    , decltype(_impl_.hasbeenpredicted_){}
    , decltype(_impl_.pawn_entity_handle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_buttons_pb()) {
    _this->_impl_.buttons_pb_ = new ::CInButtonStatePB(*from._impl_.buttons_pb_);
  }
  if (from._internal_has_viewangles()) {
    _this->_impl_.viewangles_ = new ::CMsgQAngle(*from._impl_.viewangles_);
  }
  ::memcpy(&_impl_.command_number_, &from._impl_.command_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pawn_entity_handle_) -
    reinterpret_cast<char*>(&_impl_.command_number_)) + sizeof(_impl_.pawn_entity_handle_));
  // @@protoc_insertion_point(copy_constructor:CBaseUserCmdPB)
}

inline void CBaseUserCmdPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tickless_moves_){arena}
    , decltype(_impl_.buttons_pb_){nullptr}
    , decltype(_impl_.viewangles_){nullptr}
    , decltype(_impl_.command_number_){0}
    , decltype(_impl_.tick_count_){0}
    , decltype(_impl_.forwardmove_){0}
    , decltype(_impl_.leftmove_){0}
    , decltype(_impl_.upmove_){0}
    , decltype(_impl_.impulse_){0}
    , decltype(_impl_.weaponselect_){0}
    , decltype(_impl_.random_seed_){0}
    , decltype(_impl_.mousedx_){0}
    , decltype(_impl_.mousedy_){0}
    , decltype(_impl_.hasbeenpredicted_){false}
    , decltype(_impl_.pawn_entity_handle_){16777215u}
  };
}

CBaseUserCmdPB::~CBaseUserCmdPB() {
  // @@protoc_insertion_point(destructor:CBaseUserCmdPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CBaseUserCmdPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tickless_moves_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.buttons_pb_;
  if (this != internal_default_instance()) delete _impl_.viewangles_;
}

void CBaseUserCmdPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CBaseUserCmdPB::Clear() {
// @@protoc_insertion_point(message_clear_start:CBaseUserCmdPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tickless_moves_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.buttons_pb_ != nullptr);
      _impl_.buttons_pb_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.viewangles_ != nullptr);
      _impl_.viewangles_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.command_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.impulse_) -
        reinterpret_cast<char*>(&_impl_.command_number_)) + sizeof(_impl_.impulse_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.weaponselect_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hasbeenpredicted_) -
        reinterpret_cast<char*>(&_impl_.weaponselect_)) + sizeof(_impl_.hasbeenpredicted_));
    _impl_.pawn_entity_handle_ = 16777215u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CBaseUserCmdPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 command_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_command_number(&has_bits);
          _impl_.command_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tick_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tick_count(&has_bits);
          _impl_.tick_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CInButtonStatePB buttons_pb = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_buttons_pb(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle viewangles = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_viewangles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float forwardmove = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_forwardmove(&has_bits);
          _impl_.forwardmove_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float leftmove = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_leftmove(&has_bits);
          _impl_.leftmove_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float upmove = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_upmove(&has_bits);
          _impl_.upmove_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 impulse = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_impulse(&has_bits);
          _impl_.impulse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 weaponselect = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_weaponselect(&has_bits);
          _impl_.weaponselect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 random_seed = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_random_seed(&has_bits);
          _impl_.random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mousedx = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_mousedx(&has_bits);
          _impl_.mousedx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mousedy = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_mousedy(&has_bits);
          _impl_.mousedy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hasbeenpredicted = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_hasbeenpredicted(&has_bits);
          _impl_.hasbeenpredicted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pawn_entity_handle = 14 [default = 16777215];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_pawn_entity_handle(&has_bits);
          _impl_.pawn_entity_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CTicklessMoveStep tickless_moves = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_tickless_moves(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CBaseUserCmdPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CBaseUserCmdPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 command_number = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_command_number(), target);
  }

  // optional int32 tick_count = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_tick_count(), target);
  }

  // optional .CInButtonStatePB buttons_pb = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::buttons_pb(this),
        _Internal::buttons_pb(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle viewangles = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::viewangles(this),
        _Internal::viewangles(this).GetCachedSize(), target, stream);
  }

  // optional float forwardmove = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_forwardmove(), target);
  }

  // optional float leftmove = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_leftmove(), target);
  }

  // optional float upmove = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_upmove(), target);
  }

  // optional int32 impulse = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_impulse(), target);
  }

  // optional int32 weaponselect = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_weaponselect(), target);
  }

  // optional int32 random_seed = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_random_seed(), target);
  }

  // optional int32 mousedx = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_mousedx(), target);
  }

  // optional int32 mousedy = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_mousedy(), target);
  }

  // optional bool hasbeenpredicted = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_hasbeenpredicted(), target);
  }

  // optional uint32 pawn_entity_handle = 14 [default = 16777215];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_pawn_entity_handle(), target);
  }

  // repeated .CTicklessMoveStep tickless_moves = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tickless_moves_size()); i < n; i++) {
    const auto& repfield = this->_internal_tickless_moves(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CBaseUserCmdPB)
  return target;
}

size_t CBaseUserCmdPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CBaseUserCmdPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CTicklessMoveStep tickless_moves = 18;
  total_size += 2UL * this->_internal_tickless_moves_size();
  for (const auto& msg : this->_impl_.tickless_moves_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CInButtonStatePB buttons_pb = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.buttons_pb_);
    }

    // optional .CMsgQAngle viewangles = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.viewangles_);
    }

    // optional int32 command_number = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_command_number());
    }

    // optional int32 tick_count = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tick_count());
    }

    // optional float forwardmove = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float leftmove = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float upmove = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional int32 impulse = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_impulse());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional int32 weaponselect = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_weaponselect());
    }

    // optional int32 random_seed = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_random_seed());
    }

    // optional int32 mousedx = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mousedx());
    }

    // optional int32 mousedy = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mousedy());
    }

    // optional bool hasbeenpredicted = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional uint32 pawn_entity_handle = 14 [default = 16777215];
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pawn_entity_handle());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CBaseUserCmdPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CBaseUserCmdPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CBaseUserCmdPB::GetClassData() const { return &_class_data_; }


void CBaseUserCmdPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CBaseUserCmdPB*>(&to_msg);
  auto& from = static_cast<const CBaseUserCmdPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CBaseUserCmdPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tickless_moves_.MergeFrom(from._impl_.tickless_moves_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_buttons_pb()->::CInButtonStatePB::MergeFrom(
          from._internal_buttons_pb());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_viewangles()->::CMsgQAngle::MergeFrom(
          from._internal_viewangles());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.command_number_ = from._impl_.command_number_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.tick_count_ = from._impl_.tick_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.forwardmove_ = from._impl_.forwardmove_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.leftmove_ = from._impl_.leftmove_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.upmove_ = from._impl_.upmove_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.impulse_ = from._impl_.impulse_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.weaponselect_ = from._impl_.weaponselect_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.random_seed_ = from._impl_.random_seed_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.mousedx_ = from._impl_.mousedx_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.mousedy_ = from._impl_.mousedy_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.hasbeenpredicted_ = from._impl_.hasbeenpredicted_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.pawn_entity_handle_ = from._impl_.pawn_entity_handle_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CBaseUserCmdPB::CopyFrom(const CBaseUserCmdPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CBaseUserCmdPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CBaseUserCmdPB::IsInitialized() const {
  return true;
}

void CBaseUserCmdPB::InternalSwap(CBaseUserCmdPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tickless_moves_.InternalSwap(&other->_impl_.tickless_moves_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CBaseUserCmdPB, _impl_.hasbeenpredicted_)
      + sizeof(CBaseUserCmdPB::_impl_.hasbeenpredicted_)
      - PROTOBUF_FIELD_OFFSET(CBaseUserCmdPB, _impl_.buttons_pb_)>(
          reinterpret_cast<char*>(&_impl_.buttons_pb_),
          reinterpret_cast<char*>(&other->_impl_.buttons_pb_));
  swap(_impl_.pawn_entity_handle_, other->_impl_.pawn_entity_handle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CBaseUserCmdPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[2]);
}

// ===================================================================

class CUserCmdBasePB::_Internal {
 public:
  using HasBits = decltype(std::declval<CUserCmdBasePB>()._impl_._has_bits_);
  static const ::CBaseUserCmdPB& base(const CUserCmdBasePB* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CBaseUserCmdPB&
CUserCmdBasePB::_Internal::base(const CUserCmdBasePB* msg) {
  return *msg->_impl_.base_;
}
CUserCmdBasePB::CUserCmdBasePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CUserCmdBasePB)
}
CUserCmdBasePB::CUserCmdBasePB(const CUserCmdBasePB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CUserCmdBasePB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CBaseUserCmdPB(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:CUserCmdBasePB)
}

inline void CUserCmdBasePB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
  };
}

CUserCmdBasePB::~CUserCmdBasePB() {
  // @@protoc_insertion_point(destructor:CUserCmdBasePB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CUserCmdBasePB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
}

void CUserCmdBasePB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CUserCmdBasePB::Clear() {
// @@protoc_insertion_point(message_clear_start:CUserCmdBasePB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.base_ != nullptr);
    _impl_.base_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CUserCmdBasePB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CBaseUserCmdPB base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CUserCmdBasePB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CUserCmdBasePB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CBaseUserCmdPB base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CUserCmdBasePB)
  return target;
}

size_t CUserCmdBasePB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CUserCmdBasePB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CBaseUserCmdPB base = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CUserCmdBasePB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CUserCmdBasePB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CUserCmdBasePB::GetClassData() const { return &_class_data_; }


void CUserCmdBasePB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CUserCmdBasePB*>(&to_msg);
  auto& from = static_cast<const CUserCmdBasePB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CUserCmdBasePB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::CBaseUserCmdPB::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CUserCmdBasePB::CopyFrom(const CUserCmdBasePB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CUserCmdBasePB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CUserCmdBasePB::IsInitialized() const {
  return true;
}

void CUserCmdBasePB::InternalSwap(CUserCmdBasePB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CUserCmdBasePB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[3]);
}

// ===================================================================

class CHLXUserCmdPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CHLXUserCmdPB>()._impl_._has_bits_);
  static const ::CBaseUserCmdPB& base(const CHLXUserCmdPB* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CBaseUserCmdPB&
CHLXUserCmdPB::_Internal::base(const CHLXUserCmdPB* msg) {
  return *msg->_impl_.base_;
}
CHLXUserCmdPB::CHLXUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CHLXUserCmdPB)
}
CHLXUserCmdPB::CHLXUserCmdPB(const CHLXUserCmdPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CHLXUserCmdPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CBaseUserCmdPB(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:CHLXUserCmdPB)
}

inline void CHLXUserCmdPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
  };
}

CHLXUserCmdPB::~CHLXUserCmdPB() {
  // @@protoc_insertion_point(destructor:CHLXUserCmdPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CHLXUserCmdPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
}

void CHLXUserCmdPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CHLXUserCmdPB::Clear() {
// @@protoc_insertion_point(message_clear_start:CHLXUserCmdPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.base_ != nullptr);
    _impl_.base_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CHLXUserCmdPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CBaseUserCmdPB base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CHLXUserCmdPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CHLXUserCmdPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CBaseUserCmdPB base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CHLXUserCmdPB)
  return target;
}

size_t CHLXUserCmdPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CHLXUserCmdPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CBaseUserCmdPB base = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CHLXUserCmdPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CHLXUserCmdPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CHLXUserCmdPB::GetClassData() const { return &_class_data_; }


void CHLXUserCmdPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CHLXUserCmdPB*>(&to_msg);
  auto& from = static_cast<const CHLXUserCmdPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CHLXUserCmdPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::CBaseUserCmdPB::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CHLXUserCmdPB::CopyFrom(const CHLXUserCmdPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CHLXUserCmdPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CHLXUserCmdPB::IsInitialized() const {
  return true;
}

void CHLXUserCmdPB::InternalSwap(CHLXUserCmdPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CHLXUserCmdPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[4]);
}

// ===================================================================

class CDota2UserCmdPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CDota2UserCmdPB>()._impl_._has_bits_);
  static const ::CBaseUserCmdPB& base(const CDota2UserCmdPB* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_spectator_query_unit_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgVector& crosshairtrace(const CDota2UserCmdPB* msg);
  static void set_has_crosshairtrace(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cameraposition_x(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_cameraposition_y(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_clickbehavior(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_statspanel(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_shoppanel(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_stats_dropdown(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_stats_dropdown_sort(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::CBaseUserCmdPB&
CDota2UserCmdPB::_Internal::base(const CDota2UserCmdPB* msg) {
  return *msg->_impl_.base_;
}
const ::CMsgVector&
CDota2UserCmdPB::_Internal::crosshairtrace(const CDota2UserCmdPB* msg) {
  return *msg->_impl_.crosshairtrace_;
}
void CDota2UserCmdPB::clear_crosshairtrace() {
  if (_impl_.crosshairtrace_ != nullptr) _impl_.crosshairtrace_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CDota2UserCmdPB::CDota2UserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDota2UserCmdPB)
}
CDota2UserCmdPB::CDota2UserCmdPB(const CDota2UserCmdPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDota2UserCmdPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.crosshairtrace_){nullptr}
    , decltype(_impl_.spectator_query_unit_entindex_){}
    , decltype(_impl_.cameraposition_x_){}
    , decltype(_impl_.cameraposition_y_){}
    , decltype(_impl_.clickbehavior_){}
    , decltype(_impl_.statspanel_){}
    , decltype(_impl_.shoppanel_){}
    , decltype(_impl_.stats_dropdown_){}
    , decltype(_impl_.stats_dropdown_sort_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CBaseUserCmdPB(*from._impl_.base_);
  }
  if (from._internal_has_crosshairtrace()) {
    _this->_impl_.crosshairtrace_ = new ::CMsgVector(*from._impl_.crosshairtrace_);
  }
  ::memcpy(&_impl_.spectator_query_unit_entindex_, &from._impl_.spectator_query_unit_entindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stats_dropdown_sort_) -
    reinterpret_cast<char*>(&_impl_.spectator_query_unit_entindex_)) + sizeof(_impl_.stats_dropdown_sort_));
  // @@protoc_insertion_point(copy_constructor:CDota2UserCmdPB)
}

inline void CDota2UserCmdPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.crosshairtrace_){nullptr}
    , decltype(_impl_.spectator_query_unit_entindex_){0}
    , decltype(_impl_.cameraposition_x_){0}
    , decltype(_impl_.cameraposition_y_){0}
    , decltype(_impl_.clickbehavior_){0u}
    , decltype(_impl_.statspanel_){0u}
    , decltype(_impl_.shoppanel_){0u}
    , decltype(_impl_.stats_dropdown_){0u}
    , decltype(_impl_.stats_dropdown_sort_){0u}
  };
}

CDota2UserCmdPB::~CDota2UserCmdPB() {
  // @@protoc_insertion_point(destructor:CDota2UserCmdPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDota2UserCmdPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.crosshairtrace_;
}

void CDota2UserCmdPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDota2UserCmdPB::Clear() {
// @@protoc_insertion_point(message_clear_start:CDota2UserCmdPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.base_ != nullptr);
      _impl_.base_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.crosshairtrace_ != nullptr);
      _impl_.crosshairtrace_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.spectator_query_unit_entindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shoppanel_) -
        reinterpret_cast<char*>(&_impl_.spectator_query_unit_entindex_)) + sizeof(_impl_.shoppanel_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.stats_dropdown_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.stats_dropdown_sort_) -
        reinterpret_cast<char*>(&_impl_.stats_dropdown_)) + sizeof(_impl_.stats_dropdown_sort_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDota2UserCmdPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CBaseUserCmdPB base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 spectator_query_unit_entindex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_spectator_query_unit_entindex(&has_bits);
          _impl_.spectator_query_unit_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector crosshairtrace = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_crosshairtrace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cameraposition_x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_cameraposition_x(&has_bits);
          _impl_.cameraposition_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cameraposition_y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_cameraposition_y(&has_bits);
          _impl_.cameraposition_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 clickbehavior = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_clickbehavior(&has_bits);
          _impl_.clickbehavior_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 statspanel = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_statspanel(&has_bits);
          _impl_.statspanel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 shoppanel = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_shoppanel(&has_bits);
          _impl_.shoppanel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stats_dropdown = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_stats_dropdown(&has_bits);
          _impl_.stats_dropdown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stats_dropdown_sort = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_stats_dropdown_sort(&has_bits);
          _impl_.stats_dropdown_sort_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDota2UserCmdPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDota2UserCmdPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CBaseUserCmdPB base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // optional int32 spectator_query_unit_entindex = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_spectator_query_unit_entindex(), target);
  }

  // optional .CMsgVector crosshairtrace = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::crosshairtrace(this),
        _Internal::crosshairtrace(this).GetCachedSize(), target, stream);
  }

  // optional int32 cameraposition_x = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_cameraposition_x(), target);
  }

  // optional int32 cameraposition_y = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_cameraposition_y(), target);
  }

  // optional uint32 clickbehavior = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_clickbehavior(), target);
  }

  // optional uint32 statspanel = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_statspanel(), target);
  }

  // optional uint32 shoppanel = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_shoppanel(), target);
  }

  // optional uint32 stats_dropdown = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_stats_dropdown(), target);
  }

  // optional uint32 stats_dropdown_sort = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_stats_dropdown_sort(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDota2UserCmdPB)
  return target;
}

size_t CDota2UserCmdPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDota2UserCmdPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CBaseUserCmdPB base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional .CMsgVector crosshairtrace = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.crosshairtrace_);
    }

    // optional int32 spectator_query_unit_entindex = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_spectator_query_unit_entindex());
    }

    // optional int32 cameraposition_x = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cameraposition_x());
    }

    // optional int32 cameraposition_y = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cameraposition_y());
    }

    // optional uint32 clickbehavior = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_clickbehavior());
    }

    // optional uint32 statspanel = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_statspanel());
    }

    // optional uint32 shoppanel = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shoppanel());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 stats_dropdown = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stats_dropdown());
    }

    // optional uint32 stats_dropdown_sort = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stats_dropdown_sort());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDota2UserCmdPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDota2UserCmdPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDota2UserCmdPB::GetClassData() const { return &_class_data_; }


void CDota2UserCmdPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDota2UserCmdPB*>(&to_msg);
  auto& from = static_cast<const CDota2UserCmdPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDota2UserCmdPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CBaseUserCmdPB::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_crosshairtrace()->::CMsgVector::MergeFrom(
          from._internal_crosshairtrace());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.spectator_query_unit_entindex_ = from._impl_.spectator_query_unit_entindex_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.cameraposition_x_ = from._impl_.cameraposition_x_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.cameraposition_y_ = from._impl_.cameraposition_y_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.clickbehavior_ = from._impl_.clickbehavior_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.statspanel_ = from._impl_.statspanel_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.shoppanel_ = from._impl_.shoppanel_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.stats_dropdown_ = from._impl_.stats_dropdown_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.stats_dropdown_sort_ = from._impl_.stats_dropdown_sort_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDota2UserCmdPB::CopyFrom(const CDota2UserCmdPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDota2UserCmdPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDota2UserCmdPB::IsInitialized() const {
  return true;
}

void CDota2UserCmdPB::InternalSwap(CDota2UserCmdPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDota2UserCmdPB, _impl_.stats_dropdown_sort_)
      + sizeof(CDota2UserCmdPB::_impl_.stats_dropdown_sort_)
      - PROTOBUF_FIELD_OFFSET(CDota2UserCmdPB, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDota2UserCmdPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[5]);
}

// ===================================================================

class CCitadelUserCmdPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CCitadelUserCmdPB>()._impl_._has_bits_);
  static const ::CBaseUserCmdPB& base(const CCitadelUserCmdPB* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& vec_camera_position(const CCitadelUserCmdPB* msg);
  static void set_has_vec_camera_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgQAngle& ang_camera_angles(const CCitadelUserCmdPB* msg);
  static void set_has_ang_camera_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_execute_ability_indices(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_in_shop(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_camera_roaming_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_spec_target(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::CBaseUserCmdPB&
CCitadelUserCmdPB::_Internal::base(const CCitadelUserCmdPB* msg) {
  return *msg->_impl_.base_;
}
const ::CMsgVector&
CCitadelUserCmdPB::_Internal::vec_camera_position(const CCitadelUserCmdPB* msg) {
  return *msg->_impl_.vec_camera_position_;
}
const ::CMsgQAngle&
CCitadelUserCmdPB::_Internal::ang_camera_angles(const CCitadelUserCmdPB* msg) {
  return *msg->_impl_.ang_camera_angles_;
}
void CCitadelUserCmdPB::clear_vec_camera_position() {
  if (_impl_.vec_camera_position_ != nullptr) _impl_.vec_camera_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CCitadelUserCmdPB::clear_ang_camera_angles() {
  if (_impl_.ang_camera_angles_ != nullptr) _impl_.ang_camera_angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CCitadelUserCmdPB::CCitadelUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCitadelUserCmdPB)
}
CCitadelUserCmdPB::CCitadelUserCmdPB(const CCitadelUserCmdPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCitadelUserCmdPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.vec_camera_position_){nullptr}
    , decltype(_impl_.ang_camera_angles_){nullptr}
    , decltype(_impl_.execute_ability_indices_){}
    , decltype(_impl_.in_shop_){}
    , decltype(_impl_.camera_roaming_speed_){}
    , decltype(_impl_.spec_target_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CBaseUserCmdPB(*from._impl_.base_);
  }
  if (from._internal_has_vec_camera_position()) {
    _this->_impl_.vec_camera_position_ = new ::CMsgVector(*from._impl_.vec_camera_position_);
  }
  if (from._internal_has_ang_camera_angles()) {
    _this->_impl_.ang_camera_angles_ = new ::CMsgQAngle(*from._impl_.ang_camera_angles_);
  }
  ::memcpy(&_impl_.execute_ability_indices_, &from._impl_.execute_ability_indices_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.spec_target_) -
    reinterpret_cast<char*>(&_impl_.execute_ability_indices_)) + sizeof(_impl_.spec_target_));
  // @@protoc_insertion_point(copy_constructor:CCitadelUserCmdPB)
}

inline void CCitadelUserCmdPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.vec_camera_position_){nullptr}
    , decltype(_impl_.ang_camera_angles_){nullptr}
    , decltype(_impl_.execute_ability_indices_){0}
    , decltype(_impl_.in_shop_){false}
    , decltype(_impl_.camera_roaming_speed_){0}
    , decltype(_impl_.spec_target_){-1}
  };
}

CCitadelUserCmdPB::~CCitadelUserCmdPB() {
  // @@protoc_insertion_point(destructor:CCitadelUserCmdPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCitadelUserCmdPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.vec_camera_position_;
  if (this != internal_default_instance()) delete _impl_.ang_camera_angles_;
}

void CCitadelUserCmdPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCitadelUserCmdPB::Clear() {
// @@protoc_insertion_point(message_clear_start:CCitadelUserCmdPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.base_ != nullptr);
      _impl_.base_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.vec_camera_position_ != nullptr);
      _impl_.vec_camera_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.ang_camera_angles_ != nullptr);
      _impl_.ang_camera_angles_->Clear();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&_impl_.execute_ability_indices_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.camera_roaming_speed_) -
        reinterpret_cast<char*>(&_impl_.execute_ability_indices_)) + sizeof(_impl_.camera_roaming_speed_));
    _impl_.spec_target_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCitadelUserCmdPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CBaseUserCmdPB base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector vec_camera_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_vec_camera_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle ang_camera_angles = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ang_camera_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 execute_ability_indices = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_execute_ability_indices(&has_bits);
          _impl_.execute_ability_indices_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool in_shop = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_in_shop(&has_bits);
          _impl_.in_shop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float camera_roaming_speed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_camera_roaming_speed(&has_bits);
          _impl_.camera_roaming_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 spec_target = 7 [default = -1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_spec_target(&has_bits);
          _impl_.spec_target_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCitadelUserCmdPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCitadelUserCmdPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CBaseUserCmdPB base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector vec_camera_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::vec_camera_position(this),
        _Internal::vec_camera_position(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle ang_camera_angles = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::ang_camera_angles(this),
        _Internal::ang_camera_angles(this).GetCachedSize(), target, stream);
  }

  // optional int32 execute_ability_indices = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_execute_ability_indices(), target);
  }

  // optional bool in_shop = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_in_shop(), target);
  }

  // optional float camera_roaming_speed = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_camera_roaming_speed(), target);
  }

  // optional int32 spec_target = 7 [default = -1];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_spec_target(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCitadelUserCmdPB)
  return target;
}

size_t CCitadelUserCmdPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCitadelUserCmdPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .CBaseUserCmdPB base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional .CMsgVector vec_camera_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vec_camera_position_);
    }

    // optional .CMsgQAngle ang_camera_angles = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ang_camera_angles_);
    }

    // optional int32 execute_ability_indices = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_execute_ability_indices());
    }

    // optional bool in_shop = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional float camera_roaming_speed = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional int32 spec_target = 7 [default = -1];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_spec_target());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCitadelUserCmdPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCitadelUserCmdPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCitadelUserCmdPB::GetClassData() const { return &_class_data_; }


void CCitadelUserCmdPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCitadelUserCmdPB*>(&to_msg);
  auto& from = static_cast<const CCitadelUserCmdPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCitadelUserCmdPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CBaseUserCmdPB::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_vec_camera_position()->::CMsgVector::MergeFrom(
          from._internal_vec_camera_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_ang_camera_angles()->::CMsgQAngle::MergeFrom(
          from._internal_ang_camera_angles());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.execute_ability_indices_ = from._impl_.execute_ability_indices_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.in_shop_ = from._impl_.in_shop_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.camera_roaming_speed_ = from._impl_.camera_roaming_speed_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.spec_target_ = from._impl_.spec_target_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCitadelUserCmdPB::CopyFrom(const CCitadelUserCmdPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCitadelUserCmdPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCitadelUserCmdPB::IsInitialized() const {
  return true;
}

void CCitadelUserCmdPB::InternalSwap(CCitadelUserCmdPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCitadelUserCmdPB, _impl_.camera_roaming_speed_)
      + sizeof(CCitadelUserCmdPB::_impl_.camera_roaming_speed_)
      - PROTOBUF_FIELD_OFFSET(CCitadelUserCmdPB, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
  swap(_impl_.spec_target_, other->_impl_.spec_target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCitadelUserCmdPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[6]);
}

// ===================================================================

class CSGOInputHistoryEntryPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CSGOInputHistoryEntryPB>()._impl_._has_bits_);
  static const ::CMsgQAngle& view_angles(const CSGOInputHistoryEntryPB* msg);
  static void set_has_view_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& shoot_position(const CSGOInputHistoryEntryPB* msg);
  static void set_has_shoot_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_render_tick_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_render_tick_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_player_tick_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_player_tick_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_target_ent_index(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::CMsgVector& target_head_pos_check(const CSGOInputHistoryEntryPB* msg);
  static void set_has_target_head_pos_check(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgVector& target_pos_check(const CSGOInputHistoryEntryPB* msg);
  static void set_has_target_pos_check(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgQAngle&
CSGOInputHistoryEntryPB::_Internal::view_angles(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.view_angles_;
}
const ::CMsgVector&
CSGOInputHistoryEntryPB::_Internal::shoot_position(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.shoot_position_;
}
const ::CMsgVector&
CSGOInputHistoryEntryPB::_Internal::target_head_pos_check(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.target_head_pos_check_;
}
const ::CMsgVector&
CSGOInputHistoryEntryPB::_Internal::target_pos_check(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.target_pos_check_;
}
void CSGOInputHistoryEntryPB::clear_view_angles() {
  if (_impl_.view_angles_ != nullptr) _impl_.view_angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CSGOInputHistoryEntryPB::clear_shoot_position() {
  if (_impl_.shoot_position_ != nullptr) _impl_.shoot_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CSGOInputHistoryEntryPB::clear_target_head_pos_check() {
  if (_impl_.target_head_pos_check_ != nullptr) _impl_.target_head_pos_check_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CSGOInputHistoryEntryPB::clear_target_pos_check() {
  if (_impl_.target_pos_check_ != nullptr) _impl_.target_pos_check_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CSGOInputHistoryEntryPB::CSGOInputHistoryEntryPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSGOInputHistoryEntryPB)
}
CSGOInputHistoryEntryPB::CSGOInputHistoryEntryPB(const CSGOInputHistoryEntryPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSGOInputHistoryEntryPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.view_angles_){nullptr}
    , decltype(_impl_.shoot_position_){nullptr}
    , decltype(_impl_.target_head_pos_check_){nullptr}
    , decltype(_impl_.target_pos_check_){nullptr}
    , decltype(_impl_.render_tick_count_){}
    , decltype(_impl_.render_tick_fraction_){}
    , decltype(_impl_.player_tick_count_){}
    , decltype(_impl_.player_tick_fraction_){}
    , decltype(_impl_.target_ent_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_view_angles()) {
    _this->_impl_.view_angles_ = new ::CMsgQAngle(*from._impl_.view_angles_);
  }
  if (from._internal_has_shoot_position()) {
    _this->_impl_.shoot_position_ = new ::CMsgVector(*from._impl_.shoot_position_);
  }
  if (from._internal_has_target_head_pos_check()) {
    _this->_impl_.target_head_pos_check_ = new ::CMsgVector(*from._impl_.target_head_pos_check_);
  }
  if (from._internal_has_target_pos_check()) {
    _this->_impl_.target_pos_check_ = new ::CMsgVector(*from._impl_.target_pos_check_);
  }
  ::memcpy(&_impl_.render_tick_count_, &from._impl_.render_tick_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_ent_index_) -
    reinterpret_cast<char*>(&_impl_.render_tick_count_)) + sizeof(_impl_.target_ent_index_));
  // @@protoc_insertion_point(copy_constructor:CSGOInputHistoryEntryPB)
}

inline void CSGOInputHistoryEntryPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.view_angles_){nullptr}
    , decltype(_impl_.shoot_position_){nullptr}
    , decltype(_impl_.target_head_pos_check_){nullptr}
    , decltype(_impl_.target_pos_check_){nullptr}
    , decltype(_impl_.render_tick_count_){0}
    , decltype(_impl_.render_tick_fraction_){0}
    , decltype(_impl_.player_tick_count_){0}
    , decltype(_impl_.player_tick_fraction_){0}
    , decltype(_impl_.target_ent_index_){0}
  };
}

CSGOInputHistoryEntryPB::~CSGOInputHistoryEntryPB() {
  // @@protoc_insertion_point(destructor:CSGOInputHistoryEntryPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSGOInputHistoryEntryPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.view_angles_;
  if (this != internal_default_instance()) delete _impl_.shoot_position_;
  if (this != internal_default_instance()) delete _impl_.target_head_pos_check_;
  if (this != internal_default_instance()) delete _impl_.target_pos_check_;
}

void CSGOInputHistoryEntryPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSGOInputHistoryEntryPB::Clear() {
// @@protoc_insertion_point(message_clear_start:CSGOInputHistoryEntryPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.view_angles_ != nullptr);
      _impl_.view_angles_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.shoot_position_ != nullptr);
      _impl_.shoot_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.target_head_pos_check_ != nullptr);
      _impl_.target_head_pos_check_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.target_pos_check_ != nullptr);
      _impl_.target_pos_check_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.render_tick_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.player_tick_fraction_) -
        reinterpret_cast<char*>(&_impl_.render_tick_count_)) + sizeof(_impl_.player_tick_fraction_));
  }
  _impl_.target_ent_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSGOInputHistoryEntryPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgQAngle view_angles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_view_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector shoot_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_shoot_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 render_tick_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_render_tick_count(&has_bits);
          _impl_.render_tick_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float render_tick_fraction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_render_tick_fraction(&has_bits);
          _impl_.render_tick_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 player_tick_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_player_tick_count(&has_bits);
          _impl_.player_tick_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float player_tick_fraction = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_player_tick_fraction(&has_bits);
          _impl_.player_tick_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_ent_index = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_target_ent_index(&has_bits);
          _impl_.target_ent_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector target_head_pos_check = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_head_pos_check(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector target_pos_check = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_pos_check(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSGOInputHistoryEntryPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSGOInputHistoryEntryPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgQAngle view_angles = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::view_angles(this),
        _Internal::view_angles(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector shoot_position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::shoot_position(this),
        _Internal::shoot_position(this).GetCachedSize(), target, stream);
  }

  // optional int32 render_tick_count = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_render_tick_count(), target);
  }

  // optional float render_tick_fraction = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_render_tick_fraction(), target);
  }

  // optional int32 player_tick_count = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_player_tick_count(), target);
  }

  // optional float player_tick_fraction = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_player_tick_fraction(), target);
  }

  // optional int32 target_ent_index = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_target_ent_index(), target);
  }

  // optional .CMsgVector target_head_pos_check = 9;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::target_head_pos_check(this),
        _Internal::target_head_pos_check(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector target_pos_check = 10;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::target_pos_check(this),
        _Internal::target_pos_check(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSGOInputHistoryEntryPB)
  return target;
}

size_t CSGOInputHistoryEntryPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSGOInputHistoryEntryPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgQAngle view_angles = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.view_angles_);
    }

    // optional .CMsgVector shoot_position = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shoot_position_);
    }

    // optional .CMsgVector target_head_pos_check = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.target_head_pos_check_);
    }

    // optional .CMsgVector target_pos_check = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.target_pos_check_);
    }

    // optional int32 render_tick_count = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_render_tick_count());
    }

    // optional float render_tick_fraction = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional int32 player_tick_count = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_tick_count());
    }

    // optional float player_tick_fraction = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional int32 target_ent_index = 8;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_ent_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSGOInputHistoryEntryPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSGOInputHistoryEntryPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSGOInputHistoryEntryPB::GetClassData() const { return &_class_data_; }


void CSGOInputHistoryEntryPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSGOInputHistoryEntryPB*>(&to_msg);
  auto& from = static_cast<const CSGOInputHistoryEntryPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSGOInputHistoryEntryPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_view_angles()->::CMsgQAngle::MergeFrom(
          from._internal_view_angles());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_shoot_position()->::CMsgVector::MergeFrom(
          from._internal_shoot_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_target_head_pos_check()->::CMsgVector::MergeFrom(
          from._internal_target_head_pos_check());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_target_pos_check()->::CMsgVector::MergeFrom(
          from._internal_target_pos_check());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.render_tick_count_ = from._impl_.render_tick_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.render_tick_fraction_ = from._impl_.render_tick_fraction_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.player_tick_count_ = from._impl_.player_tick_count_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.player_tick_fraction_ = from._impl_.player_tick_fraction_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_target_ent_index(from._internal_target_ent_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSGOInputHistoryEntryPB::CopyFrom(const CSGOInputHistoryEntryPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSGOInputHistoryEntryPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGOInputHistoryEntryPB::IsInitialized() const {
  return true;
}

void CSGOInputHistoryEntryPB::InternalSwap(CSGOInputHistoryEntryPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSGOInputHistoryEntryPB, _impl_.target_ent_index_)
      + sizeof(CSGOInputHistoryEntryPB::_impl_.target_ent_index_)
      - PROTOBUF_FIELD_OFFSET(CSGOInputHistoryEntryPB, _impl_.view_angles_)>(
          reinterpret_cast<char*>(&_impl_.view_angles_),
          reinterpret_cast<char*>(&other->_impl_.view_angles_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSGOInputHistoryEntryPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[7]);
}

// ===================================================================

class CSGOUserCmdPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CSGOUserCmdPB>()._impl_._has_bits_);
  static const ::CBaseUserCmdPB& base(const CSGOUserCmdPB* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attack1_start_history_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attack2_start_history_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CBaseUserCmdPB&
CSGOUserCmdPB::_Internal::base(const CSGOUserCmdPB* msg) {
  return *msg->_impl_.base_;
}
CSGOUserCmdPB::CSGOUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSGOUserCmdPB)
}
CSGOUserCmdPB::CSGOUserCmdPB(const CSGOUserCmdPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSGOUserCmdPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.input_history_){from._impl_.input_history_}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.attack1_start_history_index_){}
    , decltype(_impl_.attack2_start_history_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CBaseUserCmdPB(*from._impl_.base_);
  }
  ::memcpy(&_impl_.attack1_start_history_index_, &from._impl_.attack1_start_history_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.attack2_start_history_index_) -
    reinterpret_cast<char*>(&_impl_.attack1_start_history_index_)) + sizeof(_impl_.attack2_start_history_index_));
  // @@protoc_insertion_point(copy_constructor:CSGOUserCmdPB)
}

inline void CSGOUserCmdPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.input_history_){arena}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.attack1_start_history_index_){-1}
    , decltype(_impl_.attack2_start_history_index_){-1}
  };
}

CSGOUserCmdPB::~CSGOUserCmdPB() {
  // @@protoc_insertion_point(destructor:CSGOUserCmdPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSGOUserCmdPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_history_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void CSGOUserCmdPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSGOUserCmdPB::Clear() {
// @@protoc_insertion_point(message_clear_start:CSGOUserCmdPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_history_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.base_ != nullptr);
      _impl_.base_->Clear();
    }
    _impl_.attack1_start_history_index_ = -1;
    _impl_.attack2_start_history_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSGOUserCmdPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CBaseUserCmdPB base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSGOInputHistoryEntryPB input_history = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input_history(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 attack1_start_history_index = 6 [default = -1];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_attack1_start_history_index(&has_bits);
          _impl_.attack1_start_history_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 attack2_start_history_index = 7 [default = -1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_attack2_start_history_index(&has_bits);
          _impl_.attack2_start_history_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSGOUserCmdPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSGOUserCmdPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CBaseUserCmdPB base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // repeated .CSGOInputHistoryEntryPB input_history = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_input_history_size()); i < n; i++) {
    const auto& repfield = this->_internal_input_history(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 attack1_start_history_index = 6 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_attack1_start_history_index(), target);
  }

  // optional int32 attack2_start_history_index = 7 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_attack2_start_history_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSGOUserCmdPB)
  return target;
}

size_t CSGOUserCmdPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSGOUserCmdPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSGOInputHistoryEntryPB input_history = 2;
  total_size += 1UL * this->_internal_input_history_size();
  for (const auto& msg : this->_impl_.input_history_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CBaseUserCmdPB base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional int32 attack1_start_history_index = 6 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_attack1_start_history_index());
    }

    // optional int32 attack2_start_history_index = 7 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_attack2_start_history_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSGOUserCmdPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSGOUserCmdPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSGOUserCmdPB::GetClassData() const { return &_class_data_; }


void CSGOUserCmdPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSGOUserCmdPB*>(&to_msg);
  auto& from = static_cast<const CSGOUserCmdPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSGOUserCmdPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.input_history_.MergeFrom(from._impl_.input_history_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CBaseUserCmdPB::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.attack1_start_history_index_ = from._impl_.attack1_start_history_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.attack2_start_history_index_ = from._impl_.attack2_start_history_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSGOUserCmdPB::CopyFrom(const CSGOUserCmdPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSGOUserCmdPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGOUserCmdPB::IsInitialized() const {
  return true;
}

void CSGOUserCmdPB::InternalSwap(CSGOUserCmdPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.input_history_.InternalSwap(&other->_impl_.input_history_);
  swap(_impl_.base_, other->_impl_.base_);
  swap(_impl_.attack1_start_history_index_, other->_impl_.attack1_start_history_index_);
  swap(_impl_.attack2_start_history_index_, other->_impl_.attack2_start_history_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSGOUserCmdPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[8]);
}

// ===================================================================

class CMsgVRHandInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgVRHandInfo>()._impl_._has_bits_);
  static const ::CMsgVector& vposition(const CMsgVRHandInfo* msg);
  static void set_has_vposition(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& angles(const CMsgVRHandInfo* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& velocity(const CMsgVRHandInfo* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgVector& localposition(const CMsgVRHandInfo* msg);
  static void set_has_localposition(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgQAngle& localangles(const CMsgVRHandInfo* msg);
  static void set_has_localangles(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sampletime(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::CMsgVector& filteredposition(const CMsgVRHandInfo* msg);
  static void set_has_filteredposition(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::CMsgQAngle& filteredangles(const CMsgVRHandInfo* msg);
  static void set_has_filteredangles(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::CMsgVector& filteredvelocity(const CMsgVRHandInfo* msg);
  static void set_has_filteredvelocity(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::CMsgVector& filteredangularvel(const CMsgVRHandInfo* msg);
  static void set_has_filteredangularvel(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::CMsgVector& filteredthrowvel(const CMsgVRHandInfo* msg);
  static void set_has_filteredthrowvel(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_triggeranalogvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_gripanalogvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_finger0(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_finger1(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_finger2(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_finger3(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_finger4(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_fingersplay0(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_fingersplay1(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_fingersplay2(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_fingersplay3(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_trackpadanalogvaluex(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_trackpadanalogvaluey(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_joystickanalogvaluex(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_joystickanalogvaluey(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
};

const ::CMsgVector&
CMsgVRHandInfo::_Internal::vposition(const CMsgVRHandInfo* msg) {
  return *msg->_impl_.vposition_;
}
const ::CMsgQAngle&
CMsgVRHandInfo::_Internal::angles(const CMsgVRHandInfo* msg) {
  return *msg->_impl_.angles_;
}
const ::CMsgVector&
CMsgVRHandInfo::_Internal::velocity(const CMsgVRHandInfo* msg) {
  return *msg->_impl_.velocity_;
}
const ::CMsgVector&
CMsgVRHandInfo::_Internal::localposition(const CMsgVRHandInfo* msg) {
  return *msg->_impl_.localposition_;
}
const ::CMsgQAngle&
CMsgVRHandInfo::_Internal::localangles(const CMsgVRHandInfo* msg) {
  return *msg->_impl_.localangles_;
}
const ::CMsgVector&
CMsgVRHandInfo::_Internal::filteredposition(const CMsgVRHandInfo* msg) {
  return *msg->_impl_.filteredposition_;
}
const ::CMsgQAngle&
CMsgVRHandInfo::_Internal::filteredangles(const CMsgVRHandInfo* msg) {
  return *msg->_impl_.filteredangles_;
}
const ::CMsgVector&
CMsgVRHandInfo::_Internal::filteredvelocity(const CMsgVRHandInfo* msg) {
  return *msg->_impl_.filteredvelocity_;
}
const ::CMsgVector&
CMsgVRHandInfo::_Internal::filteredangularvel(const CMsgVRHandInfo* msg) {
  return *msg->_impl_.filteredangularvel_;
}
const ::CMsgVector&
CMsgVRHandInfo::_Internal::filteredthrowvel(const CMsgVRHandInfo* msg) {
  return *msg->_impl_.filteredthrowvel_;
}
void CMsgVRHandInfo::clear_vposition() {
  if (_impl_.vposition_ != nullptr) _impl_.vposition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgVRHandInfo::clear_angles() {
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgVRHandInfo::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CMsgVRHandInfo::clear_localposition() {
  if (_impl_.localposition_ != nullptr) _impl_.localposition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CMsgVRHandInfo::clear_localangles() {
  if (_impl_.localangles_ != nullptr) _impl_.localangles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CMsgVRHandInfo::clear_filteredposition() {
  if (_impl_.filteredposition_ != nullptr) _impl_.filteredposition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void CMsgVRHandInfo::clear_filteredangles() {
  if (_impl_.filteredangles_ != nullptr) _impl_.filteredangles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void CMsgVRHandInfo::clear_filteredvelocity() {
  if (_impl_.filteredvelocity_ != nullptr) _impl_.filteredvelocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void CMsgVRHandInfo::clear_filteredangularvel() {
  if (_impl_.filteredangularvel_ != nullptr) _impl_.filteredangularvel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void CMsgVRHandInfo::clear_filteredthrowvel() {
  if (_impl_.filteredthrowvel_ != nullptr) _impl_.filteredthrowvel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
CMsgVRHandInfo::CMsgVRHandInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgVRHandInfo)
}
CMsgVRHandInfo::CMsgVRHandInfo(const CMsgVRHandInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgVRHandInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vposition_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.localposition_){nullptr}
    , decltype(_impl_.localangles_){nullptr}
    , decltype(_impl_.filteredposition_){nullptr}
    , decltype(_impl_.filteredangles_){nullptr}
    , decltype(_impl_.filteredvelocity_){nullptr}
    , decltype(_impl_.filteredangularvel_){nullptr}
    , decltype(_impl_.filteredthrowvel_){nullptr}
    , decltype(_impl_.sampletime_){}
    , decltype(_impl_.triggeranalogvalue_){}
    , decltype(_impl_.gripanalogvalue_){}
    , decltype(_impl_.finger0_){}
    , decltype(_impl_.finger1_){}
    , decltype(_impl_.finger2_){}
    , decltype(_impl_.finger3_){}
    , decltype(_impl_.finger4_){}
    , decltype(_impl_.fingersplay0_){}
    , decltype(_impl_.fingersplay1_){}
    , decltype(_impl_.fingersplay2_){}
    , decltype(_impl_.fingersplay3_){}
    , decltype(_impl_.trackpadanalogvaluex_){}
    , decltype(_impl_.trackpadanalogvaluey_){}
    , decltype(_impl_.joystickanalogvaluex_){}
    , decltype(_impl_.joystickanalogvaluey_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_vposition()) {
    _this->_impl_.vposition_ = new ::CMsgVector(*from._impl_.vposition_);
  }
  if (from._internal_has_angles()) {
    _this->_impl_.angles_ = new ::CMsgQAngle(*from._impl_.angles_);
  }
  if (from._internal_has_velocity()) {
    _this->_impl_.velocity_ = new ::CMsgVector(*from._impl_.velocity_);
  }
  if (from._internal_has_localposition()) {
    _this->_impl_.localposition_ = new ::CMsgVector(*from._impl_.localposition_);
  }
  if (from._internal_has_localangles()) {
    _this->_impl_.localangles_ = new ::CMsgQAngle(*from._impl_.localangles_);
  }
  if (from._internal_has_filteredposition()) {
    _this->_impl_.filteredposition_ = new ::CMsgVector(*from._impl_.filteredposition_);
  }
  if (from._internal_has_filteredangles()) {
    _this->_impl_.filteredangles_ = new ::CMsgQAngle(*from._impl_.filteredangles_);
  }
  if (from._internal_has_filteredvelocity()) {
    _this->_impl_.filteredvelocity_ = new ::CMsgVector(*from._impl_.filteredvelocity_);
  }
  if (from._internal_has_filteredangularvel()) {
    _this->_impl_.filteredangularvel_ = new ::CMsgVector(*from._impl_.filteredangularvel_);
  }
  if (from._internal_has_filteredthrowvel()) {
    _this->_impl_.filteredthrowvel_ = new ::CMsgVector(*from._impl_.filteredthrowvel_);
  }
  ::memcpy(&_impl_.sampletime_, &from._impl_.sampletime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.joystickanalogvaluey_) -
    reinterpret_cast<char*>(&_impl_.sampletime_)) + sizeof(_impl_.joystickanalogvaluey_));
  // @@protoc_insertion_point(copy_constructor:CMsgVRHandInfo)
}

inline void CMsgVRHandInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vposition_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.localposition_){nullptr}
    , decltype(_impl_.localangles_){nullptr}
    , decltype(_impl_.filteredposition_){nullptr}
    , decltype(_impl_.filteredangles_){nullptr}
    , decltype(_impl_.filteredvelocity_){nullptr}
    , decltype(_impl_.filteredangularvel_){nullptr}
    , decltype(_impl_.filteredthrowvel_){nullptr}
    , decltype(_impl_.sampletime_){0}
    , decltype(_impl_.triggeranalogvalue_){0}
    , decltype(_impl_.gripanalogvalue_){0}
    , decltype(_impl_.finger0_){0}
    , decltype(_impl_.finger1_){0}
    , decltype(_impl_.finger2_){0}
    , decltype(_impl_.finger3_){0}
    , decltype(_impl_.finger4_){0}
    , decltype(_impl_.fingersplay0_){0}
    , decltype(_impl_.fingersplay1_){0}
    , decltype(_impl_.fingersplay2_){0}
    , decltype(_impl_.fingersplay3_){0}
    , decltype(_impl_.trackpadanalogvaluex_){0}
    , decltype(_impl_.trackpadanalogvaluey_){0}
    , decltype(_impl_.joystickanalogvaluex_){0}
    , decltype(_impl_.joystickanalogvaluey_){0}
  };
}

CMsgVRHandInfo::~CMsgVRHandInfo() {
  // @@protoc_insertion_point(destructor:CMsgVRHandInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgVRHandInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.vposition_;
  if (this != internal_default_instance()) delete _impl_.angles_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.localposition_;
  if (this != internal_default_instance()) delete _impl_.localangles_;
  if (this != internal_default_instance()) delete _impl_.filteredposition_;
  if (this != internal_default_instance()) delete _impl_.filteredangles_;
  if (this != internal_default_instance()) delete _impl_.filteredvelocity_;
  if (this != internal_default_instance()) delete _impl_.filteredangularvel_;
  if (this != internal_default_instance()) delete _impl_.filteredthrowvel_;
}

void CMsgVRHandInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgVRHandInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgVRHandInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.vposition_ != nullptr);
      _impl_.vposition_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.angles_ != nullptr);
      _impl_.angles_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.localposition_ != nullptr);
      _impl_.localposition_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.localangles_ != nullptr);
      _impl_.localangles_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.filteredposition_ != nullptr);
      _impl_.filteredposition_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.filteredangles_ != nullptr);
      _impl_.filteredangles_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.filteredvelocity_ != nullptr);
      _impl_.filteredvelocity_->Clear();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.filteredangularvel_ != nullptr);
      _impl_.filteredangularvel_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.filteredthrowvel_ != nullptr);
      _impl_.filteredthrowvel_->Clear();
    }
  }
  if (cached_has_bits & 0x0000fc00u) {
    ::memset(&_impl_.sampletime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.finger2_) -
        reinterpret_cast<char*>(&_impl_.sampletime_)) + sizeof(_impl_.finger2_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.finger3_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.trackpadanalogvaluey_) -
        reinterpret_cast<char*>(&_impl_.finger3_)) + sizeof(_impl_.trackpadanalogvaluey_));
  }
  if (cached_has_bits & 0x03000000u) {
    ::memset(&_impl_.joystickanalogvaluex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.joystickanalogvaluey_) -
        reinterpret_cast<char*>(&_impl_.joystickanalogvaluex_)) + sizeof(_impl_.joystickanalogvaluey_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgVRHandInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector vposition = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_vposition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle angles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector velocity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector localposition = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_localposition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle localangles = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_localangles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float sampletime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_sampletime(&has_bits);
          _impl_.sampletime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector filteredposition = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_filteredposition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle filteredangles = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_filteredangles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector filteredvelocity = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_filteredvelocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector filteredangularvel = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_filteredangularvel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector filteredthrowvel = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_filteredthrowvel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float triggeranalogvalue = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_triggeranalogvalue(&has_bits);
          _impl_.triggeranalogvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float gripanalogvalue = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_gripanalogvalue(&has_bits);
          _impl_.gripanalogvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float finger0 = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_finger0(&has_bits);
          _impl_.finger0_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float finger1 = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_finger1(&has_bits);
          _impl_.finger1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float finger2 = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_finger2(&has_bits);
          _impl_.finger2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float finger3 = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _Internal::set_has_finger3(&has_bits);
          _impl_.finger3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float finger4 = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _Internal::set_has_finger4(&has_bits);
          _impl_.finger4_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float fingersplay0 = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _Internal::set_has_fingersplay0(&has_bits);
          _impl_.fingersplay0_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float fingersplay1 = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 165)) {
          _Internal::set_has_fingersplay1(&has_bits);
          _impl_.fingersplay1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float fingersplay2 = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _Internal::set_has_fingersplay2(&has_bits);
          _impl_.fingersplay2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float fingersplay3 = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          _Internal::set_has_fingersplay3(&has_bits);
          _impl_.fingersplay3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float trackpadanalogvaluex = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 189)) {
          _Internal::set_has_trackpadanalogvaluex(&has_bits);
          _impl_.trackpadanalogvaluex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float trackpadanalogvaluey = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 197)) {
          _Internal::set_has_trackpadanalogvaluey(&has_bits);
          _impl_.trackpadanalogvaluey_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float joystickanalogvaluex = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          _Internal::set_has_joystickanalogvaluex(&has_bits);
          _impl_.joystickanalogvaluex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float joystickanalogvaluey = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 213)) {
          _Internal::set_has_joystickanalogvaluey(&has_bits);
          _impl_.joystickanalogvaluey_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgVRHandInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgVRHandInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector vposition = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::vposition(this),
        _Internal::vposition(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angles(this),
        _Internal::angles(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector velocity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector localposition = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::localposition(this),
        _Internal::localposition(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle localangles = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::localangles(this),
        _Internal::localangles(this).GetCachedSize(), target, stream);
  }

  // optional float sampletime = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_sampletime(), target);
  }

  // optional .CMsgVector filteredposition = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::filteredposition(this),
        _Internal::filteredposition(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle filteredangles = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::filteredangles(this),
        _Internal::filteredangles(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector filteredvelocity = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::filteredvelocity(this),
        _Internal::filteredvelocity(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector filteredangularvel = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::filteredangularvel(this),
        _Internal::filteredangularvel(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector filteredthrowvel = 11;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::filteredthrowvel(this),
        _Internal::filteredthrowvel(this).GetCachedSize(), target, stream);
  }

  // optional float triggeranalogvalue = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_triggeranalogvalue(), target);
  }

  // optional float gripanalogvalue = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_gripanalogvalue(), target);
  }

  // optional float finger0 = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_finger0(), target);
  }

  // optional float finger1 = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_finger1(), target);
  }

  // optional float finger2 = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_finger2(), target);
  }

  // optional float finger3 = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_finger3(), target);
  }

  // optional float finger4 = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_finger4(), target);
  }

  // optional float fingersplay0 = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(19, this->_internal_fingersplay0(), target);
  }

  // optional float fingersplay1 = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(20, this->_internal_fingersplay1(), target);
  }

  // optional float fingersplay2 = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(21, this->_internal_fingersplay2(), target);
  }

  // optional float fingersplay3 = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(22, this->_internal_fingersplay3(), target);
  }

  // optional float trackpadanalogvaluex = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(23, this->_internal_trackpadanalogvaluex(), target);
  }

  // optional float trackpadanalogvaluey = 24;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(24, this->_internal_trackpadanalogvaluey(), target);
  }

  // optional float joystickanalogvaluex = 25;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(25, this->_internal_joystickanalogvaluex(), target);
  }

  // optional float joystickanalogvaluey = 26;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(26, this->_internal_joystickanalogvaluey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgVRHandInfo)
  return target;
}

size_t CMsgVRHandInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgVRHandInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgVector vposition = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vposition_);
    }

    // optional .CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.angles_);
    }

    // optional .CMsgVector velocity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // optional .CMsgVector localposition = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.localposition_);
    }

    // optional .CMsgQAngle localangles = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.localangles_);
    }

    // optional .CMsgVector filteredposition = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filteredposition_);
    }

    // optional .CMsgQAngle filteredangles = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filteredangles_);
    }

    // optional .CMsgVector filteredvelocity = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filteredvelocity_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .CMsgVector filteredangularvel = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filteredangularvel_);
    }

    // optional .CMsgVector filteredthrowvel = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filteredthrowvel_);
    }

    // optional float sampletime = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float triggeranalogvalue = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float gripanalogvalue = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float finger0 = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional float finger1 = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional float finger2 = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional float finger3 = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional float finger4 = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 4;
    }

    // optional float fingersplay0 = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 4;
    }

    // optional float fingersplay1 = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

    // optional float fingersplay2 = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 4;
    }

    // optional float fingersplay3 = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 4;
    }

    // optional float trackpadanalogvaluex = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 4;
    }

    // optional float trackpadanalogvaluey = 24;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x03000000u) {
    // optional float joystickanalogvaluex = 25;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 4;
    }

    // optional float joystickanalogvaluey = 26;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgVRHandInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgVRHandInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgVRHandInfo::GetClassData() const { return &_class_data_; }


void CMsgVRHandInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgVRHandInfo*>(&to_msg);
  auto& from = static_cast<const CMsgVRHandInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgVRHandInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_vposition()->::CMsgVector::MergeFrom(
          from._internal_vposition());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_angles()->::CMsgQAngle::MergeFrom(
          from._internal_angles());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_velocity()->::CMsgVector::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_localposition()->::CMsgVector::MergeFrom(
          from._internal_localposition());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_localangles()->::CMsgQAngle::MergeFrom(
          from._internal_localangles());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_filteredposition()->::CMsgVector::MergeFrom(
          from._internal_filteredposition());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_filteredangles()->::CMsgQAngle::MergeFrom(
          from._internal_filteredangles());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_filteredvelocity()->::CMsgVector::MergeFrom(
          from._internal_filteredvelocity());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_filteredangularvel()->::CMsgVector::MergeFrom(
          from._internal_filteredangularvel());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_filteredthrowvel()->::CMsgVector::MergeFrom(
          from._internal_filteredthrowvel());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.sampletime_ = from._impl_.sampletime_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.triggeranalogvalue_ = from._impl_.triggeranalogvalue_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.gripanalogvalue_ = from._impl_.gripanalogvalue_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.finger0_ = from._impl_.finger0_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.finger1_ = from._impl_.finger1_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.finger2_ = from._impl_.finger2_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.finger3_ = from._impl_.finger3_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.finger4_ = from._impl_.finger4_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.fingersplay0_ = from._impl_.fingersplay0_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.fingersplay1_ = from._impl_.fingersplay1_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.fingersplay2_ = from._impl_.fingersplay2_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.fingersplay3_ = from._impl_.fingersplay3_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.trackpadanalogvaluex_ = from._impl_.trackpadanalogvaluex_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.trackpadanalogvaluey_ = from._impl_.trackpadanalogvaluey_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x03000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.joystickanalogvaluex_ = from._impl_.joystickanalogvaluex_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.joystickanalogvaluey_ = from._impl_.joystickanalogvaluey_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgVRHandInfo::CopyFrom(const CMsgVRHandInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgVRHandInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgVRHandInfo::IsInitialized() const {
  return true;
}

void CMsgVRHandInfo::InternalSwap(CMsgVRHandInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgVRHandInfo, _impl_.joystickanalogvaluey_)
      + sizeof(CMsgVRHandInfo::_impl_.joystickanalogvaluey_)
      - PROTOBUF_FIELD_OFFSET(CMsgVRHandInfo, _impl_.vposition_)>(
          reinterpret_cast<char*>(&_impl_.vposition_),
          reinterpret_cast<char*>(&other->_impl_.vposition_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgVRHandInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[9]);
}

// ===================================================================

class CMsgVRController::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgVRController>()._impl_._has_bits_);
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_supports_skeleton(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgVRHandInfo& info(const CMsgVRController* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgVRHandInfo&
CMsgVRController::_Internal::info(const CMsgVRController* msg) {
  return *msg->_impl_.info_;
}
CMsgVRController::CMsgVRController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgVRController)
}
CMsgVRController::CMsgVRController(const CMsgVRController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgVRController* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.active_){}
    , decltype(_impl_.supports_skeleton_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::CMsgVRHandInfo(*from._impl_.info_);
  }
  ::memcpy(&_impl_.active_, &from._impl_.active_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.supports_skeleton_) -
    reinterpret_cast<char*>(&_impl_.active_)) + sizeof(_impl_.supports_skeleton_));
  // @@protoc_insertion_point(copy_constructor:CMsgVRController)
}

inline void CMsgVRController::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.active_){false}
    , decltype(_impl_.supports_skeleton_){false}
  };
}

CMsgVRController::~CMsgVRController() {
  // @@protoc_insertion_point(destructor:CMsgVRController)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgVRController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void CMsgVRController::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgVRController::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgVRController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.info_ != nullptr);
    _impl_.info_->Clear();
  }
  ::memset(&_impl_.active_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.supports_skeleton_) -
      reinterpret_cast<char*>(&_impl_.active_)) + sizeof(_impl_.supports_skeleton_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgVRController::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_active(&has_bits);
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_skeleton = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_supports_skeleton(&has_bits);
          _impl_.supports_skeleton_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVRHandInfo info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgVRController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgVRController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool active = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_active(), target);
  }

  // optional bool supports_skeleton = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_supports_skeleton(), target);
  }

  // optional .CMsgVRHandInfo info = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgVRController)
  return target;
}

size_t CMsgVRController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgVRController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVRHandInfo info = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional bool active = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool supports_skeleton = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgVRController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgVRController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgVRController::GetClassData() const { return &_class_data_; }


void CMsgVRController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgVRController*>(&to_msg);
  auto& from = static_cast<const CMsgVRController&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgVRController)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_info()->::CMsgVRHandInfo::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.active_ = from._impl_.active_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.supports_skeleton_ = from._impl_.supports_skeleton_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgVRController::CopyFrom(const CMsgVRController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgVRController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgVRController::IsInitialized() const {
  return true;
}

void CMsgVRController::InternalSwap(CMsgVRController* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgVRController, _impl_.supports_skeleton_)
      + sizeof(CMsgVRController::_impl_.supports_skeleton_)
      - PROTOBUF_FIELD_OFFSET(CMsgVRController, _impl_.info_)>(
          reinterpret_cast<char*>(&_impl_.info_),
          reinterpret_cast<char*>(&other->_impl_.info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgVRController::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[10]);
}

// ===================================================================

class CUserMsgVRCore::_Internal {
 public:
  using HasBits = decltype(std::declval<CUserMsgVRCore>()._impl_._has_bits_);
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_targeting_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_controller_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgVector& middle_eye_local(const CUserMsgVRCore* msg);
  static void set_has_middle_eye_local(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& viewangles_local(const CUserMsgVRCore* msg);
  static void set_has_viewangles_local(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector&
CUserMsgVRCore::_Internal::middle_eye_local(const CUserMsgVRCore* msg) {
  return *msg->_impl_.middle_eye_local_;
}
const ::CMsgQAngle&
CUserMsgVRCore::_Internal::viewangles_local(const CUserMsgVRCore* msg) {
  return *msg->_impl_.viewangles_local_;
}
void CUserMsgVRCore::clear_middle_eye_local() {
  if (_impl_.middle_eye_local_ != nullptr) _impl_.middle_eye_local_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CUserMsgVRCore::clear_viewangles_local() {
  if (_impl_.viewangles_local_ != nullptr) _impl_.viewangles_local_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CUserMsgVRCore::CUserMsgVRCore(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CUserMsgVRCore)
}
CUserMsgVRCore::CUserMsgVRCore(const CUserMsgVRCore& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CUserMsgVRCore* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hmd_controllers_){from._impl_.hmd_controllers_}
    , decltype(_impl_.middle_eye_local_){nullptr}
    , decltype(_impl_.viewangles_local_){nullptr}
    , decltype(_impl_.active_){}
    , decltype(_impl_.targeting_mode_){}
    , decltype(_impl_.controller_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_middle_eye_local()) {
    _this->_impl_.middle_eye_local_ = new ::CMsgVector(*from._impl_.middle_eye_local_);
  }
  if (from._internal_has_viewangles_local()) {
    _this->_impl_.viewangles_local_ = new ::CMsgQAngle(*from._impl_.viewangles_local_);
  }
  ::memcpy(&_impl_.active_, &from._impl_.active_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.controller_type_) -
    reinterpret_cast<char*>(&_impl_.active_)) + sizeof(_impl_.controller_type_));
  // @@protoc_insertion_point(copy_constructor:CUserMsgVRCore)
}

inline void CUserMsgVRCore::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hmd_controllers_){arena}
    , decltype(_impl_.middle_eye_local_){nullptr}
    , decltype(_impl_.viewangles_local_){nullptr}
    , decltype(_impl_.active_){false}
    , decltype(_impl_.targeting_mode_){false}
    , decltype(_impl_.controller_type_){0u}
  };
}

CUserMsgVRCore::~CUserMsgVRCore() {
  // @@protoc_insertion_point(destructor:CUserMsgVRCore)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CUserMsgVRCore::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hmd_controllers_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.middle_eye_local_;
  if (this != internal_default_instance()) delete _impl_.viewangles_local_;
}

void CUserMsgVRCore::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CUserMsgVRCore::Clear() {
// @@protoc_insertion_point(message_clear_start:CUserMsgVRCore)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hmd_controllers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.middle_eye_local_ != nullptr);
      _impl_.middle_eye_local_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.viewangles_local_ != nullptr);
      _impl_.viewangles_local_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.active_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.controller_type_) -
        reinterpret_cast<char*>(&_impl_.active_)) + sizeof(_impl_.controller_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CUserMsgVRCore::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_active(&has_bits);
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool targeting_mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_targeting_mode(&has_bits);
          _impl_.targeting_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 controller_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_controller_type(&has_bits);
          _impl_.controller_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector middle_eye_local = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_middle_eye_local(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle viewangles_local = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_viewangles_local(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgVRController hmd_controllers = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hmd_controllers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CUserMsgVRCore::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CUserMsgVRCore)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool active = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_active(), target);
  }

  // optional bool targeting_mode = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_targeting_mode(), target);
  }

  // optional uint32 controller_type = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_controller_type(), target);
  }

  // optional .CMsgVector middle_eye_local = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::middle_eye_local(this),
        _Internal::middle_eye_local(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle viewangles_local = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::viewangles_local(this),
        _Internal::viewangles_local(this).GetCachedSize(), target, stream);
  }

  // repeated .CMsgVRController hmd_controllers = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hmd_controllers_size()); i < n; i++) {
    const auto& repfield = this->_internal_hmd_controllers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CUserMsgVRCore)
  return target;
}

size_t CUserMsgVRCore::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CUserMsgVRCore)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgVRController hmd_controllers = 6;
  total_size += 1UL * this->_internal_hmd_controllers_size();
  for (const auto& msg : this->_impl_.hmd_controllers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector middle_eye_local = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.middle_eye_local_);
    }

    // optional .CMsgQAngle viewangles_local = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.viewangles_local_);
    }

    // optional bool active = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool targeting_mode = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 controller_type = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_controller_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CUserMsgVRCore::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CUserMsgVRCore::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CUserMsgVRCore::GetClassData() const { return &_class_data_; }


void CUserMsgVRCore::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CUserMsgVRCore*>(&to_msg);
  auto& from = static_cast<const CUserMsgVRCore&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CUserMsgVRCore)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hmd_controllers_.MergeFrom(from._impl_.hmd_controllers_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_middle_eye_local()->::CMsgVector::MergeFrom(
          from._internal_middle_eye_local());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_viewangles_local()->::CMsgQAngle::MergeFrom(
          from._internal_viewangles_local());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.active_ = from._impl_.active_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.targeting_mode_ = from._impl_.targeting_mode_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.controller_type_ = from._impl_.controller_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CUserMsgVRCore::CopyFrom(const CUserMsgVRCore& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CUserMsgVRCore)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CUserMsgVRCore::IsInitialized() const {
  return true;
}

void CUserMsgVRCore::InternalSwap(CUserMsgVRCore* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.hmd_controllers_.InternalSwap(&other->_impl_.hmd_controllers_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CUserMsgVRCore, _impl_.controller_type_)
      + sizeof(CUserMsgVRCore::_impl_.controller_type_)
      - PROTOBUF_FIELD_OFFSET(CUserMsgVRCore, _impl_.middle_eye_local_)>(
          reinterpret_cast<char*>(&_impl_.middle_eye_local_),
          reinterpret_cast<char*>(&other->_impl_.middle_eye_local_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CUserMsgVRCore::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[11]);
}

// ===================================================================

class VrInputDigitalActionData::_Internal {
 public:
  using HasBits = decltype(std::declval<VrInputDigitalActionData>()._impl_._has_bits_);
  static void set_has_activeorigin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_changed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_updatetime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

VrInputDigitalActionData::VrInputDigitalActionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VrInputDigitalActionData)
}
VrInputDigitalActionData::VrInputDigitalActionData(const VrInputDigitalActionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VrInputDigitalActionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.activeorigin_){}
    , decltype(_impl_.active_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.changed_){}
    , decltype(_impl_.updatetime_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.activeorigin_, &from._impl_.activeorigin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.updatetime_) -
    reinterpret_cast<char*>(&_impl_.activeorigin_)) + sizeof(_impl_.updatetime_));
  // @@protoc_insertion_point(copy_constructor:VrInputDigitalActionData)
}

inline void VrInputDigitalActionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.activeorigin_){uint64_t{0u}}
    , decltype(_impl_.active_){false}
    , decltype(_impl_.state_){false}
    , decltype(_impl_.changed_){false}
    , decltype(_impl_.updatetime_){0}
  };
}

VrInputDigitalActionData::~VrInputDigitalActionData() {
  // @@protoc_insertion_point(destructor:VrInputDigitalActionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VrInputDigitalActionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VrInputDigitalActionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VrInputDigitalActionData::Clear() {
// @@protoc_insertion_point(message_clear_start:VrInputDigitalActionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.activeorigin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.updatetime_) -
        reinterpret_cast<char*>(&_impl_.activeorigin_)) + sizeof(_impl_.updatetime_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VrInputDigitalActionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 activeorigin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_activeorigin(&has_bits);
          _impl_.activeorigin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool active = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_active(&has_bits);
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_state(&has_bits);
          _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool changed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_changed(&has_bits);
          _impl_.changed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float updatetime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_updatetime(&has_bits);
          _impl_.updatetime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VrInputDigitalActionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VrInputDigitalActionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 activeorigin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_activeorigin(), target);
  }

  // optional bool active = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_active(), target);
  }

  // optional bool state = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_state(), target);
  }

  // optional bool changed = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_changed(), target);
  }

  // optional float updatetime = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_updatetime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VrInputDigitalActionData)
  return target;
}

size_t VrInputDigitalActionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VrInputDigitalActionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 activeorigin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_activeorigin());
    }

    // optional bool active = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool state = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool changed = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional float updatetime = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VrInputDigitalActionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VrInputDigitalActionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VrInputDigitalActionData::GetClassData() const { return &_class_data_; }


void VrInputDigitalActionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VrInputDigitalActionData*>(&to_msg);
  auto& from = static_cast<const VrInputDigitalActionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VrInputDigitalActionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.activeorigin_ = from._impl_.activeorigin_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.active_ = from._impl_.active_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.changed_ = from._impl_.changed_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.updatetime_ = from._impl_.updatetime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VrInputDigitalActionData::CopyFrom(const VrInputDigitalActionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VrInputDigitalActionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VrInputDigitalActionData::IsInitialized() const {
  return true;
}

void VrInputDigitalActionData::InternalSwap(VrInputDigitalActionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VrInputDigitalActionData, _impl_.updatetime_)
      + sizeof(VrInputDigitalActionData::_impl_.updatetime_)
      - PROTOBUF_FIELD_OFFSET(VrInputDigitalActionData, _impl_.activeorigin_)>(
          reinterpret_cast<char*>(&_impl_.activeorigin_),
          reinterpret_cast<char*>(&other->_impl_.activeorigin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VrInputDigitalActionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[12]);
}

// ===================================================================

class VrInputAnalogActionData::_Internal {
 public:
  using HasBits = decltype(std::declval<VrInputAnalogActionData>()._impl_._has_bits_);
  static void set_has_activeorigin(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgVector& position(const VrInputAnalogActionData* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& delta(const VrInputAnalogActionData* msg);
  static void set_has_delta(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_updatetime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgVector&
VrInputAnalogActionData::_Internal::position(const VrInputAnalogActionData* msg) {
  return *msg->_impl_.position_;
}
const ::CMsgVector&
VrInputAnalogActionData::_Internal::delta(const VrInputAnalogActionData* msg) {
  return *msg->_impl_.delta_;
}
void VrInputAnalogActionData::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void VrInputAnalogActionData::clear_delta() {
  if (_impl_.delta_ != nullptr) _impl_.delta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
VrInputAnalogActionData::VrInputAnalogActionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VrInputAnalogActionData)
}
VrInputAnalogActionData::VrInputAnalogActionData(const VrInputAnalogActionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VrInputAnalogActionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.delta_){nullptr}
    , decltype(_impl_.activeorigin_){}
    , decltype(_impl_.active_){}
    , decltype(_impl_.updatetime_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::CMsgVector(*from._impl_.position_);
  }
  if (from._internal_has_delta()) {
    _this->_impl_.delta_ = new ::CMsgVector(*from._impl_.delta_);
  }
  ::memcpy(&_impl_.activeorigin_, &from._impl_.activeorigin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.updatetime_) -
    reinterpret_cast<char*>(&_impl_.activeorigin_)) + sizeof(_impl_.updatetime_));
  // @@protoc_insertion_point(copy_constructor:VrInputAnalogActionData)
}

inline void VrInputAnalogActionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.delta_){nullptr}
    , decltype(_impl_.activeorigin_){uint64_t{0u}}
    , decltype(_impl_.active_){false}
    , decltype(_impl_.updatetime_){0}
  };
}

VrInputAnalogActionData::~VrInputAnalogActionData() {
  // @@protoc_insertion_point(destructor:VrInputAnalogActionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VrInputAnalogActionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.delta_;
}

void VrInputAnalogActionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VrInputAnalogActionData::Clear() {
// @@protoc_insertion_point(message_clear_start:VrInputAnalogActionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.delta_ != nullptr);
      _impl_.delta_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.activeorigin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.updatetime_) -
        reinterpret_cast<char*>(&_impl_.activeorigin_)) + sizeof(_impl_.updatetime_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VrInputAnalogActionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 activeorigin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_activeorigin(&has_bits);
          _impl_.activeorigin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector delta = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_delta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool active = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_active(&has_bits);
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float updatetime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_updatetime(&has_bits);
          _impl_.updatetime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VrInputAnalogActionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VrInputAnalogActionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 activeorigin = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_activeorigin(), target);
  }

  // optional .CMsgVector position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector delta = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::delta(this),
        _Internal::delta(this).GetCachedSize(), target, stream);
  }

  // optional bool active = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_active(), target);
  }

  // optional float updatetime = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_updatetime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VrInputAnalogActionData)
  return target;
}

size_t VrInputAnalogActionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VrInputAnalogActionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector position = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .CMsgVector delta = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.delta_);
    }

    // optional uint64 activeorigin = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_activeorigin());
    }

    // optional bool active = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional float updatetime = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VrInputAnalogActionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VrInputAnalogActionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VrInputAnalogActionData::GetClassData() const { return &_class_data_; }


void VrInputAnalogActionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VrInputAnalogActionData*>(&to_msg);
  auto& from = static_cast<const VrInputAnalogActionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VrInputAnalogActionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::CMsgVector::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_delta()->::CMsgVector::MergeFrom(
          from._internal_delta());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.activeorigin_ = from._impl_.activeorigin_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.active_ = from._impl_.active_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.updatetime_ = from._impl_.updatetime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VrInputAnalogActionData::CopyFrom(const VrInputAnalogActionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VrInputAnalogActionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VrInputAnalogActionData::IsInitialized() const {
  return true;
}

void VrInputAnalogActionData::InternalSwap(VrInputAnalogActionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VrInputAnalogActionData, _impl_.updatetime_)
      + sizeof(VrInputAnalogActionData::_impl_.updatetime_)
      - PROTOBUF_FIELD_OFFSET(VrInputAnalogActionData, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VrInputAnalogActionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[13]);
}

// ===================================================================

class VrInputSkeletalActionData::_Internal {
 public:
  using HasBits = decltype(std::declval<VrInputSkeletalActionData>()._impl_._has_bits_);
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_activeorigin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

VrInputSkeletalActionData::VrInputSkeletalActionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VrInputSkeletalActionData)
}
VrInputSkeletalActionData::VrInputSkeletalActionData(const VrInputSkeletalActionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VrInputSkeletalActionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.activeorigin_){}
    , decltype(_impl_.active_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.activeorigin_, &from._impl_.activeorigin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.active_) -
    reinterpret_cast<char*>(&_impl_.activeorigin_)) + sizeof(_impl_.active_));
  // @@protoc_insertion_point(copy_constructor:VrInputSkeletalActionData)
}

inline void VrInputSkeletalActionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.activeorigin_){uint64_t{0u}}
    , decltype(_impl_.active_){false}
  };
}

VrInputSkeletalActionData::~VrInputSkeletalActionData() {
  // @@protoc_insertion_point(destructor:VrInputSkeletalActionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VrInputSkeletalActionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VrInputSkeletalActionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VrInputSkeletalActionData::Clear() {
// @@protoc_insertion_point(message_clear_start:VrInputSkeletalActionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.activeorigin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.active_) -
        reinterpret_cast<char*>(&_impl_.activeorigin_)) + sizeof(_impl_.active_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VrInputSkeletalActionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_active(&has_bits);
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 activeorigin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_activeorigin(&has_bits);
          _impl_.activeorigin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VrInputSkeletalActionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VrInputSkeletalActionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool active = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_active(), target);
  }

  // optional uint64 activeorigin = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_activeorigin(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VrInputSkeletalActionData)
  return target;
}

size_t VrInputSkeletalActionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VrInputSkeletalActionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 activeorigin = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_activeorigin());
    }

    // optional bool active = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VrInputSkeletalActionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VrInputSkeletalActionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VrInputSkeletalActionData::GetClassData() const { return &_class_data_; }


void VrInputSkeletalActionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VrInputSkeletalActionData*>(&to_msg);
  auto& from = static_cast<const VrInputSkeletalActionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VrInputSkeletalActionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.activeorigin_ = from._impl_.activeorigin_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.active_ = from._impl_.active_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VrInputSkeletalActionData::CopyFrom(const VrInputSkeletalActionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VrInputSkeletalActionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VrInputSkeletalActionData::IsInitialized() const {
  return true;
}

void VrInputSkeletalActionData::InternalSwap(VrInputSkeletalActionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VrInputSkeletalActionData, _impl_.active_)
      + sizeof(VrInputSkeletalActionData::_impl_.active_)
      - PROTOBUF_FIELD_OFFSET(VrInputSkeletalActionData, _impl_.activeorigin_)>(
          reinterpret_cast<char*>(&_impl_.activeorigin_),
          reinterpret_cast<char*>(&other->_impl_.activeorigin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VrInputSkeletalActionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[14]);
}

// ===================================================================

class VrSkeletalSummaryData::_Internal {
 public:
};

VrSkeletalSummaryData::VrSkeletalSummaryData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VrSkeletalSummaryData)
}
VrSkeletalSummaryData::VrSkeletalSummaryData(const VrSkeletalSummaryData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VrSkeletalSummaryData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fingercurl_){from._impl_.fingercurl_}
    , decltype(_impl_.fingersplay_){from._impl_.fingersplay_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:VrSkeletalSummaryData)
}

inline void VrSkeletalSummaryData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fingercurl_){arena}
    , decltype(_impl_.fingersplay_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VrSkeletalSummaryData::~VrSkeletalSummaryData() {
  // @@protoc_insertion_point(destructor:VrSkeletalSummaryData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VrSkeletalSummaryData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fingercurl_.~RepeatedField();
  _impl_.fingersplay_.~RepeatedField();
}

void VrSkeletalSummaryData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VrSkeletalSummaryData::Clear() {
// @@protoc_insertion_point(message_clear_start:VrSkeletalSummaryData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fingercurl_.Clear();
  _impl_.fingersplay_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VrSkeletalSummaryData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float fingercurl = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_fingercurl(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<13>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_fingercurl(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float fingersplay = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_fingersplay(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<21>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_fingersplay(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VrSkeletalSummaryData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VrSkeletalSummaryData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float fingercurl = 1;
  for (int i = 0, n = this->_internal_fingercurl_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_fingercurl(i), target);
  }

  // repeated float fingersplay = 2;
  for (int i = 0, n = this->_internal_fingersplay_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_fingersplay(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VrSkeletalSummaryData)
  return target;
}

size_t VrSkeletalSummaryData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VrSkeletalSummaryData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float fingercurl = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_fingercurl_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_fingercurl_size());
    total_size += data_size;
  }

  // repeated float fingersplay = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_fingersplay_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_fingersplay_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VrSkeletalSummaryData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VrSkeletalSummaryData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VrSkeletalSummaryData::GetClassData() const { return &_class_data_; }


void VrSkeletalSummaryData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VrSkeletalSummaryData*>(&to_msg);
  auto& from = static_cast<const VrSkeletalSummaryData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VrSkeletalSummaryData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fingercurl_.MergeFrom(from._impl_.fingercurl_);
  _this->_impl_.fingersplay_.MergeFrom(from._impl_.fingersplay_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VrSkeletalSummaryData::CopyFrom(const VrSkeletalSummaryData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VrSkeletalSummaryData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VrSkeletalSummaryData::IsInitialized() const {
  return true;
}

void VrSkeletalSummaryData::InternalSwap(VrSkeletalSummaryData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.fingercurl_.InternalSwap(&other->_impl_.fingercurl_);
  _impl_.fingersplay_.InternalSwap(&other->_impl_.fingersplay_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VrSkeletalSummaryData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[15]);
}

// ===================================================================

class VrSkeletalData::_Internal {
 public:
  using HasBits = decltype(std::declval<VrSkeletalData>()._impl_._has_bits_);
  static const ::VrInputSkeletalActionData& skeletal_action_data(const VrSkeletalData* msg);
  static void set_has_skeletal_action_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::VrSkeletalSummaryData& skeletal_summary_data(const VrSkeletalData* msg);
  static void set_has_skeletal_summary_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bone_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bone_transform_source(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_compressed_bone_transforms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::VrInputSkeletalActionData&
VrSkeletalData::_Internal::skeletal_action_data(const VrSkeletalData* msg) {
  return *msg->_impl_.skeletal_action_data_;
}
const ::VrSkeletalSummaryData&
VrSkeletalData::_Internal::skeletal_summary_data(const VrSkeletalData* msg) {
  return *msg->_impl_.skeletal_summary_data_;
}
VrSkeletalData::VrSkeletalData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VrSkeletalData)
}
VrSkeletalData::VrSkeletalData(const VrSkeletalData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VrSkeletalData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.compressed_bone_transforms_){}
    , decltype(_impl_.skeletal_action_data_){nullptr}
    , decltype(_impl_.skeletal_summary_data_){nullptr}
    , decltype(_impl_.bone_count_){}
    , decltype(_impl_.bone_transform_source_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.compressed_bone_transforms_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.compressed_bone_transforms_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_compressed_bone_transforms()) {
    _this->_impl_.compressed_bone_transforms_.Set(from._internal_compressed_bone_transforms(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_skeletal_action_data()) {
    _this->_impl_.skeletal_action_data_ = new ::VrInputSkeletalActionData(*from._impl_.skeletal_action_data_);
  }
  if (from._internal_has_skeletal_summary_data()) {
    _this->_impl_.skeletal_summary_data_ = new ::VrSkeletalSummaryData(*from._impl_.skeletal_summary_data_);
  }
  ::memcpy(&_impl_.bone_count_, &from._impl_.bone_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bone_transform_source_) -
    reinterpret_cast<char*>(&_impl_.bone_count_)) + sizeof(_impl_.bone_transform_source_));
  // @@protoc_insertion_point(copy_constructor:VrSkeletalData)
}

inline void VrSkeletalData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.compressed_bone_transforms_){}
    , decltype(_impl_.skeletal_action_data_){nullptr}
    , decltype(_impl_.skeletal_summary_data_){nullptr}
    , decltype(_impl_.bone_count_){0u}
    , decltype(_impl_.bone_transform_source_){0u}
  };
  _impl_.compressed_bone_transforms_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.compressed_bone_transforms_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VrSkeletalData::~VrSkeletalData() {
  // @@protoc_insertion_point(destructor:VrSkeletalData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VrSkeletalData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.compressed_bone_transforms_.Destroy();
  if (this != internal_default_instance()) delete _impl_.skeletal_action_data_;
  if (this != internal_default_instance()) delete _impl_.skeletal_summary_data_;
}

void VrSkeletalData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VrSkeletalData::Clear() {
// @@protoc_insertion_point(message_clear_start:VrSkeletalData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.compressed_bone_transforms_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.skeletal_action_data_ != nullptr);
      _impl_.skeletal_action_data_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.skeletal_summary_data_ != nullptr);
      _impl_.skeletal_summary_data_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.bone_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bone_transform_source_) -
        reinterpret_cast<char*>(&_impl_.bone_count_)) + sizeof(_impl_.bone_transform_source_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VrSkeletalData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .VrInputSkeletalActionData skeletal_action_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_skeletal_action_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .VrSkeletalSummaryData skeletal_summary_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_skeletal_summary_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bone_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_bone_count(&has_bits);
          _impl_.bone_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bone_transform_source = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bone_transform_source(&has_bits);
          _impl_.bone_transform_source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes compressed_bone_transforms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_compressed_bone_transforms();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VrSkeletalData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VrSkeletalData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .VrInputSkeletalActionData skeletal_action_data = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::skeletal_action_data(this),
        _Internal::skeletal_action_data(this).GetCachedSize(), target, stream);
  }

  // optional .VrSkeletalSummaryData skeletal_summary_data = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::skeletal_summary_data(this),
        _Internal::skeletal_summary_data(this).GetCachedSize(), target, stream);
  }

  // optional uint32 bone_count = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_bone_count(), target);
  }

  // optional uint32 bone_transform_source = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_bone_transform_source(), target);
  }

  // optional bytes compressed_bone_transforms = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_compressed_bone_transforms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VrSkeletalData)
  return target;
}

size_t VrSkeletalData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VrSkeletalData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes compressed_bone_transforms = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_compressed_bone_transforms());
    }

    // optional .VrInputSkeletalActionData skeletal_action_data = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.skeletal_action_data_);
    }

    // optional .VrSkeletalSummaryData skeletal_summary_data = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.skeletal_summary_data_);
    }

    // optional uint32 bone_count = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bone_count());
    }

    // optional uint32 bone_transform_source = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bone_transform_source());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VrSkeletalData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VrSkeletalData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VrSkeletalData::GetClassData() const { return &_class_data_; }


void VrSkeletalData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VrSkeletalData*>(&to_msg);
  auto& from = static_cast<const VrSkeletalData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VrSkeletalData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_compressed_bone_transforms(from._internal_compressed_bone_transforms());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_skeletal_action_data()->::VrInputSkeletalActionData::MergeFrom(
          from._internal_skeletal_action_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_skeletal_summary_data()->::VrSkeletalSummaryData::MergeFrom(
          from._internal_skeletal_summary_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bone_count_ = from._impl_.bone_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.bone_transform_source_ = from._impl_.bone_transform_source_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VrSkeletalData::CopyFrom(const VrSkeletalData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VrSkeletalData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VrSkeletalData::IsInitialized() const {
  return true;
}

void VrSkeletalData::InternalSwap(VrSkeletalData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.compressed_bone_transforms_, lhs_arena,
      &other->_impl_.compressed_bone_transforms_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VrSkeletalData, _impl_.bone_transform_source_)
      + sizeof(VrSkeletalData::_impl_.bone_transform_source_)
      - PROTOBUF_FIELD_OFFSET(VrSkeletalData, _impl_.skeletal_action_data_)>(
          reinterpret_cast<char*>(&_impl_.skeletal_action_data_),
          reinterpret_cast<char*>(&other->_impl_.skeletal_action_data_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VrSkeletalData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[16]);
}

// ===================================================================

class CUerMsgVRActions::_Internal {
 public:
};

CUerMsgVRActions::CUerMsgVRActions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CUerMsgVRActions)
}
CUerMsgVRActions::CUerMsgVRActions(const CUerMsgVRActions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CUerMsgVRActions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.digital_action_data_){from._impl_.digital_action_data_}
    , decltype(_impl_.analog_action_data_){from._impl_.analog_action_data_}
    , decltype(_impl_.skeleton_){from._impl_.skeleton_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CUerMsgVRActions)
}

inline void CUerMsgVRActions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.digital_action_data_){arena}
    , decltype(_impl_.analog_action_data_){arena}
    , decltype(_impl_.skeleton_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CUerMsgVRActions::~CUerMsgVRActions() {
  // @@protoc_insertion_point(destructor:CUerMsgVRActions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CUerMsgVRActions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.digital_action_data_.~RepeatedPtrField();
  _impl_.analog_action_data_.~RepeatedPtrField();
  _impl_.skeleton_.~RepeatedPtrField();
}

void CUerMsgVRActions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CUerMsgVRActions::Clear() {
// @@protoc_insertion_point(message_clear_start:CUerMsgVRActions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.digital_action_data_.Clear();
  _impl_.analog_action_data_.Clear();
  _impl_.skeleton_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CUerMsgVRActions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .VrInputDigitalActionData digital_action_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_digital_action_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .VrInputAnalogActionData analog_action_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_analog_action_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .VrSkeletalData skeleton = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_skeleton(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CUerMsgVRActions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CUerMsgVRActions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .VrInputDigitalActionData digital_action_data = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_digital_action_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_digital_action_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .VrInputAnalogActionData analog_action_data = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_analog_action_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_analog_action_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .VrSkeletalData skeleton = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_skeleton_size()); i < n; i++) {
    const auto& repfield = this->_internal_skeleton(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CUerMsgVRActions)
  return target;
}

size_t CUerMsgVRActions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CUerMsgVRActions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .VrInputDigitalActionData digital_action_data = 1;
  total_size += 1UL * this->_internal_digital_action_data_size();
  for (const auto& msg : this->_impl_.digital_action_data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .VrInputAnalogActionData analog_action_data = 2;
  total_size += 1UL * this->_internal_analog_action_data_size();
  for (const auto& msg : this->_impl_.analog_action_data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .VrSkeletalData skeleton = 3;
  total_size += 1UL * this->_internal_skeleton_size();
  for (const auto& msg : this->_impl_.skeleton_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CUerMsgVRActions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CUerMsgVRActions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CUerMsgVRActions::GetClassData() const { return &_class_data_; }


void CUerMsgVRActions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CUerMsgVRActions*>(&to_msg);
  auto& from = static_cast<const CUerMsgVRActions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CUerMsgVRActions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.digital_action_data_.MergeFrom(from._impl_.digital_action_data_);
  _this->_impl_.analog_action_data_.MergeFrom(from._impl_.analog_action_data_);
  _this->_impl_.skeleton_.MergeFrom(from._impl_.skeleton_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CUerMsgVRActions::CopyFrom(const CUerMsgVRActions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CUerMsgVRActions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CUerMsgVRActions::IsInitialized() const {
  return true;
}

void CUerMsgVRActions::InternalSwap(CUerMsgVRActions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.digital_action_data_.InternalSwap(&other->_impl_.digital_action_data_);
  _impl_.analog_action_data_.InternalSwap(&other->_impl_.analog_action_data_);
  _impl_.skeleton_.InternalSwap(&other->_impl_.skeleton_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CUerMsgVRActions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[17]);
}

// ===================================================================

class VRSampleUserCmdPB::_Internal {
 public:
  using HasBits = decltype(std::declval<VRSampleUserCmdPB>()._impl_._has_bits_);
  static const ::CBaseUserCmdPB& base(const VRSampleUserCmdPB* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CUserMsgVRCore& hmd(const VRSampleUserCmdPB* msg);
  static void set_has_hmd(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CUerMsgVRActions& actions(const VRSampleUserCmdPB* msg);
  static void set_has_actions(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CBaseUserCmdPB&
VRSampleUserCmdPB::_Internal::base(const VRSampleUserCmdPB* msg) {
  return *msg->_impl_.base_;
}
const ::CUserMsgVRCore&
VRSampleUserCmdPB::_Internal::hmd(const VRSampleUserCmdPB* msg) {
  return *msg->_impl_.hmd_;
}
const ::CUerMsgVRActions&
VRSampleUserCmdPB::_Internal::actions(const VRSampleUserCmdPB* msg) {
  return *msg->_impl_.actions_;
}
VRSampleUserCmdPB::VRSampleUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VRSampleUserCmdPB)
}
VRSampleUserCmdPB::VRSampleUserCmdPB(const VRSampleUserCmdPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VRSampleUserCmdPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.hmd_){nullptr}
    , decltype(_impl_.actions_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CBaseUserCmdPB(*from._impl_.base_);
  }
  if (from._internal_has_hmd()) {
    _this->_impl_.hmd_ = new ::CUserMsgVRCore(*from._impl_.hmd_);
  }
  if (from._internal_has_actions()) {
    _this->_impl_.actions_ = new ::CUerMsgVRActions(*from._impl_.actions_);
  }
  // @@protoc_insertion_point(copy_constructor:VRSampleUserCmdPB)
}

inline void VRSampleUserCmdPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.hmd_){nullptr}
    , decltype(_impl_.actions_){nullptr}
  };
}

VRSampleUserCmdPB::~VRSampleUserCmdPB() {
  // @@protoc_insertion_point(destructor:VRSampleUserCmdPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VRSampleUserCmdPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.hmd_;
  if (this != internal_default_instance()) delete _impl_.actions_;
}

void VRSampleUserCmdPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VRSampleUserCmdPB::Clear() {
// @@protoc_insertion_point(message_clear_start:VRSampleUserCmdPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.base_ != nullptr);
      _impl_.base_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.hmd_ != nullptr);
      _impl_.hmd_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.actions_ != nullptr);
      _impl_.actions_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VRSampleUserCmdPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CBaseUserCmdPB base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CUserMsgVRCore hmd = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_hmd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CUerMsgVRActions actions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_actions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VRSampleUserCmdPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VRSampleUserCmdPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CBaseUserCmdPB base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // optional .CUserMsgVRCore hmd = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::hmd(this),
        _Internal::hmd(this).GetCachedSize(), target, stream);
  }

  // optional .CUerMsgVRActions actions = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::actions(this),
        _Internal::actions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VRSampleUserCmdPB)
  return target;
}

size_t VRSampleUserCmdPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VRSampleUserCmdPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CBaseUserCmdPB base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional .CUserMsgVRCore hmd = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hmd_);
    }

    // optional .CUerMsgVRActions actions = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.actions_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VRSampleUserCmdPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VRSampleUserCmdPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VRSampleUserCmdPB::GetClassData() const { return &_class_data_; }


void VRSampleUserCmdPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VRSampleUserCmdPB*>(&to_msg);
  auto& from = static_cast<const VRSampleUserCmdPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VRSampleUserCmdPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CBaseUserCmdPB::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_hmd()->::CUserMsgVRCore::MergeFrom(
          from._internal_hmd());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_actions()->::CUerMsgVRActions::MergeFrom(
          from._internal_actions());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VRSampleUserCmdPB::CopyFrom(const VRSampleUserCmdPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VRSampleUserCmdPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VRSampleUserCmdPB::IsInitialized() const {
  return true;
}

void VRSampleUserCmdPB::InternalSwap(VRSampleUserCmdPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VRSampleUserCmdPB, _impl_.actions_)
      + sizeof(VRSampleUserCmdPB::_impl_.actions_)
      - PROTOBUF_FIELD_OFFSET(VRSampleUserCmdPB, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VRSampleUserCmdPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[18]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CInButtonStatePB*
Arena::CreateMaybeMessage< ::CInButtonStatePB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInButtonStatePB >(arena);
}
template<> PROTOBUF_NOINLINE ::CTicklessMoveStep*
Arena::CreateMaybeMessage< ::CTicklessMoveStep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CTicklessMoveStep >(arena);
}
template<> PROTOBUF_NOINLINE ::CBaseUserCmdPB*
Arena::CreateMaybeMessage< ::CBaseUserCmdPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CBaseUserCmdPB >(arena);
}
template<> PROTOBUF_NOINLINE ::CUserCmdBasePB*
Arena::CreateMaybeMessage< ::CUserCmdBasePB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CUserCmdBasePB >(arena);
}
template<> PROTOBUF_NOINLINE ::CHLXUserCmdPB*
Arena::CreateMaybeMessage< ::CHLXUserCmdPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CHLXUserCmdPB >(arena);
}
template<> PROTOBUF_NOINLINE ::CDota2UserCmdPB*
Arena::CreateMaybeMessage< ::CDota2UserCmdPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDota2UserCmdPB >(arena);
}
template<> PROTOBUF_NOINLINE ::CCitadelUserCmdPB*
Arena::CreateMaybeMessage< ::CCitadelUserCmdPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCitadelUserCmdPB >(arena);
}
template<> PROTOBUF_NOINLINE ::CSGOInputHistoryEntryPB*
Arena::CreateMaybeMessage< ::CSGOInputHistoryEntryPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSGOInputHistoryEntryPB >(arena);
}
template<> PROTOBUF_NOINLINE ::CSGOUserCmdPB*
Arena::CreateMaybeMessage< ::CSGOUserCmdPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSGOUserCmdPB >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgVRHandInfo*
Arena::CreateMaybeMessage< ::CMsgVRHandInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgVRHandInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgVRController*
Arena::CreateMaybeMessage< ::CMsgVRController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgVRController >(arena);
}
template<> PROTOBUF_NOINLINE ::CUserMsgVRCore*
Arena::CreateMaybeMessage< ::CUserMsgVRCore >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CUserMsgVRCore >(arena);
}
template<> PROTOBUF_NOINLINE ::VrInputDigitalActionData*
Arena::CreateMaybeMessage< ::VrInputDigitalActionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VrInputDigitalActionData >(arena);
}
template<> PROTOBUF_NOINLINE ::VrInputAnalogActionData*
Arena::CreateMaybeMessage< ::VrInputAnalogActionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VrInputAnalogActionData >(arena);
}
template<> PROTOBUF_NOINLINE ::VrInputSkeletalActionData*
Arena::CreateMaybeMessage< ::VrInputSkeletalActionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VrInputSkeletalActionData >(arena);
}
template<> PROTOBUF_NOINLINE ::VrSkeletalSummaryData*
Arena::CreateMaybeMessage< ::VrSkeletalSummaryData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VrSkeletalSummaryData >(arena);
}
template<> PROTOBUF_NOINLINE ::VrSkeletalData*
Arena::CreateMaybeMessage< ::VrSkeletalData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VrSkeletalData >(arena);
}
template<> PROTOBUF_NOINLINE ::CUerMsgVRActions*
Arena::CreateMaybeMessage< ::CUerMsgVRActions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CUerMsgVRActions >(arena);
}
template<> PROTOBUF_NOINLINE ::VRSampleUserCmdPB*
Arena::CreateMaybeMessage< ::VRSampleUserCmdPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VRSampleUserCmdPB >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
