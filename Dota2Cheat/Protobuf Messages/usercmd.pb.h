// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: usercmd.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_usercmd_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_usercmd_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "networkbasetypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_usercmd_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_usercmd_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_usercmd_2eproto;
class CBaseUserCmdPB;
struct CBaseUserCmdPBDefaultTypeInternal;
extern CBaseUserCmdPBDefaultTypeInternal _CBaseUserCmdPB_default_instance_;
class CCitadelUserCmdPB;
struct CCitadelUserCmdPBDefaultTypeInternal;
extern CCitadelUserCmdPBDefaultTypeInternal _CCitadelUserCmdPB_default_instance_;
class CDota2UserCmdPB;
struct CDota2UserCmdPBDefaultTypeInternal;
extern CDota2UserCmdPBDefaultTypeInternal _CDota2UserCmdPB_default_instance_;
class CHLXUserCmdPB;
struct CHLXUserCmdPBDefaultTypeInternal;
extern CHLXUserCmdPBDefaultTypeInternal _CHLXUserCmdPB_default_instance_;
class CInButtonStatePB;
struct CInButtonStatePBDefaultTypeInternal;
extern CInButtonStatePBDefaultTypeInternal _CInButtonStatePB_default_instance_;
class CMsgVRController;
struct CMsgVRControllerDefaultTypeInternal;
extern CMsgVRControllerDefaultTypeInternal _CMsgVRController_default_instance_;
class CMsgVRHandInfo;
struct CMsgVRHandInfoDefaultTypeInternal;
extern CMsgVRHandInfoDefaultTypeInternal _CMsgVRHandInfo_default_instance_;
class CSGOInputHistoryEntryPB;
struct CSGOInputHistoryEntryPBDefaultTypeInternal;
extern CSGOInputHistoryEntryPBDefaultTypeInternal _CSGOInputHistoryEntryPB_default_instance_;
class CSGOUserCmdPB;
struct CSGOUserCmdPBDefaultTypeInternal;
extern CSGOUserCmdPBDefaultTypeInternal _CSGOUserCmdPB_default_instance_;
class CTicklessMoveStep;
struct CTicklessMoveStepDefaultTypeInternal;
extern CTicklessMoveStepDefaultTypeInternal _CTicklessMoveStep_default_instance_;
class CUerMsgVRActions;
struct CUerMsgVRActionsDefaultTypeInternal;
extern CUerMsgVRActionsDefaultTypeInternal _CUerMsgVRActions_default_instance_;
class CUserCmdBasePB;
struct CUserCmdBasePBDefaultTypeInternal;
extern CUserCmdBasePBDefaultTypeInternal _CUserCmdBasePB_default_instance_;
class CUserMsgVRCore;
struct CUserMsgVRCoreDefaultTypeInternal;
extern CUserMsgVRCoreDefaultTypeInternal _CUserMsgVRCore_default_instance_;
class VRSampleUserCmdPB;
struct VRSampleUserCmdPBDefaultTypeInternal;
extern VRSampleUserCmdPBDefaultTypeInternal _VRSampleUserCmdPB_default_instance_;
class VrInputAnalogActionData;
struct VrInputAnalogActionDataDefaultTypeInternal;
extern VrInputAnalogActionDataDefaultTypeInternal _VrInputAnalogActionData_default_instance_;
class VrInputDigitalActionData;
struct VrInputDigitalActionDataDefaultTypeInternal;
extern VrInputDigitalActionDataDefaultTypeInternal _VrInputDigitalActionData_default_instance_;
class VrInputSkeletalActionData;
struct VrInputSkeletalActionDataDefaultTypeInternal;
extern VrInputSkeletalActionDataDefaultTypeInternal _VrInputSkeletalActionData_default_instance_;
class VrSkeletalData;
struct VrSkeletalDataDefaultTypeInternal;
extern VrSkeletalDataDefaultTypeInternal _VrSkeletalData_default_instance_;
class VrSkeletalSummaryData;
struct VrSkeletalSummaryDataDefaultTypeInternal;
extern VrSkeletalSummaryDataDefaultTypeInternal _VrSkeletalSummaryData_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CBaseUserCmdPB* Arena::CreateMaybeMessage<::CBaseUserCmdPB>(Arena*);
template<> ::CCitadelUserCmdPB* Arena::CreateMaybeMessage<::CCitadelUserCmdPB>(Arena*);
template<> ::CDota2UserCmdPB* Arena::CreateMaybeMessage<::CDota2UserCmdPB>(Arena*);
template<> ::CHLXUserCmdPB* Arena::CreateMaybeMessage<::CHLXUserCmdPB>(Arena*);
template<> ::CInButtonStatePB* Arena::CreateMaybeMessage<::CInButtonStatePB>(Arena*);
template<> ::CMsgVRController* Arena::CreateMaybeMessage<::CMsgVRController>(Arena*);
template<> ::CMsgVRHandInfo* Arena::CreateMaybeMessage<::CMsgVRHandInfo>(Arena*);
template<> ::CSGOInputHistoryEntryPB* Arena::CreateMaybeMessage<::CSGOInputHistoryEntryPB>(Arena*);
template<> ::CSGOUserCmdPB* Arena::CreateMaybeMessage<::CSGOUserCmdPB>(Arena*);
template<> ::CTicklessMoveStep* Arena::CreateMaybeMessage<::CTicklessMoveStep>(Arena*);
template<> ::CUerMsgVRActions* Arena::CreateMaybeMessage<::CUerMsgVRActions>(Arena*);
template<> ::CUserCmdBasePB* Arena::CreateMaybeMessage<::CUserCmdBasePB>(Arena*);
template<> ::CUserMsgVRCore* Arena::CreateMaybeMessage<::CUserMsgVRCore>(Arena*);
template<> ::VRSampleUserCmdPB* Arena::CreateMaybeMessage<::VRSampleUserCmdPB>(Arena*);
template<> ::VrInputAnalogActionData* Arena::CreateMaybeMessage<::VrInputAnalogActionData>(Arena*);
template<> ::VrInputDigitalActionData* Arena::CreateMaybeMessage<::VrInputDigitalActionData>(Arena*);
template<> ::VrInputSkeletalActionData* Arena::CreateMaybeMessage<::VrInputSkeletalActionData>(Arena*);
template<> ::VrSkeletalData* Arena::CreateMaybeMessage<::VrSkeletalData>(Arena*);
template<> ::VrSkeletalSummaryData* Arena::CreateMaybeMessage<::VrSkeletalSummaryData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class CInButtonStatePB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInButtonStatePB) */ {
 public:
  inline CInButtonStatePB() : CInButtonStatePB(nullptr) {}
  ~CInButtonStatePB() override;
  explicit PROTOBUF_CONSTEXPR CInButtonStatePB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInButtonStatePB(const CInButtonStatePB& from);
  CInButtonStatePB(CInButtonStatePB&& from) noexcept
    : CInButtonStatePB() {
    *this = ::std::move(from);
  }

  inline CInButtonStatePB& operator=(const CInButtonStatePB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInButtonStatePB& operator=(CInButtonStatePB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInButtonStatePB& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInButtonStatePB* internal_default_instance() {
    return reinterpret_cast<const CInButtonStatePB*>(
               &_CInButtonStatePB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CInButtonStatePB& a, CInButtonStatePB& b) {
    a.Swap(&b);
  }
  inline void Swap(CInButtonStatePB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInButtonStatePB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInButtonStatePB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInButtonStatePB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInButtonStatePB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CInButtonStatePB& from) {
    CInButtonStatePB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInButtonStatePB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInButtonStatePB";
  }
  protected:
  explicit CInButtonStatePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kButtonstate1FieldNumber = 1,
    kButtonstate2FieldNumber = 2,
    kButtonstate3FieldNumber = 3,
  };
  // optional uint64 buttonstate1 = 1;
  bool has_buttonstate1() const;
  private:
  bool _internal_has_buttonstate1() const;
  public:
  void clear_buttonstate1();
  uint64_t buttonstate1() const;
  void set_buttonstate1(uint64_t value);
  private:
  uint64_t _internal_buttonstate1() const;
  void _internal_set_buttonstate1(uint64_t value);
  public:

  // optional uint64 buttonstate2 = 2;
  bool has_buttonstate2() const;
  private:
  bool _internal_has_buttonstate2() const;
  public:
  void clear_buttonstate2();
  uint64_t buttonstate2() const;
  void set_buttonstate2(uint64_t value);
  private:
  uint64_t _internal_buttonstate2() const;
  void _internal_set_buttonstate2(uint64_t value);
  public:

  // optional uint64 buttonstate3 = 3;
  bool has_buttonstate3() const;
  private:
  bool _internal_has_buttonstate3() const;
  public:
  void clear_buttonstate3();
  uint64_t buttonstate3() const;
  void set_buttonstate3(uint64_t value);
  private:
  uint64_t _internal_buttonstate3() const;
  void _internal_set_buttonstate3(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CInButtonStatePB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t buttonstate1_;
    uint64_t buttonstate2_;
    uint64_t buttonstate3_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CTicklessMoveStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTicklessMoveStep) */ {
 public:
  inline CTicklessMoveStep() : CTicklessMoveStep(nullptr) {}
  ~CTicklessMoveStep() override;
  explicit PROTOBUF_CONSTEXPR CTicklessMoveStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTicklessMoveStep(const CTicklessMoveStep& from);
  CTicklessMoveStep(CTicklessMoveStep&& from) noexcept
    : CTicklessMoveStep() {
    *this = ::std::move(from);
  }

  inline CTicklessMoveStep& operator=(const CTicklessMoveStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTicklessMoveStep& operator=(CTicklessMoveStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTicklessMoveStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTicklessMoveStep* internal_default_instance() {
    return reinterpret_cast<const CTicklessMoveStep*>(
               &_CTicklessMoveStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CTicklessMoveStep& a, CTicklessMoveStep& b) {
    a.Swap(&b);
  }
  inline void Swap(CTicklessMoveStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTicklessMoveStep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTicklessMoveStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTicklessMoveStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTicklessMoveStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CTicklessMoveStep& from) {
    CTicklessMoveStep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTicklessMoveStep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTicklessMoveStep";
  }
  protected:
  explicit CTicklessMoveStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kButtonFieldNumber = 1,
    kPressedFieldNumber = 2,
    kWhenFieldNumber = 3,
  };
  // optional int32 button = 1;
  bool has_button() const;
  private:
  bool _internal_has_button() const;
  public:
  void clear_button();
  int32_t button() const;
  void set_button(int32_t value);
  private:
  int32_t _internal_button() const;
  void _internal_set_button(int32_t value);
  public:

  // optional bool pressed = 2;
  bool has_pressed() const;
  private:
  bool _internal_has_pressed() const;
  public:
  void clear_pressed();
  bool pressed() const;
  void set_pressed(bool value);
  private:
  bool _internal_pressed() const;
  void _internal_set_pressed(bool value);
  public:

  // optional float when = 3;
  bool has_when() const;
  private:
  bool _internal_has_when() const;
  public:
  void clear_when();
  float when() const;
  void set_when(float value);
  private:
  float _internal_when() const;
  void _internal_set_when(float value);
  public:

  // @@protoc_insertion_point(class_scope:CTicklessMoveStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t button_;
    bool pressed_;
    float when_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CBaseUserCmdPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CBaseUserCmdPB) */ {
 public:
  inline CBaseUserCmdPB() : CBaseUserCmdPB(nullptr) {}
  ~CBaseUserCmdPB() override;
  explicit PROTOBUF_CONSTEXPR CBaseUserCmdPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CBaseUserCmdPB(const CBaseUserCmdPB& from);
  CBaseUserCmdPB(CBaseUserCmdPB&& from) noexcept
    : CBaseUserCmdPB() {
    *this = ::std::move(from);
  }

  inline CBaseUserCmdPB& operator=(const CBaseUserCmdPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CBaseUserCmdPB& operator=(CBaseUserCmdPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CBaseUserCmdPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const CBaseUserCmdPB* internal_default_instance() {
    return reinterpret_cast<const CBaseUserCmdPB*>(
               &_CBaseUserCmdPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CBaseUserCmdPB& a, CBaseUserCmdPB& b) {
    a.Swap(&b);
  }
  inline void Swap(CBaseUserCmdPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CBaseUserCmdPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CBaseUserCmdPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CBaseUserCmdPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CBaseUserCmdPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CBaseUserCmdPB& from) {
    CBaseUserCmdPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CBaseUserCmdPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CBaseUserCmdPB";
  }
  protected:
  explicit CBaseUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicklessMovesFieldNumber = 18,
    kButtonsPbFieldNumber = 3,
    kViewanglesFieldNumber = 4,
    kCommandNumberFieldNumber = 1,
    kTickCountFieldNumber = 2,
    kForwardmoveFieldNumber = 5,
    kLeftmoveFieldNumber = 6,
    kUpmoveFieldNumber = 7,
    kImpulseFieldNumber = 8,
    kWeaponselectFieldNumber = 9,
    kRandomSeedFieldNumber = 10,
    kMousedxFieldNumber = 11,
    kMousedyFieldNumber = 12,
    kHasbeenpredictedFieldNumber = 13,
    kPawnEntityHandleFieldNumber = 14,
  };
  // repeated .CTicklessMoveStep tickless_moves = 18;
  int tickless_moves_size() const;
  private:
  int _internal_tickless_moves_size() const;
  public:
  void clear_tickless_moves();
  ::CTicklessMoveStep* mutable_tickless_moves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTicklessMoveStep >*
      mutable_tickless_moves();
  private:
  const ::CTicklessMoveStep& _internal_tickless_moves(int index) const;
  ::CTicklessMoveStep* _internal_add_tickless_moves();
  public:
  const ::CTicklessMoveStep& tickless_moves(int index) const;
  ::CTicklessMoveStep* add_tickless_moves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTicklessMoveStep >&
      tickless_moves() const;

  // optional .CInButtonStatePB buttons_pb = 3;
  bool has_buttons_pb() const;
  private:
  bool _internal_has_buttons_pb() const;
  public:
  void clear_buttons_pb();
  const ::CInButtonStatePB& buttons_pb() const;
  PROTOBUF_NODISCARD ::CInButtonStatePB* release_buttons_pb();
  ::CInButtonStatePB* mutable_buttons_pb();
  void set_allocated_buttons_pb(::CInButtonStatePB* buttons_pb);
  private:
  const ::CInButtonStatePB& _internal_buttons_pb() const;
  ::CInButtonStatePB* _internal_mutable_buttons_pb();
  public:
  void unsafe_arena_set_allocated_buttons_pb(
      ::CInButtonStatePB* buttons_pb);
  ::CInButtonStatePB* unsafe_arena_release_buttons_pb();

  // optional .CMsgQAngle viewangles = 4;
  bool has_viewangles() const;
  private:
  bool _internal_has_viewangles() const;
  public:
  void clear_viewangles();
  const ::CMsgQAngle& viewangles() const;
  PROTOBUF_NODISCARD ::CMsgQAngle* release_viewangles();
  ::CMsgQAngle* mutable_viewangles();
  void set_allocated_viewangles(::CMsgQAngle* viewangles);
  private:
  const ::CMsgQAngle& _internal_viewangles() const;
  ::CMsgQAngle* _internal_mutable_viewangles();
  public:
  void unsafe_arena_set_allocated_viewangles(
      ::CMsgQAngle* viewangles);
  ::CMsgQAngle* unsafe_arena_release_viewangles();

  // optional int32 command_number = 1;
  bool has_command_number() const;
  private:
  bool _internal_has_command_number() const;
  public:
  void clear_command_number();
  int32_t command_number() const;
  void set_command_number(int32_t value);
  private:
  int32_t _internal_command_number() const;
  void _internal_set_command_number(int32_t value);
  public:

  // optional int32 tick_count = 2;
  bool has_tick_count() const;
  private:
  bool _internal_has_tick_count() const;
  public:
  void clear_tick_count();
  int32_t tick_count() const;
  void set_tick_count(int32_t value);
  private:
  int32_t _internal_tick_count() const;
  void _internal_set_tick_count(int32_t value);
  public:

  // optional float forwardmove = 5;
  bool has_forwardmove() const;
  private:
  bool _internal_has_forwardmove() const;
  public:
  void clear_forwardmove();
  float forwardmove() const;
  void set_forwardmove(float value);
  private:
  float _internal_forwardmove() const;
  void _internal_set_forwardmove(float value);
  public:

  // optional float leftmove = 6;
  bool has_leftmove() const;
  private:
  bool _internal_has_leftmove() const;
  public:
  void clear_leftmove();
  float leftmove() const;
  void set_leftmove(float value);
  private:
  float _internal_leftmove() const;
  void _internal_set_leftmove(float value);
  public:

  // optional float upmove = 7;
  bool has_upmove() const;
  private:
  bool _internal_has_upmove() const;
  public:
  void clear_upmove();
  float upmove() const;
  void set_upmove(float value);
  private:
  float _internal_upmove() const;
  void _internal_set_upmove(float value);
  public:

  // optional int32 impulse = 8;
  bool has_impulse() const;
  private:
  bool _internal_has_impulse() const;
  public:
  void clear_impulse();
  int32_t impulse() const;
  void set_impulse(int32_t value);
  private:
  int32_t _internal_impulse() const;
  void _internal_set_impulse(int32_t value);
  public:

  // optional int32 weaponselect = 9;
  bool has_weaponselect() const;
  private:
  bool _internal_has_weaponselect() const;
  public:
  void clear_weaponselect();
  int32_t weaponselect() const;
  void set_weaponselect(int32_t value);
  private:
  int32_t _internal_weaponselect() const;
  void _internal_set_weaponselect(int32_t value);
  public:

  // optional int32 random_seed = 10;
  bool has_random_seed() const;
  private:
  bool _internal_has_random_seed() const;
  public:
  void clear_random_seed();
  int32_t random_seed() const;
  void set_random_seed(int32_t value);
  private:
  int32_t _internal_random_seed() const;
  void _internal_set_random_seed(int32_t value);
  public:

  // optional int32 mousedx = 11;
  bool has_mousedx() const;
  private:
  bool _internal_has_mousedx() const;
  public:
  void clear_mousedx();
  int32_t mousedx() const;
  void set_mousedx(int32_t value);
  private:
  int32_t _internal_mousedx() const;
  void _internal_set_mousedx(int32_t value);
  public:

  // optional int32 mousedy = 12;
  bool has_mousedy() const;
  private:
  bool _internal_has_mousedy() const;
  public:
  void clear_mousedy();
  int32_t mousedy() const;
  void set_mousedy(int32_t value);
  private:
  int32_t _internal_mousedy() const;
  void _internal_set_mousedy(int32_t value);
  public:

  // optional bool hasbeenpredicted = 13;
  bool has_hasbeenpredicted() const;
  private:
  bool _internal_has_hasbeenpredicted() const;
  public:
  void clear_hasbeenpredicted();
  bool hasbeenpredicted() const;
  void set_hasbeenpredicted(bool value);
  private:
  bool _internal_hasbeenpredicted() const;
  void _internal_set_hasbeenpredicted(bool value);
  public:

  // optional uint32 pawn_entity_handle = 14 [default = 16777215];
  bool has_pawn_entity_handle() const;
  private:
  bool _internal_has_pawn_entity_handle() const;
  public:
  void clear_pawn_entity_handle();
  uint32_t pawn_entity_handle() const;
  void set_pawn_entity_handle(uint32_t value);
  private:
  uint32_t _internal_pawn_entity_handle() const;
  void _internal_set_pawn_entity_handle(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CBaseUserCmdPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTicklessMoveStep > tickless_moves_;
    ::CInButtonStatePB* buttons_pb_;
    ::CMsgQAngle* viewangles_;
    int32_t command_number_;
    int32_t tick_count_;
    float forwardmove_;
    float leftmove_;
    float upmove_;
    int32_t impulse_;
    int32_t weaponselect_;
    int32_t random_seed_;
    int32_t mousedx_;
    int32_t mousedy_;
    bool hasbeenpredicted_;
    uint32_t pawn_entity_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CUserCmdBasePB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CUserCmdBasePB) */ {
 public:
  inline CUserCmdBasePB() : CUserCmdBasePB(nullptr) {}
  ~CUserCmdBasePB() override;
  explicit PROTOBUF_CONSTEXPR CUserCmdBasePB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CUserCmdBasePB(const CUserCmdBasePB& from);
  CUserCmdBasePB(CUserCmdBasePB&& from) noexcept
    : CUserCmdBasePB() {
    *this = ::std::move(from);
  }

  inline CUserCmdBasePB& operator=(const CUserCmdBasePB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CUserCmdBasePB& operator=(CUserCmdBasePB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CUserCmdBasePB& default_instance() {
    return *internal_default_instance();
  }
  static inline const CUserCmdBasePB* internal_default_instance() {
    return reinterpret_cast<const CUserCmdBasePB*>(
               &_CUserCmdBasePB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CUserCmdBasePB& a, CUserCmdBasePB& b) {
    a.Swap(&b);
  }
  inline void Swap(CUserCmdBasePB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CUserCmdBasePB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CUserCmdBasePB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CUserCmdBasePB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CUserCmdBasePB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CUserCmdBasePB& from) {
    CUserCmdBasePB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CUserCmdBasePB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CUserCmdBasePB";
  }
  protected:
  explicit CUserCmdBasePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
  };
  // optional .CBaseUserCmdPB base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::CBaseUserCmdPB& base() const;
  PROTOBUF_NODISCARD ::CBaseUserCmdPB* release_base();
  ::CBaseUserCmdPB* mutable_base();
  void set_allocated_base(::CBaseUserCmdPB* base);
  private:
  const ::CBaseUserCmdPB& _internal_base() const;
  ::CBaseUserCmdPB* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::CBaseUserCmdPB* base);
  ::CBaseUserCmdPB* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:CUserCmdBasePB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CBaseUserCmdPB* base_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CHLXUserCmdPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CHLXUserCmdPB) */ {
 public:
  inline CHLXUserCmdPB() : CHLXUserCmdPB(nullptr) {}
  ~CHLXUserCmdPB() override;
  explicit PROTOBUF_CONSTEXPR CHLXUserCmdPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CHLXUserCmdPB(const CHLXUserCmdPB& from);
  CHLXUserCmdPB(CHLXUserCmdPB&& from) noexcept
    : CHLXUserCmdPB() {
    *this = ::std::move(from);
  }

  inline CHLXUserCmdPB& operator=(const CHLXUserCmdPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CHLXUserCmdPB& operator=(CHLXUserCmdPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CHLXUserCmdPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const CHLXUserCmdPB* internal_default_instance() {
    return reinterpret_cast<const CHLXUserCmdPB*>(
               &_CHLXUserCmdPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CHLXUserCmdPB& a, CHLXUserCmdPB& b) {
    a.Swap(&b);
  }
  inline void Swap(CHLXUserCmdPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CHLXUserCmdPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CHLXUserCmdPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CHLXUserCmdPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CHLXUserCmdPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CHLXUserCmdPB& from) {
    CHLXUserCmdPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CHLXUserCmdPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CHLXUserCmdPB";
  }
  protected:
  explicit CHLXUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
  };
  // optional .CBaseUserCmdPB base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::CBaseUserCmdPB& base() const;
  PROTOBUF_NODISCARD ::CBaseUserCmdPB* release_base();
  ::CBaseUserCmdPB* mutable_base();
  void set_allocated_base(::CBaseUserCmdPB* base);
  private:
  const ::CBaseUserCmdPB& _internal_base() const;
  ::CBaseUserCmdPB* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::CBaseUserCmdPB* base);
  ::CBaseUserCmdPB* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:CHLXUserCmdPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CBaseUserCmdPB* base_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CDota2UserCmdPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CDota2UserCmdPB) */ {
 public:
  inline CDota2UserCmdPB() : CDota2UserCmdPB(nullptr) {}
  ~CDota2UserCmdPB() override;
  explicit PROTOBUF_CONSTEXPR CDota2UserCmdPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDota2UserCmdPB(const CDota2UserCmdPB& from);
  CDota2UserCmdPB(CDota2UserCmdPB&& from) noexcept
    : CDota2UserCmdPB() {
    *this = ::std::move(from);
  }

  inline CDota2UserCmdPB& operator=(const CDota2UserCmdPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDota2UserCmdPB& operator=(CDota2UserCmdPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDota2UserCmdPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDota2UserCmdPB* internal_default_instance() {
    return reinterpret_cast<const CDota2UserCmdPB*>(
               &_CDota2UserCmdPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CDota2UserCmdPB& a, CDota2UserCmdPB& b) {
    a.Swap(&b);
  }
  inline void Swap(CDota2UserCmdPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDota2UserCmdPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDota2UserCmdPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDota2UserCmdPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CDota2UserCmdPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CDota2UserCmdPB& from) {
    CDota2UserCmdPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDota2UserCmdPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDota2UserCmdPB";
  }
  protected:
  explicit CDota2UserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
    kCrosshairtraceFieldNumber = 3,
    kSpectatorQueryUnitEntindexFieldNumber = 2,
    kCamerapositionXFieldNumber = 4,
    kCamerapositionYFieldNumber = 5,
    kClickbehaviorFieldNumber = 6,
    kStatspanelFieldNumber = 7,
    kShoppanelFieldNumber = 8,
    kStatsDropdownFieldNumber = 9,
    kStatsDropdownSortFieldNumber = 10,
  };
  // optional .CBaseUserCmdPB base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::CBaseUserCmdPB& base() const;
  PROTOBUF_NODISCARD ::CBaseUserCmdPB* release_base();
  ::CBaseUserCmdPB* mutable_base();
  void set_allocated_base(::CBaseUserCmdPB* base);
  private:
  const ::CBaseUserCmdPB& _internal_base() const;
  ::CBaseUserCmdPB* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::CBaseUserCmdPB* base);
  ::CBaseUserCmdPB* unsafe_arena_release_base();

  // optional .CMsgVector crosshairtrace = 3;
  bool has_crosshairtrace() const;
  private:
  bool _internal_has_crosshairtrace() const;
  public:
  void clear_crosshairtrace();
  const ::CMsgVector& crosshairtrace() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_crosshairtrace();
  ::CMsgVector* mutable_crosshairtrace();
  void set_allocated_crosshairtrace(::CMsgVector* crosshairtrace);
  private:
  const ::CMsgVector& _internal_crosshairtrace() const;
  ::CMsgVector* _internal_mutable_crosshairtrace();
  public:
  void unsafe_arena_set_allocated_crosshairtrace(
      ::CMsgVector* crosshairtrace);
  ::CMsgVector* unsafe_arena_release_crosshairtrace();

  // optional int32 spectator_query_unit_entindex = 2;
  bool has_spectator_query_unit_entindex() const;
  private:
  bool _internal_has_spectator_query_unit_entindex() const;
  public:
  void clear_spectator_query_unit_entindex();
  int32_t spectator_query_unit_entindex() const;
  void set_spectator_query_unit_entindex(int32_t value);
  private:
  int32_t _internal_spectator_query_unit_entindex() const;
  void _internal_set_spectator_query_unit_entindex(int32_t value);
  public:

  // optional int32 cameraposition_x = 4;
  bool has_cameraposition_x() const;
  private:
  bool _internal_has_cameraposition_x() const;
  public:
  void clear_cameraposition_x();
  int32_t cameraposition_x() const;
  void set_cameraposition_x(int32_t value);
  private:
  int32_t _internal_cameraposition_x() const;
  void _internal_set_cameraposition_x(int32_t value);
  public:

  // optional int32 cameraposition_y = 5;
  bool has_cameraposition_y() const;
  private:
  bool _internal_has_cameraposition_y() const;
  public:
  void clear_cameraposition_y();
  int32_t cameraposition_y() const;
  void set_cameraposition_y(int32_t value);
  private:
  int32_t _internal_cameraposition_y() const;
  void _internal_set_cameraposition_y(int32_t value);
  public:

  // optional uint32 clickbehavior = 6;
  bool has_clickbehavior() const;
  private:
  bool _internal_has_clickbehavior() const;
  public:
  void clear_clickbehavior();
  uint32_t clickbehavior() const;
  void set_clickbehavior(uint32_t value);
  private:
  uint32_t _internal_clickbehavior() const;
  void _internal_set_clickbehavior(uint32_t value);
  public:

  // optional uint32 statspanel = 7;
  bool has_statspanel() const;
  private:
  bool _internal_has_statspanel() const;
  public:
  void clear_statspanel();
  uint32_t statspanel() const;
  void set_statspanel(uint32_t value);
  private:
  uint32_t _internal_statspanel() const;
  void _internal_set_statspanel(uint32_t value);
  public:

  // optional uint32 shoppanel = 8;
  bool has_shoppanel() const;
  private:
  bool _internal_has_shoppanel() const;
  public:
  void clear_shoppanel();
  uint32_t shoppanel() const;
  void set_shoppanel(uint32_t value);
  private:
  uint32_t _internal_shoppanel() const;
  void _internal_set_shoppanel(uint32_t value);
  public:

  // optional uint32 stats_dropdown = 9;
  bool has_stats_dropdown() const;
  private:
  bool _internal_has_stats_dropdown() const;
  public:
  void clear_stats_dropdown();
  uint32_t stats_dropdown() const;
  void set_stats_dropdown(uint32_t value);
  private:
  uint32_t _internal_stats_dropdown() const;
  void _internal_set_stats_dropdown(uint32_t value);
  public:

  // optional uint32 stats_dropdown_sort = 10;
  bool has_stats_dropdown_sort() const;
  private:
  bool _internal_has_stats_dropdown_sort() const;
  public:
  void clear_stats_dropdown_sort();
  uint32_t stats_dropdown_sort() const;
  void set_stats_dropdown_sort(uint32_t value);
  private:
  uint32_t _internal_stats_dropdown_sort() const;
  void _internal_set_stats_dropdown_sort(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CDota2UserCmdPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CBaseUserCmdPB* base_;
    ::CMsgVector* crosshairtrace_;
    int32_t spectator_query_unit_entindex_;
    int32_t cameraposition_x_;
    int32_t cameraposition_y_;
    uint32_t clickbehavior_;
    uint32_t statspanel_;
    uint32_t shoppanel_;
    uint32_t stats_dropdown_;
    uint32_t stats_dropdown_sort_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CCitadelUserCmdPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CCitadelUserCmdPB) */ {
 public:
  inline CCitadelUserCmdPB() : CCitadelUserCmdPB(nullptr) {}
  ~CCitadelUserCmdPB() override;
  explicit PROTOBUF_CONSTEXPR CCitadelUserCmdPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCitadelUserCmdPB(const CCitadelUserCmdPB& from);
  CCitadelUserCmdPB(CCitadelUserCmdPB&& from) noexcept
    : CCitadelUserCmdPB() {
    *this = ::std::move(from);
  }

  inline CCitadelUserCmdPB& operator=(const CCitadelUserCmdPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCitadelUserCmdPB& operator=(CCitadelUserCmdPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCitadelUserCmdPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCitadelUserCmdPB* internal_default_instance() {
    return reinterpret_cast<const CCitadelUserCmdPB*>(
               &_CCitadelUserCmdPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CCitadelUserCmdPB& a, CCitadelUserCmdPB& b) {
    a.Swap(&b);
  }
  inline void Swap(CCitadelUserCmdPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCitadelUserCmdPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCitadelUserCmdPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCitadelUserCmdPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCitadelUserCmdPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CCitadelUserCmdPB& from) {
    CCitadelUserCmdPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCitadelUserCmdPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CCitadelUserCmdPB";
  }
  protected:
  explicit CCitadelUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
    kVecCameraPositionFieldNumber = 2,
    kAngCameraAnglesFieldNumber = 3,
    kExecuteAbilityIndicesFieldNumber = 4,
    kInShopFieldNumber = 5,
    kCameraRoamingSpeedFieldNumber = 6,
    kSpecTargetFieldNumber = 7,
  };
  // optional .CBaseUserCmdPB base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::CBaseUserCmdPB& base() const;
  PROTOBUF_NODISCARD ::CBaseUserCmdPB* release_base();
  ::CBaseUserCmdPB* mutable_base();
  void set_allocated_base(::CBaseUserCmdPB* base);
  private:
  const ::CBaseUserCmdPB& _internal_base() const;
  ::CBaseUserCmdPB* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::CBaseUserCmdPB* base);
  ::CBaseUserCmdPB* unsafe_arena_release_base();

  // optional .CMsgVector vec_camera_position = 2;
  bool has_vec_camera_position() const;
  private:
  bool _internal_has_vec_camera_position() const;
  public:
  void clear_vec_camera_position();
  const ::CMsgVector& vec_camera_position() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_vec_camera_position();
  ::CMsgVector* mutable_vec_camera_position();
  void set_allocated_vec_camera_position(::CMsgVector* vec_camera_position);
  private:
  const ::CMsgVector& _internal_vec_camera_position() const;
  ::CMsgVector* _internal_mutable_vec_camera_position();
  public:
  void unsafe_arena_set_allocated_vec_camera_position(
      ::CMsgVector* vec_camera_position);
  ::CMsgVector* unsafe_arena_release_vec_camera_position();

  // optional .CMsgQAngle ang_camera_angles = 3;
  bool has_ang_camera_angles() const;
  private:
  bool _internal_has_ang_camera_angles() const;
  public:
  void clear_ang_camera_angles();
  const ::CMsgQAngle& ang_camera_angles() const;
  PROTOBUF_NODISCARD ::CMsgQAngle* release_ang_camera_angles();
  ::CMsgQAngle* mutable_ang_camera_angles();
  void set_allocated_ang_camera_angles(::CMsgQAngle* ang_camera_angles);
  private:
  const ::CMsgQAngle& _internal_ang_camera_angles() const;
  ::CMsgQAngle* _internal_mutable_ang_camera_angles();
  public:
  void unsafe_arena_set_allocated_ang_camera_angles(
      ::CMsgQAngle* ang_camera_angles);
  ::CMsgQAngle* unsafe_arena_release_ang_camera_angles();

  // optional int32 execute_ability_indices = 4;
  bool has_execute_ability_indices() const;
  private:
  bool _internal_has_execute_ability_indices() const;
  public:
  void clear_execute_ability_indices();
  int32_t execute_ability_indices() const;
  void set_execute_ability_indices(int32_t value);
  private:
  int32_t _internal_execute_ability_indices() const;
  void _internal_set_execute_ability_indices(int32_t value);
  public:

  // optional bool in_shop = 5;
  bool has_in_shop() const;
  private:
  bool _internal_has_in_shop() const;
  public:
  void clear_in_shop();
  bool in_shop() const;
  void set_in_shop(bool value);
  private:
  bool _internal_in_shop() const;
  void _internal_set_in_shop(bool value);
  public:

  // optional float camera_roaming_speed = 6;
  bool has_camera_roaming_speed() const;
  private:
  bool _internal_has_camera_roaming_speed() const;
  public:
  void clear_camera_roaming_speed();
  float camera_roaming_speed() const;
  void set_camera_roaming_speed(float value);
  private:
  float _internal_camera_roaming_speed() const;
  void _internal_set_camera_roaming_speed(float value);
  public:

  // optional int32 spec_target = 7 [default = -1];
  bool has_spec_target() const;
  private:
  bool _internal_has_spec_target() const;
  public:
  void clear_spec_target();
  int32_t spec_target() const;
  void set_spec_target(int32_t value);
  private:
  int32_t _internal_spec_target() const;
  void _internal_set_spec_target(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CCitadelUserCmdPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CBaseUserCmdPB* base_;
    ::CMsgVector* vec_camera_position_;
    ::CMsgQAngle* ang_camera_angles_;
    int32_t execute_ability_indices_;
    bool in_shop_;
    float camera_roaming_speed_;
    int32_t spec_target_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CSGOInputHistoryEntryPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSGOInputHistoryEntryPB) */ {
 public:
  inline CSGOInputHistoryEntryPB() : CSGOInputHistoryEntryPB(nullptr) {}
  ~CSGOInputHistoryEntryPB() override;
  explicit PROTOBUF_CONSTEXPR CSGOInputHistoryEntryPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSGOInputHistoryEntryPB(const CSGOInputHistoryEntryPB& from);
  CSGOInputHistoryEntryPB(CSGOInputHistoryEntryPB&& from) noexcept
    : CSGOInputHistoryEntryPB() {
    *this = ::std::move(from);
  }

  inline CSGOInputHistoryEntryPB& operator=(const CSGOInputHistoryEntryPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSGOInputHistoryEntryPB& operator=(CSGOInputHistoryEntryPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSGOInputHistoryEntryPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSGOInputHistoryEntryPB* internal_default_instance() {
    return reinterpret_cast<const CSGOInputHistoryEntryPB*>(
               &_CSGOInputHistoryEntryPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CSGOInputHistoryEntryPB& a, CSGOInputHistoryEntryPB& b) {
    a.Swap(&b);
  }
  inline void Swap(CSGOInputHistoryEntryPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSGOInputHistoryEntryPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSGOInputHistoryEntryPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSGOInputHistoryEntryPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSGOInputHistoryEntryPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CSGOInputHistoryEntryPB& from) {
    CSGOInputHistoryEntryPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSGOInputHistoryEntryPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSGOInputHistoryEntryPB";
  }
  protected:
  explicit CSGOInputHistoryEntryPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewAnglesFieldNumber = 2,
    kShootPositionFieldNumber = 3,
    kTargetHeadPosCheckFieldNumber = 9,
    kTargetPosCheckFieldNumber = 10,
    kRenderTickCountFieldNumber = 4,
    kRenderTickFractionFieldNumber = 5,
    kPlayerTickCountFieldNumber = 6,
    kPlayerTickFractionFieldNumber = 7,
    kTargetEntIndexFieldNumber = 8,
  };
  // optional .CMsgQAngle view_angles = 2;
  bool has_view_angles() const;
  private:
  bool _internal_has_view_angles() const;
  public:
  void clear_view_angles();
  const ::CMsgQAngle& view_angles() const;
  PROTOBUF_NODISCARD ::CMsgQAngle* release_view_angles();
  ::CMsgQAngle* mutable_view_angles();
  void set_allocated_view_angles(::CMsgQAngle* view_angles);
  private:
  const ::CMsgQAngle& _internal_view_angles() const;
  ::CMsgQAngle* _internal_mutable_view_angles();
  public:
  void unsafe_arena_set_allocated_view_angles(
      ::CMsgQAngle* view_angles);
  ::CMsgQAngle* unsafe_arena_release_view_angles();

  // optional .CMsgVector shoot_position = 3;
  bool has_shoot_position() const;
  private:
  bool _internal_has_shoot_position() const;
  public:
  void clear_shoot_position();
  const ::CMsgVector& shoot_position() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_shoot_position();
  ::CMsgVector* mutable_shoot_position();
  void set_allocated_shoot_position(::CMsgVector* shoot_position);
  private:
  const ::CMsgVector& _internal_shoot_position() const;
  ::CMsgVector* _internal_mutable_shoot_position();
  public:
  void unsafe_arena_set_allocated_shoot_position(
      ::CMsgVector* shoot_position);
  ::CMsgVector* unsafe_arena_release_shoot_position();

  // optional .CMsgVector target_head_pos_check = 9;
  bool has_target_head_pos_check() const;
  private:
  bool _internal_has_target_head_pos_check() const;
  public:
  void clear_target_head_pos_check();
  const ::CMsgVector& target_head_pos_check() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_target_head_pos_check();
  ::CMsgVector* mutable_target_head_pos_check();
  void set_allocated_target_head_pos_check(::CMsgVector* target_head_pos_check);
  private:
  const ::CMsgVector& _internal_target_head_pos_check() const;
  ::CMsgVector* _internal_mutable_target_head_pos_check();
  public:
  void unsafe_arena_set_allocated_target_head_pos_check(
      ::CMsgVector* target_head_pos_check);
  ::CMsgVector* unsafe_arena_release_target_head_pos_check();

  // optional .CMsgVector target_pos_check = 10;
  bool has_target_pos_check() const;
  private:
  bool _internal_has_target_pos_check() const;
  public:
  void clear_target_pos_check();
  const ::CMsgVector& target_pos_check() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_target_pos_check();
  ::CMsgVector* mutable_target_pos_check();
  void set_allocated_target_pos_check(::CMsgVector* target_pos_check);
  private:
  const ::CMsgVector& _internal_target_pos_check() const;
  ::CMsgVector* _internal_mutable_target_pos_check();
  public:
  void unsafe_arena_set_allocated_target_pos_check(
      ::CMsgVector* target_pos_check);
  ::CMsgVector* unsafe_arena_release_target_pos_check();

  // optional int32 render_tick_count = 4;
  bool has_render_tick_count() const;
  private:
  bool _internal_has_render_tick_count() const;
  public:
  void clear_render_tick_count();
  int32_t render_tick_count() const;
  void set_render_tick_count(int32_t value);
  private:
  int32_t _internal_render_tick_count() const;
  void _internal_set_render_tick_count(int32_t value);
  public:

  // optional float render_tick_fraction = 5;
  bool has_render_tick_fraction() const;
  private:
  bool _internal_has_render_tick_fraction() const;
  public:
  void clear_render_tick_fraction();
  float render_tick_fraction() const;
  void set_render_tick_fraction(float value);
  private:
  float _internal_render_tick_fraction() const;
  void _internal_set_render_tick_fraction(float value);
  public:

  // optional int32 player_tick_count = 6;
  bool has_player_tick_count() const;
  private:
  bool _internal_has_player_tick_count() const;
  public:
  void clear_player_tick_count();
  int32_t player_tick_count() const;
  void set_player_tick_count(int32_t value);
  private:
  int32_t _internal_player_tick_count() const;
  void _internal_set_player_tick_count(int32_t value);
  public:

  // optional float player_tick_fraction = 7;
  bool has_player_tick_fraction() const;
  private:
  bool _internal_has_player_tick_fraction() const;
  public:
  void clear_player_tick_fraction();
  float player_tick_fraction() const;
  void set_player_tick_fraction(float value);
  private:
  float _internal_player_tick_fraction() const;
  void _internal_set_player_tick_fraction(float value);
  public:

  // optional int32 target_ent_index = 8;
  bool has_target_ent_index() const;
  private:
  bool _internal_has_target_ent_index() const;
  public:
  void clear_target_ent_index();
  int32_t target_ent_index() const;
  void set_target_ent_index(int32_t value);
  private:
  int32_t _internal_target_ent_index() const;
  void _internal_set_target_ent_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSGOInputHistoryEntryPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgQAngle* view_angles_;
    ::CMsgVector* shoot_position_;
    ::CMsgVector* target_head_pos_check_;
    ::CMsgVector* target_pos_check_;
    int32_t render_tick_count_;
    float render_tick_fraction_;
    int32_t player_tick_count_;
    float player_tick_fraction_;
    int32_t target_ent_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CSGOUserCmdPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSGOUserCmdPB) */ {
 public:
  inline CSGOUserCmdPB() : CSGOUserCmdPB(nullptr) {}
  ~CSGOUserCmdPB() override;
  explicit PROTOBUF_CONSTEXPR CSGOUserCmdPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSGOUserCmdPB(const CSGOUserCmdPB& from);
  CSGOUserCmdPB(CSGOUserCmdPB&& from) noexcept
    : CSGOUserCmdPB() {
    *this = ::std::move(from);
  }

  inline CSGOUserCmdPB& operator=(const CSGOUserCmdPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSGOUserCmdPB& operator=(CSGOUserCmdPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSGOUserCmdPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSGOUserCmdPB* internal_default_instance() {
    return reinterpret_cast<const CSGOUserCmdPB*>(
               &_CSGOUserCmdPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CSGOUserCmdPB& a, CSGOUserCmdPB& b) {
    a.Swap(&b);
  }
  inline void Swap(CSGOUserCmdPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSGOUserCmdPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSGOUserCmdPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSGOUserCmdPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSGOUserCmdPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CSGOUserCmdPB& from) {
    CSGOUserCmdPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSGOUserCmdPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSGOUserCmdPB";
  }
  protected:
  explicit CSGOUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputHistoryFieldNumber = 2,
    kBaseFieldNumber = 1,
    kAttack1StartHistoryIndexFieldNumber = 6,
    kAttack2StartHistoryIndexFieldNumber = 7,
  };
  // repeated .CSGOInputHistoryEntryPB input_history = 2;
  int input_history_size() const;
  private:
  int _internal_input_history_size() const;
  public:
  void clear_input_history();
  ::CSGOInputHistoryEntryPB* mutable_input_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSGOInputHistoryEntryPB >*
      mutable_input_history();
  private:
  const ::CSGOInputHistoryEntryPB& _internal_input_history(int index) const;
  ::CSGOInputHistoryEntryPB* _internal_add_input_history();
  public:
  const ::CSGOInputHistoryEntryPB& input_history(int index) const;
  ::CSGOInputHistoryEntryPB* add_input_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSGOInputHistoryEntryPB >&
      input_history() const;

  // optional .CBaseUserCmdPB base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::CBaseUserCmdPB& base() const;
  PROTOBUF_NODISCARD ::CBaseUserCmdPB* release_base();
  ::CBaseUserCmdPB* mutable_base();
  void set_allocated_base(::CBaseUserCmdPB* base);
  private:
  const ::CBaseUserCmdPB& _internal_base() const;
  ::CBaseUserCmdPB* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::CBaseUserCmdPB* base);
  ::CBaseUserCmdPB* unsafe_arena_release_base();

  // optional int32 attack1_start_history_index = 6 [default = -1];
  bool has_attack1_start_history_index() const;
  private:
  bool _internal_has_attack1_start_history_index() const;
  public:
  void clear_attack1_start_history_index();
  int32_t attack1_start_history_index() const;
  void set_attack1_start_history_index(int32_t value);
  private:
  int32_t _internal_attack1_start_history_index() const;
  void _internal_set_attack1_start_history_index(int32_t value);
  public:

  // optional int32 attack2_start_history_index = 7 [default = -1];
  bool has_attack2_start_history_index() const;
  private:
  bool _internal_has_attack2_start_history_index() const;
  public:
  void clear_attack2_start_history_index();
  int32_t attack2_start_history_index() const;
  void set_attack2_start_history_index(int32_t value);
  private:
  int32_t _internal_attack2_start_history_index() const;
  void _internal_set_attack2_start_history_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSGOUserCmdPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSGOInputHistoryEntryPB > input_history_;
    ::CBaseUserCmdPB* base_;
    int32_t attack1_start_history_index_;
    int32_t attack2_start_history_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CMsgVRHandInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgVRHandInfo) */ {
 public:
  inline CMsgVRHandInfo() : CMsgVRHandInfo(nullptr) {}
  ~CMsgVRHandInfo() override;
  explicit PROTOBUF_CONSTEXPR CMsgVRHandInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgVRHandInfo(const CMsgVRHandInfo& from);
  CMsgVRHandInfo(CMsgVRHandInfo&& from) noexcept
    : CMsgVRHandInfo() {
    *this = ::std::move(from);
  }

  inline CMsgVRHandInfo& operator=(const CMsgVRHandInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgVRHandInfo& operator=(CMsgVRHandInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgVRHandInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgVRHandInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgVRHandInfo*>(
               &_CMsgVRHandInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CMsgVRHandInfo& a, CMsgVRHandInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgVRHandInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgVRHandInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgVRHandInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgVRHandInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgVRHandInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgVRHandInfo& from) {
    CMsgVRHandInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgVRHandInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgVRHandInfo";
  }
  protected:
  explicit CMsgVRHandInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVpositionFieldNumber = 1,
    kAnglesFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kLocalpositionFieldNumber = 4,
    kLocalanglesFieldNumber = 5,
    kFilteredpositionFieldNumber = 7,
    kFilteredanglesFieldNumber = 8,
    kFilteredvelocityFieldNumber = 9,
    kFilteredangularvelFieldNumber = 10,
    kFilteredthrowvelFieldNumber = 11,
    kSampletimeFieldNumber = 6,
    kTriggeranalogvalueFieldNumber = 12,
    kGripanalogvalueFieldNumber = 13,
    kFinger0FieldNumber = 14,
    kFinger1FieldNumber = 15,
    kFinger2FieldNumber = 16,
    kFinger3FieldNumber = 17,
    kFinger4FieldNumber = 18,
    kFingersplay0FieldNumber = 19,
    kFingersplay1FieldNumber = 20,
    kFingersplay2FieldNumber = 21,
    kFingersplay3FieldNumber = 22,
    kTrackpadanalogvaluexFieldNumber = 23,
    kTrackpadanalogvalueyFieldNumber = 24,
    kJoystickanalogvaluexFieldNumber = 25,
    kJoystickanalogvalueyFieldNumber = 26,
  };
  // optional .CMsgVector vposition = 1;
  bool has_vposition() const;
  private:
  bool _internal_has_vposition() const;
  public:
  void clear_vposition();
  const ::CMsgVector& vposition() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_vposition();
  ::CMsgVector* mutable_vposition();
  void set_allocated_vposition(::CMsgVector* vposition);
  private:
  const ::CMsgVector& _internal_vposition() const;
  ::CMsgVector* _internal_mutable_vposition();
  public:
  void unsafe_arena_set_allocated_vposition(
      ::CMsgVector* vposition);
  ::CMsgVector* unsafe_arena_release_vposition();

  // optional .CMsgQAngle angles = 2;
  bool has_angles() const;
  private:
  bool _internal_has_angles() const;
  public:
  void clear_angles();
  const ::CMsgQAngle& angles() const;
  PROTOBUF_NODISCARD ::CMsgQAngle* release_angles();
  ::CMsgQAngle* mutable_angles();
  void set_allocated_angles(::CMsgQAngle* angles);
  private:
  const ::CMsgQAngle& _internal_angles() const;
  ::CMsgQAngle* _internal_mutable_angles();
  public:
  void unsafe_arena_set_allocated_angles(
      ::CMsgQAngle* angles);
  ::CMsgQAngle* unsafe_arena_release_angles();

  // optional .CMsgVector velocity = 3;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::CMsgVector& velocity() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_velocity();
  ::CMsgVector* mutable_velocity();
  void set_allocated_velocity(::CMsgVector* velocity);
  private:
  const ::CMsgVector& _internal_velocity() const;
  ::CMsgVector* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::CMsgVector* velocity);
  ::CMsgVector* unsafe_arena_release_velocity();

  // optional .CMsgVector localposition = 4;
  bool has_localposition() const;
  private:
  bool _internal_has_localposition() const;
  public:
  void clear_localposition();
  const ::CMsgVector& localposition() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_localposition();
  ::CMsgVector* mutable_localposition();
  void set_allocated_localposition(::CMsgVector* localposition);
  private:
  const ::CMsgVector& _internal_localposition() const;
  ::CMsgVector* _internal_mutable_localposition();
  public:
  void unsafe_arena_set_allocated_localposition(
      ::CMsgVector* localposition);
  ::CMsgVector* unsafe_arena_release_localposition();

  // optional .CMsgQAngle localangles = 5;
  bool has_localangles() const;
  private:
  bool _internal_has_localangles() const;
  public:
  void clear_localangles();
  const ::CMsgQAngle& localangles() const;
  PROTOBUF_NODISCARD ::CMsgQAngle* release_localangles();
  ::CMsgQAngle* mutable_localangles();
  void set_allocated_localangles(::CMsgQAngle* localangles);
  private:
  const ::CMsgQAngle& _internal_localangles() const;
  ::CMsgQAngle* _internal_mutable_localangles();
  public:
  void unsafe_arena_set_allocated_localangles(
      ::CMsgQAngle* localangles);
  ::CMsgQAngle* unsafe_arena_release_localangles();

  // optional .CMsgVector filteredposition = 7;
  bool has_filteredposition() const;
  private:
  bool _internal_has_filteredposition() const;
  public:
  void clear_filteredposition();
  const ::CMsgVector& filteredposition() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_filteredposition();
  ::CMsgVector* mutable_filteredposition();
  void set_allocated_filteredposition(::CMsgVector* filteredposition);
  private:
  const ::CMsgVector& _internal_filteredposition() const;
  ::CMsgVector* _internal_mutable_filteredposition();
  public:
  void unsafe_arena_set_allocated_filteredposition(
      ::CMsgVector* filteredposition);
  ::CMsgVector* unsafe_arena_release_filteredposition();

  // optional .CMsgQAngle filteredangles = 8;
  bool has_filteredangles() const;
  private:
  bool _internal_has_filteredangles() const;
  public:
  void clear_filteredangles();
  const ::CMsgQAngle& filteredangles() const;
  PROTOBUF_NODISCARD ::CMsgQAngle* release_filteredangles();
  ::CMsgQAngle* mutable_filteredangles();
  void set_allocated_filteredangles(::CMsgQAngle* filteredangles);
  private:
  const ::CMsgQAngle& _internal_filteredangles() const;
  ::CMsgQAngle* _internal_mutable_filteredangles();
  public:
  void unsafe_arena_set_allocated_filteredangles(
      ::CMsgQAngle* filteredangles);
  ::CMsgQAngle* unsafe_arena_release_filteredangles();

  // optional .CMsgVector filteredvelocity = 9;
  bool has_filteredvelocity() const;
  private:
  bool _internal_has_filteredvelocity() const;
  public:
  void clear_filteredvelocity();
  const ::CMsgVector& filteredvelocity() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_filteredvelocity();
  ::CMsgVector* mutable_filteredvelocity();
  void set_allocated_filteredvelocity(::CMsgVector* filteredvelocity);
  private:
  const ::CMsgVector& _internal_filteredvelocity() const;
  ::CMsgVector* _internal_mutable_filteredvelocity();
  public:
  void unsafe_arena_set_allocated_filteredvelocity(
      ::CMsgVector* filteredvelocity);
  ::CMsgVector* unsafe_arena_release_filteredvelocity();

  // optional .CMsgVector filteredangularvel = 10;
  bool has_filteredangularvel() const;
  private:
  bool _internal_has_filteredangularvel() const;
  public:
  void clear_filteredangularvel();
  const ::CMsgVector& filteredangularvel() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_filteredangularvel();
  ::CMsgVector* mutable_filteredangularvel();
  void set_allocated_filteredangularvel(::CMsgVector* filteredangularvel);
  private:
  const ::CMsgVector& _internal_filteredangularvel() const;
  ::CMsgVector* _internal_mutable_filteredangularvel();
  public:
  void unsafe_arena_set_allocated_filteredangularvel(
      ::CMsgVector* filteredangularvel);
  ::CMsgVector* unsafe_arena_release_filteredangularvel();

  // optional .CMsgVector filteredthrowvel = 11;
  bool has_filteredthrowvel() const;
  private:
  bool _internal_has_filteredthrowvel() const;
  public:
  void clear_filteredthrowvel();
  const ::CMsgVector& filteredthrowvel() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_filteredthrowvel();
  ::CMsgVector* mutable_filteredthrowvel();
  void set_allocated_filteredthrowvel(::CMsgVector* filteredthrowvel);
  private:
  const ::CMsgVector& _internal_filteredthrowvel() const;
  ::CMsgVector* _internal_mutable_filteredthrowvel();
  public:
  void unsafe_arena_set_allocated_filteredthrowvel(
      ::CMsgVector* filteredthrowvel);
  ::CMsgVector* unsafe_arena_release_filteredthrowvel();

  // optional float sampletime = 6;
  bool has_sampletime() const;
  private:
  bool _internal_has_sampletime() const;
  public:
  void clear_sampletime();
  float sampletime() const;
  void set_sampletime(float value);
  private:
  float _internal_sampletime() const;
  void _internal_set_sampletime(float value);
  public:

  // optional float triggeranalogvalue = 12;
  bool has_triggeranalogvalue() const;
  private:
  bool _internal_has_triggeranalogvalue() const;
  public:
  void clear_triggeranalogvalue();
  float triggeranalogvalue() const;
  void set_triggeranalogvalue(float value);
  private:
  float _internal_triggeranalogvalue() const;
  void _internal_set_triggeranalogvalue(float value);
  public:

  // optional float gripanalogvalue = 13;
  bool has_gripanalogvalue() const;
  private:
  bool _internal_has_gripanalogvalue() const;
  public:
  void clear_gripanalogvalue();
  float gripanalogvalue() const;
  void set_gripanalogvalue(float value);
  private:
  float _internal_gripanalogvalue() const;
  void _internal_set_gripanalogvalue(float value);
  public:

  // optional float finger0 = 14;
  bool has_finger0() const;
  private:
  bool _internal_has_finger0() const;
  public:
  void clear_finger0();
  float finger0() const;
  void set_finger0(float value);
  private:
  float _internal_finger0() const;
  void _internal_set_finger0(float value);
  public:

  // optional float finger1 = 15;
  bool has_finger1() const;
  private:
  bool _internal_has_finger1() const;
  public:
  void clear_finger1();
  float finger1() const;
  void set_finger1(float value);
  private:
  float _internal_finger1() const;
  void _internal_set_finger1(float value);
  public:

  // optional float finger2 = 16;
  bool has_finger2() const;
  private:
  bool _internal_has_finger2() const;
  public:
  void clear_finger2();
  float finger2() const;
  void set_finger2(float value);
  private:
  float _internal_finger2() const;
  void _internal_set_finger2(float value);
  public:

  // optional float finger3 = 17;
  bool has_finger3() const;
  private:
  bool _internal_has_finger3() const;
  public:
  void clear_finger3();
  float finger3() const;
  void set_finger3(float value);
  private:
  float _internal_finger3() const;
  void _internal_set_finger3(float value);
  public:

  // optional float finger4 = 18;
  bool has_finger4() const;
  private:
  bool _internal_has_finger4() const;
  public:
  void clear_finger4();
  float finger4() const;
  void set_finger4(float value);
  private:
  float _internal_finger4() const;
  void _internal_set_finger4(float value);
  public:

  // optional float fingersplay0 = 19;
  bool has_fingersplay0() const;
  private:
  bool _internal_has_fingersplay0() const;
  public:
  void clear_fingersplay0();
  float fingersplay0() const;
  void set_fingersplay0(float value);
  private:
  float _internal_fingersplay0() const;
  void _internal_set_fingersplay0(float value);
  public:

  // optional float fingersplay1 = 20;
  bool has_fingersplay1() const;
  private:
  bool _internal_has_fingersplay1() const;
  public:
  void clear_fingersplay1();
  float fingersplay1() const;
  void set_fingersplay1(float value);
  private:
  float _internal_fingersplay1() const;
  void _internal_set_fingersplay1(float value);
  public:

  // optional float fingersplay2 = 21;
  bool has_fingersplay2() const;
  private:
  bool _internal_has_fingersplay2() const;
  public:
  void clear_fingersplay2();
  float fingersplay2() const;
  void set_fingersplay2(float value);
  private:
  float _internal_fingersplay2() const;
  void _internal_set_fingersplay2(float value);
  public:

  // optional float fingersplay3 = 22;
  bool has_fingersplay3() const;
  private:
  bool _internal_has_fingersplay3() const;
  public:
  void clear_fingersplay3();
  float fingersplay3() const;
  void set_fingersplay3(float value);
  private:
  float _internal_fingersplay3() const;
  void _internal_set_fingersplay3(float value);
  public:

  // optional float trackpadanalogvaluex = 23;
  bool has_trackpadanalogvaluex() const;
  private:
  bool _internal_has_trackpadanalogvaluex() const;
  public:
  void clear_trackpadanalogvaluex();
  float trackpadanalogvaluex() const;
  void set_trackpadanalogvaluex(float value);
  private:
  float _internal_trackpadanalogvaluex() const;
  void _internal_set_trackpadanalogvaluex(float value);
  public:

  // optional float trackpadanalogvaluey = 24;
  bool has_trackpadanalogvaluey() const;
  private:
  bool _internal_has_trackpadanalogvaluey() const;
  public:
  void clear_trackpadanalogvaluey();
  float trackpadanalogvaluey() const;
  void set_trackpadanalogvaluey(float value);
  private:
  float _internal_trackpadanalogvaluey() const;
  void _internal_set_trackpadanalogvaluey(float value);
  public:

  // optional float joystickanalogvaluex = 25;
  bool has_joystickanalogvaluex() const;
  private:
  bool _internal_has_joystickanalogvaluex() const;
  public:
  void clear_joystickanalogvaluex();
  float joystickanalogvaluex() const;
  void set_joystickanalogvaluex(float value);
  private:
  float _internal_joystickanalogvaluex() const;
  void _internal_set_joystickanalogvaluex(float value);
  public:

  // optional float joystickanalogvaluey = 26;
  bool has_joystickanalogvaluey() const;
  private:
  bool _internal_has_joystickanalogvaluey() const;
  public:
  void clear_joystickanalogvaluey();
  float joystickanalogvaluey() const;
  void set_joystickanalogvaluey(float value);
  private:
  float _internal_joystickanalogvaluey() const;
  void _internal_set_joystickanalogvaluey(float value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgVRHandInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgVector* vposition_;
    ::CMsgQAngle* angles_;
    ::CMsgVector* velocity_;
    ::CMsgVector* localposition_;
    ::CMsgQAngle* localangles_;
    ::CMsgVector* filteredposition_;
    ::CMsgQAngle* filteredangles_;
    ::CMsgVector* filteredvelocity_;
    ::CMsgVector* filteredangularvel_;
    ::CMsgVector* filteredthrowvel_;
    float sampletime_;
    float triggeranalogvalue_;
    float gripanalogvalue_;
    float finger0_;
    float finger1_;
    float finger2_;
    float finger3_;
    float finger4_;
    float fingersplay0_;
    float fingersplay1_;
    float fingersplay2_;
    float fingersplay3_;
    float trackpadanalogvaluex_;
    float trackpadanalogvaluey_;
    float joystickanalogvaluex_;
    float joystickanalogvaluey_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CMsgVRController final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgVRController) */ {
 public:
  inline CMsgVRController() : CMsgVRController(nullptr) {}
  ~CMsgVRController() override;
  explicit PROTOBUF_CONSTEXPR CMsgVRController(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgVRController(const CMsgVRController& from);
  CMsgVRController(CMsgVRController&& from) noexcept
    : CMsgVRController() {
    *this = ::std::move(from);
  }

  inline CMsgVRController& operator=(const CMsgVRController& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgVRController& operator=(CMsgVRController&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgVRController& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgVRController* internal_default_instance() {
    return reinterpret_cast<const CMsgVRController*>(
               &_CMsgVRController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CMsgVRController& a, CMsgVRController& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgVRController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgVRController* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgVRController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgVRController>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgVRController& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgVRController& from) {
    CMsgVRController::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgVRController* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgVRController";
  }
  protected:
  explicit CMsgVRController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 3,
    kActiveFieldNumber = 1,
    kSupportsSkeletonFieldNumber = 2,
  };
  // optional .CMsgVRHandInfo info = 3;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::CMsgVRHandInfo& info() const;
  PROTOBUF_NODISCARD ::CMsgVRHandInfo* release_info();
  ::CMsgVRHandInfo* mutable_info();
  void set_allocated_info(::CMsgVRHandInfo* info);
  private:
  const ::CMsgVRHandInfo& _internal_info() const;
  ::CMsgVRHandInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::CMsgVRHandInfo* info);
  ::CMsgVRHandInfo* unsafe_arena_release_info();

  // optional bool active = 1;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // optional bool supports_skeleton = 2;
  bool has_supports_skeleton() const;
  private:
  bool _internal_has_supports_skeleton() const;
  public:
  void clear_supports_skeleton();
  bool supports_skeleton() const;
  void set_supports_skeleton(bool value);
  private:
  bool _internal_supports_skeleton() const;
  void _internal_set_supports_skeleton(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgVRController)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgVRHandInfo* info_;
    bool active_;
    bool supports_skeleton_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CUserMsgVRCore final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CUserMsgVRCore) */ {
 public:
  inline CUserMsgVRCore() : CUserMsgVRCore(nullptr) {}
  ~CUserMsgVRCore() override;
  explicit PROTOBUF_CONSTEXPR CUserMsgVRCore(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CUserMsgVRCore(const CUserMsgVRCore& from);
  CUserMsgVRCore(CUserMsgVRCore&& from) noexcept
    : CUserMsgVRCore() {
    *this = ::std::move(from);
  }

  inline CUserMsgVRCore& operator=(const CUserMsgVRCore& from) {
    CopyFrom(from);
    return *this;
  }
  inline CUserMsgVRCore& operator=(CUserMsgVRCore&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CUserMsgVRCore& default_instance() {
    return *internal_default_instance();
  }
  static inline const CUserMsgVRCore* internal_default_instance() {
    return reinterpret_cast<const CUserMsgVRCore*>(
               &_CUserMsgVRCore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CUserMsgVRCore& a, CUserMsgVRCore& b) {
    a.Swap(&b);
  }
  inline void Swap(CUserMsgVRCore* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CUserMsgVRCore* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CUserMsgVRCore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CUserMsgVRCore>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CUserMsgVRCore& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CUserMsgVRCore& from) {
    CUserMsgVRCore::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CUserMsgVRCore* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CUserMsgVRCore";
  }
  protected:
  explicit CUserMsgVRCore(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHmdControllersFieldNumber = 6,
    kMiddleEyeLocalFieldNumber = 4,
    kViewanglesLocalFieldNumber = 5,
    kActiveFieldNumber = 1,
    kTargetingModeFieldNumber = 2,
    kControllerTypeFieldNumber = 3,
  };
  // repeated .CMsgVRController hmd_controllers = 6;
  int hmd_controllers_size() const;
  private:
  int _internal_hmd_controllers_size() const;
  public:
  void clear_hmd_controllers();
  ::CMsgVRController* mutable_hmd_controllers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgVRController >*
      mutable_hmd_controllers();
  private:
  const ::CMsgVRController& _internal_hmd_controllers(int index) const;
  ::CMsgVRController* _internal_add_hmd_controllers();
  public:
  const ::CMsgVRController& hmd_controllers(int index) const;
  ::CMsgVRController* add_hmd_controllers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgVRController >&
      hmd_controllers() const;

  // optional .CMsgVector middle_eye_local = 4;
  bool has_middle_eye_local() const;
  private:
  bool _internal_has_middle_eye_local() const;
  public:
  void clear_middle_eye_local();
  const ::CMsgVector& middle_eye_local() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_middle_eye_local();
  ::CMsgVector* mutable_middle_eye_local();
  void set_allocated_middle_eye_local(::CMsgVector* middle_eye_local);
  private:
  const ::CMsgVector& _internal_middle_eye_local() const;
  ::CMsgVector* _internal_mutable_middle_eye_local();
  public:
  void unsafe_arena_set_allocated_middle_eye_local(
      ::CMsgVector* middle_eye_local);
  ::CMsgVector* unsafe_arena_release_middle_eye_local();

  // optional .CMsgQAngle viewangles_local = 5;
  bool has_viewangles_local() const;
  private:
  bool _internal_has_viewangles_local() const;
  public:
  void clear_viewangles_local();
  const ::CMsgQAngle& viewangles_local() const;
  PROTOBUF_NODISCARD ::CMsgQAngle* release_viewangles_local();
  ::CMsgQAngle* mutable_viewangles_local();
  void set_allocated_viewangles_local(::CMsgQAngle* viewangles_local);
  private:
  const ::CMsgQAngle& _internal_viewangles_local() const;
  ::CMsgQAngle* _internal_mutable_viewangles_local();
  public:
  void unsafe_arena_set_allocated_viewangles_local(
      ::CMsgQAngle* viewangles_local);
  ::CMsgQAngle* unsafe_arena_release_viewangles_local();

  // optional bool active = 1;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // optional bool targeting_mode = 2;
  bool has_targeting_mode() const;
  private:
  bool _internal_has_targeting_mode() const;
  public:
  void clear_targeting_mode();
  bool targeting_mode() const;
  void set_targeting_mode(bool value);
  private:
  bool _internal_targeting_mode() const;
  void _internal_set_targeting_mode(bool value);
  public:

  // optional uint32 controller_type = 3;
  bool has_controller_type() const;
  private:
  bool _internal_has_controller_type() const;
  public:
  void clear_controller_type();
  uint32_t controller_type() const;
  void set_controller_type(uint32_t value);
  private:
  uint32_t _internal_controller_type() const;
  void _internal_set_controller_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CUserMsgVRCore)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgVRController > hmd_controllers_;
    ::CMsgVector* middle_eye_local_;
    ::CMsgQAngle* viewangles_local_;
    bool active_;
    bool targeting_mode_;
    uint32_t controller_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class VrInputDigitalActionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VrInputDigitalActionData) */ {
 public:
  inline VrInputDigitalActionData() : VrInputDigitalActionData(nullptr) {}
  ~VrInputDigitalActionData() override;
  explicit PROTOBUF_CONSTEXPR VrInputDigitalActionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VrInputDigitalActionData(const VrInputDigitalActionData& from);
  VrInputDigitalActionData(VrInputDigitalActionData&& from) noexcept
    : VrInputDigitalActionData() {
    *this = ::std::move(from);
  }

  inline VrInputDigitalActionData& operator=(const VrInputDigitalActionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VrInputDigitalActionData& operator=(VrInputDigitalActionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VrInputDigitalActionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VrInputDigitalActionData* internal_default_instance() {
    return reinterpret_cast<const VrInputDigitalActionData*>(
               &_VrInputDigitalActionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VrInputDigitalActionData& a, VrInputDigitalActionData& b) {
    a.Swap(&b);
  }
  inline void Swap(VrInputDigitalActionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VrInputDigitalActionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VrInputDigitalActionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VrInputDigitalActionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VrInputDigitalActionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VrInputDigitalActionData& from) {
    VrInputDigitalActionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VrInputDigitalActionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VrInputDigitalActionData";
  }
  protected:
  explicit VrInputDigitalActionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveoriginFieldNumber = 1,
    kActiveFieldNumber = 2,
    kStateFieldNumber = 3,
    kChangedFieldNumber = 4,
    kUpdatetimeFieldNumber = 5,
  };
  // optional uint64 activeorigin = 1;
  bool has_activeorigin() const;
  private:
  bool _internal_has_activeorigin() const;
  public:
  void clear_activeorigin();
  uint64_t activeorigin() const;
  void set_activeorigin(uint64_t value);
  private:
  uint64_t _internal_activeorigin() const;
  void _internal_set_activeorigin(uint64_t value);
  public:

  // optional bool active = 2;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // optional bool state = 3;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  bool state() const;
  void set_state(bool value);
  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);
  public:

  // optional bool changed = 4;
  bool has_changed() const;
  private:
  bool _internal_has_changed() const;
  public:
  void clear_changed();
  bool changed() const;
  void set_changed(bool value);
  private:
  bool _internal_changed() const;
  void _internal_set_changed(bool value);
  public:

  // optional float updatetime = 5;
  bool has_updatetime() const;
  private:
  bool _internal_has_updatetime() const;
  public:
  void clear_updatetime();
  float updatetime() const;
  void set_updatetime(float value);
  private:
  float _internal_updatetime() const;
  void _internal_set_updatetime(float value);
  public:

  // @@protoc_insertion_point(class_scope:VrInputDigitalActionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t activeorigin_;
    bool active_;
    bool state_;
    bool changed_;
    float updatetime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class VrInputAnalogActionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VrInputAnalogActionData) */ {
 public:
  inline VrInputAnalogActionData() : VrInputAnalogActionData(nullptr) {}
  ~VrInputAnalogActionData() override;
  explicit PROTOBUF_CONSTEXPR VrInputAnalogActionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VrInputAnalogActionData(const VrInputAnalogActionData& from);
  VrInputAnalogActionData(VrInputAnalogActionData&& from) noexcept
    : VrInputAnalogActionData() {
    *this = ::std::move(from);
  }

  inline VrInputAnalogActionData& operator=(const VrInputAnalogActionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VrInputAnalogActionData& operator=(VrInputAnalogActionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VrInputAnalogActionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VrInputAnalogActionData* internal_default_instance() {
    return reinterpret_cast<const VrInputAnalogActionData*>(
               &_VrInputAnalogActionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(VrInputAnalogActionData& a, VrInputAnalogActionData& b) {
    a.Swap(&b);
  }
  inline void Swap(VrInputAnalogActionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VrInputAnalogActionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VrInputAnalogActionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VrInputAnalogActionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VrInputAnalogActionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VrInputAnalogActionData& from) {
    VrInputAnalogActionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VrInputAnalogActionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VrInputAnalogActionData";
  }
  protected:
  explicit VrInputAnalogActionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kDeltaFieldNumber = 3,
    kActiveoriginFieldNumber = 1,
    kActiveFieldNumber = 4,
    kUpdatetimeFieldNumber = 5,
  };
  // optional .CMsgVector position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::CMsgVector& position() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_position();
  ::CMsgVector* mutable_position();
  void set_allocated_position(::CMsgVector* position);
  private:
  const ::CMsgVector& _internal_position() const;
  ::CMsgVector* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::CMsgVector* position);
  ::CMsgVector* unsafe_arena_release_position();

  // optional .CMsgVector delta = 3;
  bool has_delta() const;
  private:
  bool _internal_has_delta() const;
  public:
  void clear_delta();
  const ::CMsgVector& delta() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_delta();
  ::CMsgVector* mutable_delta();
  void set_allocated_delta(::CMsgVector* delta);
  private:
  const ::CMsgVector& _internal_delta() const;
  ::CMsgVector* _internal_mutable_delta();
  public:
  void unsafe_arena_set_allocated_delta(
      ::CMsgVector* delta);
  ::CMsgVector* unsafe_arena_release_delta();

  // optional uint64 activeorigin = 1;
  bool has_activeorigin() const;
  private:
  bool _internal_has_activeorigin() const;
  public:
  void clear_activeorigin();
  uint64_t activeorigin() const;
  void set_activeorigin(uint64_t value);
  private:
  uint64_t _internal_activeorigin() const;
  void _internal_set_activeorigin(uint64_t value);
  public:

  // optional bool active = 4;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // optional float updatetime = 5;
  bool has_updatetime() const;
  private:
  bool _internal_has_updatetime() const;
  public:
  void clear_updatetime();
  float updatetime() const;
  void set_updatetime(float value);
  private:
  float _internal_updatetime() const;
  void _internal_set_updatetime(float value);
  public:

  // @@protoc_insertion_point(class_scope:VrInputAnalogActionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgVector* position_;
    ::CMsgVector* delta_;
    uint64_t activeorigin_;
    bool active_;
    float updatetime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class VrInputSkeletalActionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VrInputSkeletalActionData) */ {
 public:
  inline VrInputSkeletalActionData() : VrInputSkeletalActionData(nullptr) {}
  ~VrInputSkeletalActionData() override;
  explicit PROTOBUF_CONSTEXPR VrInputSkeletalActionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VrInputSkeletalActionData(const VrInputSkeletalActionData& from);
  VrInputSkeletalActionData(VrInputSkeletalActionData&& from) noexcept
    : VrInputSkeletalActionData() {
    *this = ::std::move(from);
  }

  inline VrInputSkeletalActionData& operator=(const VrInputSkeletalActionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VrInputSkeletalActionData& operator=(VrInputSkeletalActionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VrInputSkeletalActionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VrInputSkeletalActionData* internal_default_instance() {
    return reinterpret_cast<const VrInputSkeletalActionData*>(
               &_VrInputSkeletalActionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VrInputSkeletalActionData& a, VrInputSkeletalActionData& b) {
    a.Swap(&b);
  }
  inline void Swap(VrInputSkeletalActionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VrInputSkeletalActionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VrInputSkeletalActionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VrInputSkeletalActionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VrInputSkeletalActionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VrInputSkeletalActionData& from) {
    VrInputSkeletalActionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VrInputSkeletalActionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VrInputSkeletalActionData";
  }
  protected:
  explicit VrInputSkeletalActionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveoriginFieldNumber = 2,
    kActiveFieldNumber = 1,
  };
  // optional uint64 activeorigin = 2;
  bool has_activeorigin() const;
  private:
  bool _internal_has_activeorigin() const;
  public:
  void clear_activeorigin();
  uint64_t activeorigin() const;
  void set_activeorigin(uint64_t value);
  private:
  uint64_t _internal_activeorigin() const;
  void _internal_set_activeorigin(uint64_t value);
  public:

  // optional bool active = 1;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:VrInputSkeletalActionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t activeorigin_;
    bool active_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class VrSkeletalSummaryData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VrSkeletalSummaryData) */ {
 public:
  inline VrSkeletalSummaryData() : VrSkeletalSummaryData(nullptr) {}
  ~VrSkeletalSummaryData() override;
  explicit PROTOBUF_CONSTEXPR VrSkeletalSummaryData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VrSkeletalSummaryData(const VrSkeletalSummaryData& from);
  VrSkeletalSummaryData(VrSkeletalSummaryData&& from) noexcept
    : VrSkeletalSummaryData() {
    *this = ::std::move(from);
  }

  inline VrSkeletalSummaryData& operator=(const VrSkeletalSummaryData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VrSkeletalSummaryData& operator=(VrSkeletalSummaryData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VrSkeletalSummaryData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VrSkeletalSummaryData* internal_default_instance() {
    return reinterpret_cast<const VrSkeletalSummaryData*>(
               &_VrSkeletalSummaryData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(VrSkeletalSummaryData& a, VrSkeletalSummaryData& b) {
    a.Swap(&b);
  }
  inline void Swap(VrSkeletalSummaryData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VrSkeletalSummaryData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VrSkeletalSummaryData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VrSkeletalSummaryData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VrSkeletalSummaryData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VrSkeletalSummaryData& from) {
    VrSkeletalSummaryData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VrSkeletalSummaryData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VrSkeletalSummaryData";
  }
  protected:
  explicit VrSkeletalSummaryData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFingercurlFieldNumber = 1,
    kFingersplayFieldNumber = 2,
  };
  // repeated float fingercurl = 1;
  int fingercurl_size() const;
  private:
  int _internal_fingercurl_size() const;
  public:
  void clear_fingercurl();
  private:
  float _internal_fingercurl(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_fingercurl() const;
  void _internal_add_fingercurl(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_fingercurl();
  public:
  float fingercurl(int index) const;
  void set_fingercurl(int index, float value);
  void add_fingercurl(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      fingercurl() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_fingercurl();

  // repeated float fingersplay = 2;
  int fingersplay_size() const;
  private:
  int _internal_fingersplay_size() const;
  public:
  void clear_fingersplay();
  private:
  float _internal_fingersplay(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_fingersplay() const;
  void _internal_add_fingersplay(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_fingersplay();
  public:
  float fingersplay(int index) const;
  void set_fingersplay(int index, float value);
  void add_fingersplay(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      fingersplay() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_fingersplay();

  // @@protoc_insertion_point(class_scope:VrSkeletalSummaryData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > fingercurl_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > fingersplay_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class VrSkeletalData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VrSkeletalData) */ {
 public:
  inline VrSkeletalData() : VrSkeletalData(nullptr) {}
  ~VrSkeletalData() override;
  explicit PROTOBUF_CONSTEXPR VrSkeletalData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VrSkeletalData(const VrSkeletalData& from);
  VrSkeletalData(VrSkeletalData&& from) noexcept
    : VrSkeletalData() {
    *this = ::std::move(from);
  }

  inline VrSkeletalData& operator=(const VrSkeletalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VrSkeletalData& operator=(VrSkeletalData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VrSkeletalData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VrSkeletalData* internal_default_instance() {
    return reinterpret_cast<const VrSkeletalData*>(
               &_VrSkeletalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VrSkeletalData& a, VrSkeletalData& b) {
    a.Swap(&b);
  }
  inline void Swap(VrSkeletalData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VrSkeletalData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VrSkeletalData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VrSkeletalData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VrSkeletalData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VrSkeletalData& from) {
    VrSkeletalData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VrSkeletalData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VrSkeletalData";
  }
  protected:
  explicit VrSkeletalData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompressedBoneTransformsFieldNumber = 5,
    kSkeletalActionDataFieldNumber = 1,
    kSkeletalSummaryDataFieldNumber = 2,
    kBoneCountFieldNumber = 3,
    kBoneTransformSourceFieldNumber = 4,
  };
  // optional bytes compressed_bone_transforms = 5;
  bool has_compressed_bone_transforms() const;
  private:
  bool _internal_has_compressed_bone_transforms() const;
  public:
  void clear_compressed_bone_transforms();
  const std::string& compressed_bone_transforms() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_compressed_bone_transforms(ArgT0&& arg0, ArgT... args);
  std::string* mutable_compressed_bone_transforms();
  PROTOBUF_NODISCARD std::string* release_compressed_bone_transforms();
  void set_allocated_compressed_bone_transforms(std::string* compressed_bone_transforms);
  private:
  const std::string& _internal_compressed_bone_transforms() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compressed_bone_transforms(const std::string& value);
  std::string* _internal_mutable_compressed_bone_transforms();
  public:

  // optional .VrInputSkeletalActionData skeletal_action_data = 1;
  bool has_skeletal_action_data() const;
  private:
  bool _internal_has_skeletal_action_data() const;
  public:
  void clear_skeletal_action_data();
  const ::VrInputSkeletalActionData& skeletal_action_data() const;
  PROTOBUF_NODISCARD ::VrInputSkeletalActionData* release_skeletal_action_data();
  ::VrInputSkeletalActionData* mutable_skeletal_action_data();
  void set_allocated_skeletal_action_data(::VrInputSkeletalActionData* skeletal_action_data);
  private:
  const ::VrInputSkeletalActionData& _internal_skeletal_action_data() const;
  ::VrInputSkeletalActionData* _internal_mutable_skeletal_action_data();
  public:
  void unsafe_arena_set_allocated_skeletal_action_data(
      ::VrInputSkeletalActionData* skeletal_action_data);
  ::VrInputSkeletalActionData* unsafe_arena_release_skeletal_action_data();

  // optional .VrSkeletalSummaryData skeletal_summary_data = 2;
  bool has_skeletal_summary_data() const;
  private:
  bool _internal_has_skeletal_summary_data() const;
  public:
  void clear_skeletal_summary_data();
  const ::VrSkeletalSummaryData& skeletal_summary_data() const;
  PROTOBUF_NODISCARD ::VrSkeletalSummaryData* release_skeletal_summary_data();
  ::VrSkeletalSummaryData* mutable_skeletal_summary_data();
  void set_allocated_skeletal_summary_data(::VrSkeletalSummaryData* skeletal_summary_data);
  private:
  const ::VrSkeletalSummaryData& _internal_skeletal_summary_data() const;
  ::VrSkeletalSummaryData* _internal_mutable_skeletal_summary_data();
  public:
  void unsafe_arena_set_allocated_skeletal_summary_data(
      ::VrSkeletalSummaryData* skeletal_summary_data);
  ::VrSkeletalSummaryData* unsafe_arena_release_skeletal_summary_data();

  // optional uint32 bone_count = 3;
  bool has_bone_count() const;
  private:
  bool _internal_has_bone_count() const;
  public:
  void clear_bone_count();
  uint32_t bone_count() const;
  void set_bone_count(uint32_t value);
  private:
  uint32_t _internal_bone_count() const;
  void _internal_set_bone_count(uint32_t value);
  public:

  // optional uint32 bone_transform_source = 4;
  bool has_bone_transform_source() const;
  private:
  bool _internal_has_bone_transform_source() const;
  public:
  void clear_bone_transform_source();
  uint32_t bone_transform_source() const;
  void set_bone_transform_source(uint32_t value);
  private:
  uint32_t _internal_bone_transform_source() const;
  void _internal_set_bone_transform_source(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VrSkeletalData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr compressed_bone_transforms_;
    ::VrInputSkeletalActionData* skeletal_action_data_;
    ::VrSkeletalSummaryData* skeletal_summary_data_;
    uint32_t bone_count_;
    uint32_t bone_transform_source_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class CUerMsgVRActions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CUerMsgVRActions) */ {
 public:
  inline CUerMsgVRActions() : CUerMsgVRActions(nullptr) {}
  ~CUerMsgVRActions() override;
  explicit PROTOBUF_CONSTEXPR CUerMsgVRActions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CUerMsgVRActions(const CUerMsgVRActions& from);
  CUerMsgVRActions(CUerMsgVRActions&& from) noexcept
    : CUerMsgVRActions() {
    *this = ::std::move(from);
  }

  inline CUerMsgVRActions& operator=(const CUerMsgVRActions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CUerMsgVRActions& operator=(CUerMsgVRActions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CUerMsgVRActions& default_instance() {
    return *internal_default_instance();
  }
  static inline const CUerMsgVRActions* internal_default_instance() {
    return reinterpret_cast<const CUerMsgVRActions*>(
               &_CUerMsgVRActions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CUerMsgVRActions& a, CUerMsgVRActions& b) {
    a.Swap(&b);
  }
  inline void Swap(CUerMsgVRActions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CUerMsgVRActions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CUerMsgVRActions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CUerMsgVRActions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CUerMsgVRActions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CUerMsgVRActions& from) {
    CUerMsgVRActions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CUerMsgVRActions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CUerMsgVRActions";
  }
  protected:
  explicit CUerMsgVRActions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigitalActionDataFieldNumber = 1,
    kAnalogActionDataFieldNumber = 2,
    kSkeletonFieldNumber = 3,
  };
  // repeated .VrInputDigitalActionData digital_action_data = 1;
  int digital_action_data_size() const;
  private:
  int _internal_digital_action_data_size() const;
  public:
  void clear_digital_action_data();
  ::VrInputDigitalActionData* mutable_digital_action_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrInputDigitalActionData >*
      mutable_digital_action_data();
  private:
  const ::VrInputDigitalActionData& _internal_digital_action_data(int index) const;
  ::VrInputDigitalActionData* _internal_add_digital_action_data();
  public:
  const ::VrInputDigitalActionData& digital_action_data(int index) const;
  ::VrInputDigitalActionData* add_digital_action_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrInputDigitalActionData >&
      digital_action_data() const;

  // repeated .VrInputAnalogActionData analog_action_data = 2;
  int analog_action_data_size() const;
  private:
  int _internal_analog_action_data_size() const;
  public:
  void clear_analog_action_data();
  ::VrInputAnalogActionData* mutable_analog_action_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrInputAnalogActionData >*
      mutable_analog_action_data();
  private:
  const ::VrInputAnalogActionData& _internal_analog_action_data(int index) const;
  ::VrInputAnalogActionData* _internal_add_analog_action_data();
  public:
  const ::VrInputAnalogActionData& analog_action_data(int index) const;
  ::VrInputAnalogActionData* add_analog_action_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrInputAnalogActionData >&
      analog_action_data() const;

  // repeated .VrSkeletalData skeleton = 3;
  int skeleton_size() const;
  private:
  int _internal_skeleton_size() const;
  public:
  void clear_skeleton();
  ::VrSkeletalData* mutable_skeleton(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrSkeletalData >*
      mutable_skeleton();
  private:
  const ::VrSkeletalData& _internal_skeleton(int index) const;
  ::VrSkeletalData* _internal_add_skeleton();
  public:
  const ::VrSkeletalData& skeleton(int index) const;
  ::VrSkeletalData* add_skeleton();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrSkeletalData >&
      skeleton() const;

  // @@protoc_insertion_point(class_scope:CUerMsgVRActions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrInputDigitalActionData > digital_action_data_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrInputAnalogActionData > analog_action_data_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrSkeletalData > skeleton_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// -------------------------------------------------------------------

class VRSampleUserCmdPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VRSampleUserCmdPB) */ {
 public:
  inline VRSampleUserCmdPB() : VRSampleUserCmdPB(nullptr) {}
  ~VRSampleUserCmdPB() override;
  explicit PROTOBUF_CONSTEXPR VRSampleUserCmdPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VRSampleUserCmdPB(const VRSampleUserCmdPB& from);
  VRSampleUserCmdPB(VRSampleUserCmdPB&& from) noexcept
    : VRSampleUserCmdPB() {
    *this = ::std::move(from);
  }

  inline VRSampleUserCmdPB& operator=(const VRSampleUserCmdPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline VRSampleUserCmdPB& operator=(VRSampleUserCmdPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VRSampleUserCmdPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const VRSampleUserCmdPB* internal_default_instance() {
    return reinterpret_cast<const VRSampleUserCmdPB*>(
               &_VRSampleUserCmdPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VRSampleUserCmdPB& a, VRSampleUserCmdPB& b) {
    a.Swap(&b);
  }
  inline void Swap(VRSampleUserCmdPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VRSampleUserCmdPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VRSampleUserCmdPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VRSampleUserCmdPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VRSampleUserCmdPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VRSampleUserCmdPB& from) {
    VRSampleUserCmdPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VRSampleUserCmdPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VRSampleUserCmdPB";
  }
  protected:
  explicit VRSampleUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
    kHmdFieldNumber = 2,
    kActionsFieldNumber = 3,
  };
  // optional .CBaseUserCmdPB base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::CBaseUserCmdPB& base() const;
  PROTOBUF_NODISCARD ::CBaseUserCmdPB* release_base();
  ::CBaseUserCmdPB* mutable_base();
  void set_allocated_base(::CBaseUserCmdPB* base);
  private:
  const ::CBaseUserCmdPB& _internal_base() const;
  ::CBaseUserCmdPB* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::CBaseUserCmdPB* base);
  ::CBaseUserCmdPB* unsafe_arena_release_base();

  // optional .CUserMsgVRCore hmd = 2;
  bool has_hmd() const;
  private:
  bool _internal_has_hmd() const;
  public:
  void clear_hmd();
  const ::CUserMsgVRCore& hmd() const;
  PROTOBUF_NODISCARD ::CUserMsgVRCore* release_hmd();
  ::CUserMsgVRCore* mutable_hmd();
  void set_allocated_hmd(::CUserMsgVRCore* hmd);
  private:
  const ::CUserMsgVRCore& _internal_hmd() const;
  ::CUserMsgVRCore* _internal_mutable_hmd();
  public:
  void unsafe_arena_set_allocated_hmd(
      ::CUserMsgVRCore* hmd);
  ::CUserMsgVRCore* unsafe_arena_release_hmd();

  // optional .CUerMsgVRActions actions = 3;
  bool has_actions() const;
  private:
  bool _internal_has_actions() const;
  public:
  void clear_actions();
  const ::CUerMsgVRActions& actions() const;
  PROTOBUF_NODISCARD ::CUerMsgVRActions* release_actions();
  ::CUerMsgVRActions* mutable_actions();
  void set_allocated_actions(::CUerMsgVRActions* actions);
  private:
  const ::CUerMsgVRActions& _internal_actions() const;
  ::CUerMsgVRActions* _internal_mutable_actions();
  public:
  void unsafe_arena_set_allocated_actions(
      ::CUerMsgVRActions* actions);
  ::CUerMsgVRActions* unsafe_arena_release_actions();

  // @@protoc_insertion_point(class_scope:VRSampleUserCmdPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CBaseUserCmdPB* base_;
    ::CUserMsgVRCore* hmd_;
    ::CUerMsgVRActions* actions_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usercmd_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CInButtonStatePB

// optional uint64 buttonstate1 = 1;
inline bool CInButtonStatePB::_internal_has_buttonstate1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInButtonStatePB::has_buttonstate1() const {
  return _internal_has_buttonstate1();
}
inline void CInButtonStatePB::clear_buttonstate1() {
  _impl_.buttonstate1_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CInButtonStatePB::_internal_buttonstate1() const {
  return _impl_.buttonstate1_;
}
inline uint64_t CInButtonStatePB::buttonstate1() const {
  // @@protoc_insertion_point(field_get:CInButtonStatePB.buttonstate1)
  return _internal_buttonstate1();
}
inline void CInButtonStatePB::_internal_set_buttonstate1(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buttonstate1_ = value;
}
inline void CInButtonStatePB::set_buttonstate1(uint64_t value) {
  _internal_set_buttonstate1(value);
  // @@protoc_insertion_point(field_set:CInButtonStatePB.buttonstate1)
}

// optional uint64 buttonstate2 = 2;
inline bool CInButtonStatePB::_internal_has_buttonstate2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInButtonStatePB::has_buttonstate2() const {
  return _internal_has_buttonstate2();
}
inline void CInButtonStatePB::clear_buttonstate2() {
  _impl_.buttonstate2_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CInButtonStatePB::_internal_buttonstate2() const {
  return _impl_.buttonstate2_;
}
inline uint64_t CInButtonStatePB::buttonstate2() const {
  // @@protoc_insertion_point(field_get:CInButtonStatePB.buttonstate2)
  return _internal_buttonstate2();
}
inline void CInButtonStatePB::_internal_set_buttonstate2(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.buttonstate2_ = value;
}
inline void CInButtonStatePB::set_buttonstate2(uint64_t value) {
  _internal_set_buttonstate2(value);
  // @@protoc_insertion_point(field_set:CInButtonStatePB.buttonstate2)
}

// optional uint64 buttonstate3 = 3;
inline bool CInButtonStatePB::_internal_has_buttonstate3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CInButtonStatePB::has_buttonstate3() const {
  return _internal_has_buttonstate3();
}
inline void CInButtonStatePB::clear_buttonstate3() {
  _impl_.buttonstate3_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CInButtonStatePB::_internal_buttonstate3() const {
  return _impl_.buttonstate3_;
}
inline uint64_t CInButtonStatePB::buttonstate3() const {
  // @@protoc_insertion_point(field_get:CInButtonStatePB.buttonstate3)
  return _internal_buttonstate3();
}
inline void CInButtonStatePB::_internal_set_buttonstate3(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.buttonstate3_ = value;
}
inline void CInButtonStatePB::set_buttonstate3(uint64_t value) {
  _internal_set_buttonstate3(value);
  // @@protoc_insertion_point(field_set:CInButtonStatePB.buttonstate3)
}

// -------------------------------------------------------------------

// CTicklessMoveStep

// optional int32 button = 1;
inline bool CTicklessMoveStep::_internal_has_button() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CTicklessMoveStep::has_button() const {
  return _internal_has_button();
}
inline void CTicklessMoveStep::clear_button() {
  _impl_.button_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CTicklessMoveStep::_internal_button() const {
  return _impl_.button_;
}
inline int32_t CTicklessMoveStep::button() const {
  // @@protoc_insertion_point(field_get:CTicklessMoveStep.button)
  return _internal_button();
}
inline void CTicklessMoveStep::_internal_set_button(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.button_ = value;
}
inline void CTicklessMoveStep::set_button(int32_t value) {
  _internal_set_button(value);
  // @@protoc_insertion_point(field_set:CTicklessMoveStep.button)
}

// optional bool pressed = 2;
inline bool CTicklessMoveStep::_internal_has_pressed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CTicklessMoveStep::has_pressed() const {
  return _internal_has_pressed();
}
inline void CTicklessMoveStep::clear_pressed() {
  _impl_.pressed_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CTicklessMoveStep::_internal_pressed() const {
  return _impl_.pressed_;
}
inline bool CTicklessMoveStep::pressed() const {
  // @@protoc_insertion_point(field_get:CTicklessMoveStep.pressed)
  return _internal_pressed();
}
inline void CTicklessMoveStep::_internal_set_pressed(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pressed_ = value;
}
inline void CTicklessMoveStep::set_pressed(bool value) {
  _internal_set_pressed(value);
  // @@protoc_insertion_point(field_set:CTicklessMoveStep.pressed)
}

// optional float when = 3;
inline bool CTicklessMoveStep::_internal_has_when() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CTicklessMoveStep::has_when() const {
  return _internal_has_when();
}
inline void CTicklessMoveStep::clear_when() {
  _impl_.when_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float CTicklessMoveStep::_internal_when() const {
  return _impl_.when_;
}
inline float CTicklessMoveStep::when() const {
  // @@protoc_insertion_point(field_get:CTicklessMoveStep.when)
  return _internal_when();
}
inline void CTicklessMoveStep::_internal_set_when(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.when_ = value;
}
inline void CTicklessMoveStep::set_when(float value) {
  _internal_set_when(value);
  // @@protoc_insertion_point(field_set:CTicklessMoveStep.when)
}

// -------------------------------------------------------------------

// CBaseUserCmdPB

// optional int32 command_number = 1;
inline bool CBaseUserCmdPB::_internal_has_command_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_command_number() const {
  return _internal_has_command_number();
}
inline void CBaseUserCmdPB::clear_command_number() {
  _impl_.command_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CBaseUserCmdPB::_internal_command_number() const {
  return _impl_.command_number_;
}
inline int32_t CBaseUserCmdPB::command_number() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.command_number)
  return _internal_command_number();
}
inline void CBaseUserCmdPB::_internal_set_command_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.command_number_ = value;
}
inline void CBaseUserCmdPB::set_command_number(int32_t value) {
  _internal_set_command_number(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.command_number)
}

// optional int32 tick_count = 2;
inline bool CBaseUserCmdPB::_internal_has_tick_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_tick_count() const {
  return _internal_has_tick_count();
}
inline void CBaseUserCmdPB::clear_tick_count() {
  _impl_.tick_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t CBaseUserCmdPB::_internal_tick_count() const {
  return _impl_.tick_count_;
}
inline int32_t CBaseUserCmdPB::tick_count() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.tick_count)
  return _internal_tick_count();
}
inline void CBaseUserCmdPB::_internal_set_tick_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tick_count_ = value;
}
inline void CBaseUserCmdPB::set_tick_count(int32_t value) {
  _internal_set_tick_count(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.tick_count)
}

// optional .CInButtonStatePB buttons_pb = 3;
inline bool CBaseUserCmdPB::_internal_has_buttons_pb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buttons_pb_ != nullptr);
  return value;
}
inline bool CBaseUserCmdPB::has_buttons_pb() const {
  return _internal_has_buttons_pb();
}
inline void CBaseUserCmdPB::clear_buttons_pb() {
  if (_impl_.buttons_pb_ != nullptr) _impl_.buttons_pb_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CInButtonStatePB& CBaseUserCmdPB::_internal_buttons_pb() const {
  const ::CInButtonStatePB* p = _impl_.buttons_pb_;
  return p != nullptr ? *p : reinterpret_cast<const ::CInButtonStatePB&>(
      ::_CInButtonStatePB_default_instance_);
}
inline const ::CInButtonStatePB& CBaseUserCmdPB::buttons_pb() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.buttons_pb)
  return _internal_buttons_pb();
}
inline void CBaseUserCmdPB::unsafe_arena_set_allocated_buttons_pb(
    ::CInButtonStatePB* buttons_pb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buttons_pb_);
  }
  _impl_.buttons_pb_ = buttons_pb;
  if (buttons_pb) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CBaseUserCmdPB.buttons_pb)
}
inline ::CInButtonStatePB* CBaseUserCmdPB::release_buttons_pb() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CInButtonStatePB* temp = _impl_.buttons_pb_;
  _impl_.buttons_pb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CInButtonStatePB* CBaseUserCmdPB::unsafe_arena_release_buttons_pb() {
  // @@protoc_insertion_point(field_release:CBaseUserCmdPB.buttons_pb)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CInButtonStatePB* temp = _impl_.buttons_pb_;
  _impl_.buttons_pb_ = nullptr;
  return temp;
}
inline ::CInButtonStatePB* CBaseUserCmdPB::_internal_mutable_buttons_pb() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.buttons_pb_ == nullptr) {
    auto* p = CreateMaybeMessage<::CInButtonStatePB>(GetArenaForAllocation());
    _impl_.buttons_pb_ = p;
  }
  return _impl_.buttons_pb_;
}
inline ::CInButtonStatePB* CBaseUserCmdPB::mutable_buttons_pb() {
  ::CInButtonStatePB* _msg = _internal_mutable_buttons_pb();
  // @@protoc_insertion_point(field_mutable:CBaseUserCmdPB.buttons_pb)
  return _msg;
}
inline void CBaseUserCmdPB::set_allocated_buttons_pb(::CInButtonStatePB* buttons_pb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.buttons_pb_;
  }
  if (buttons_pb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buttons_pb);
    if (message_arena != submessage_arena) {
      buttons_pb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buttons_pb, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buttons_pb_ = buttons_pb;
  // @@protoc_insertion_point(field_set_allocated:CBaseUserCmdPB.buttons_pb)
}

// optional .CMsgQAngle viewangles = 4;
inline bool CBaseUserCmdPB::_internal_has_viewangles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.viewangles_ != nullptr);
  return value;
}
inline bool CBaseUserCmdPB::has_viewangles() const {
  return _internal_has_viewangles();
}
inline const ::CMsgQAngle& CBaseUserCmdPB::_internal_viewangles() const {
  const ::CMsgQAngle* p = _impl_.viewangles_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgQAngle&>(
      ::_CMsgQAngle_default_instance_);
}
inline const ::CMsgQAngle& CBaseUserCmdPB::viewangles() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.viewangles)
  return _internal_viewangles();
}
inline void CBaseUserCmdPB::unsafe_arena_set_allocated_viewangles(
    ::CMsgQAngle* viewangles) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.viewangles_);
  }
  _impl_.viewangles_ = viewangles;
  if (viewangles) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CBaseUserCmdPB.viewangles)
}
inline ::CMsgQAngle* CBaseUserCmdPB::release_viewangles() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgQAngle* temp = _impl_.viewangles_;
  _impl_.viewangles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgQAngle* CBaseUserCmdPB::unsafe_arena_release_viewangles() {
  // @@protoc_insertion_point(field_release:CBaseUserCmdPB.viewangles)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgQAngle* temp = _impl_.viewangles_;
  _impl_.viewangles_ = nullptr;
  return temp;
}
inline ::CMsgQAngle* CBaseUserCmdPB::_internal_mutable_viewangles() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.viewangles_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgQAngle>(GetArenaForAllocation());
    _impl_.viewangles_ = p;
  }
  return _impl_.viewangles_;
}
inline ::CMsgQAngle* CBaseUserCmdPB::mutable_viewangles() {
  ::CMsgQAngle* _msg = _internal_mutable_viewangles();
  // @@protoc_insertion_point(field_mutable:CBaseUserCmdPB.viewangles)
  return _msg;
}
inline void CBaseUserCmdPB::set_allocated_viewangles(::CMsgQAngle* viewangles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.viewangles_);
  }
  if (viewangles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(viewangles));
    if (message_arena != submessage_arena) {
      viewangles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, viewangles, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.viewangles_ = viewangles;
  // @@protoc_insertion_point(field_set_allocated:CBaseUserCmdPB.viewangles)
}

// optional float forwardmove = 5;
inline bool CBaseUserCmdPB::_internal_has_forwardmove() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_forwardmove() const {
  return _internal_has_forwardmove();
}
inline void CBaseUserCmdPB::clear_forwardmove() {
  _impl_.forwardmove_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float CBaseUserCmdPB::_internal_forwardmove() const {
  return _impl_.forwardmove_;
}
inline float CBaseUserCmdPB::forwardmove() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.forwardmove)
  return _internal_forwardmove();
}
inline void CBaseUserCmdPB::_internal_set_forwardmove(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.forwardmove_ = value;
}
inline void CBaseUserCmdPB::set_forwardmove(float value) {
  _internal_set_forwardmove(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.forwardmove)
}

// optional float leftmove = 6;
inline bool CBaseUserCmdPB::_internal_has_leftmove() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_leftmove() const {
  return _internal_has_leftmove();
}
inline void CBaseUserCmdPB::clear_leftmove() {
  _impl_.leftmove_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float CBaseUserCmdPB::_internal_leftmove() const {
  return _impl_.leftmove_;
}
inline float CBaseUserCmdPB::leftmove() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.leftmove)
  return _internal_leftmove();
}
inline void CBaseUserCmdPB::_internal_set_leftmove(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.leftmove_ = value;
}
inline void CBaseUserCmdPB::set_leftmove(float value) {
  _internal_set_leftmove(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.leftmove)
}

// optional float upmove = 7;
inline bool CBaseUserCmdPB::_internal_has_upmove() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_upmove() const {
  return _internal_has_upmove();
}
inline void CBaseUserCmdPB::clear_upmove() {
  _impl_.upmove_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float CBaseUserCmdPB::_internal_upmove() const {
  return _impl_.upmove_;
}
inline float CBaseUserCmdPB::upmove() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.upmove)
  return _internal_upmove();
}
inline void CBaseUserCmdPB::_internal_set_upmove(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.upmove_ = value;
}
inline void CBaseUserCmdPB::set_upmove(float value) {
  _internal_set_upmove(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.upmove)
}

// optional int32 impulse = 8;
inline bool CBaseUserCmdPB::_internal_has_impulse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_impulse() const {
  return _internal_has_impulse();
}
inline void CBaseUserCmdPB::clear_impulse() {
  _impl_.impulse_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t CBaseUserCmdPB::_internal_impulse() const {
  return _impl_.impulse_;
}
inline int32_t CBaseUserCmdPB::impulse() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.impulse)
  return _internal_impulse();
}
inline void CBaseUserCmdPB::_internal_set_impulse(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.impulse_ = value;
}
inline void CBaseUserCmdPB::set_impulse(int32_t value) {
  _internal_set_impulse(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.impulse)
}

// optional int32 weaponselect = 9;
inline bool CBaseUserCmdPB::_internal_has_weaponselect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_weaponselect() const {
  return _internal_has_weaponselect();
}
inline void CBaseUserCmdPB::clear_weaponselect() {
  _impl_.weaponselect_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t CBaseUserCmdPB::_internal_weaponselect() const {
  return _impl_.weaponselect_;
}
inline int32_t CBaseUserCmdPB::weaponselect() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.weaponselect)
  return _internal_weaponselect();
}
inline void CBaseUserCmdPB::_internal_set_weaponselect(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.weaponselect_ = value;
}
inline void CBaseUserCmdPB::set_weaponselect(int32_t value) {
  _internal_set_weaponselect(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.weaponselect)
}

// optional int32 random_seed = 10;
inline bool CBaseUserCmdPB::_internal_has_random_seed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_random_seed() const {
  return _internal_has_random_seed();
}
inline void CBaseUserCmdPB::clear_random_seed() {
  _impl_.random_seed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t CBaseUserCmdPB::_internal_random_seed() const {
  return _impl_.random_seed_;
}
inline int32_t CBaseUserCmdPB::random_seed() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.random_seed)
  return _internal_random_seed();
}
inline void CBaseUserCmdPB::_internal_set_random_seed(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.random_seed_ = value;
}
inline void CBaseUserCmdPB::set_random_seed(int32_t value) {
  _internal_set_random_seed(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.random_seed)
}

// optional int32 mousedx = 11;
inline bool CBaseUserCmdPB::_internal_has_mousedx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_mousedx() const {
  return _internal_has_mousedx();
}
inline void CBaseUserCmdPB::clear_mousedx() {
  _impl_.mousedx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int32_t CBaseUserCmdPB::_internal_mousedx() const {
  return _impl_.mousedx_;
}
inline int32_t CBaseUserCmdPB::mousedx() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.mousedx)
  return _internal_mousedx();
}
inline void CBaseUserCmdPB::_internal_set_mousedx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.mousedx_ = value;
}
inline void CBaseUserCmdPB::set_mousedx(int32_t value) {
  _internal_set_mousedx(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.mousedx)
}

// optional int32 mousedy = 12;
inline bool CBaseUserCmdPB::_internal_has_mousedy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_mousedy() const {
  return _internal_has_mousedy();
}
inline void CBaseUserCmdPB::clear_mousedy() {
  _impl_.mousedy_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int32_t CBaseUserCmdPB::_internal_mousedy() const {
  return _impl_.mousedy_;
}
inline int32_t CBaseUserCmdPB::mousedy() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.mousedy)
  return _internal_mousedy();
}
inline void CBaseUserCmdPB::_internal_set_mousedy(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.mousedy_ = value;
}
inline void CBaseUserCmdPB::set_mousedy(int32_t value) {
  _internal_set_mousedy(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.mousedy)
}

// optional bool hasbeenpredicted = 13;
inline bool CBaseUserCmdPB::_internal_has_hasbeenpredicted() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_hasbeenpredicted() const {
  return _internal_has_hasbeenpredicted();
}
inline void CBaseUserCmdPB::clear_hasbeenpredicted() {
  _impl_.hasbeenpredicted_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool CBaseUserCmdPB::_internal_hasbeenpredicted() const {
  return _impl_.hasbeenpredicted_;
}
inline bool CBaseUserCmdPB::hasbeenpredicted() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.hasbeenpredicted)
  return _internal_hasbeenpredicted();
}
inline void CBaseUserCmdPB::_internal_set_hasbeenpredicted(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.hasbeenpredicted_ = value;
}
inline void CBaseUserCmdPB::set_hasbeenpredicted(bool value) {
  _internal_set_hasbeenpredicted(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.hasbeenpredicted)
}

// optional uint32 pawn_entity_handle = 14 [default = 16777215];
inline bool CBaseUserCmdPB::_internal_has_pawn_entity_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CBaseUserCmdPB::has_pawn_entity_handle() const {
  return _internal_has_pawn_entity_handle();
}
inline void CBaseUserCmdPB::clear_pawn_entity_handle() {
  _impl_.pawn_entity_handle_ = 16777215u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t CBaseUserCmdPB::_internal_pawn_entity_handle() const {
  return _impl_.pawn_entity_handle_;
}
inline uint32_t CBaseUserCmdPB::pawn_entity_handle() const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.pawn_entity_handle)
  return _internal_pawn_entity_handle();
}
inline void CBaseUserCmdPB::_internal_set_pawn_entity_handle(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.pawn_entity_handle_ = value;
}
inline void CBaseUserCmdPB::set_pawn_entity_handle(uint32_t value) {
  _internal_set_pawn_entity_handle(value);
  // @@protoc_insertion_point(field_set:CBaseUserCmdPB.pawn_entity_handle)
}

// repeated .CTicklessMoveStep tickless_moves = 18;
inline int CBaseUserCmdPB::_internal_tickless_moves_size() const {
  return _impl_.tickless_moves_.size();
}
inline int CBaseUserCmdPB::tickless_moves_size() const {
  return _internal_tickless_moves_size();
}
inline void CBaseUserCmdPB::clear_tickless_moves() {
  _impl_.tickless_moves_.Clear();
}
inline ::CTicklessMoveStep* CBaseUserCmdPB::mutable_tickless_moves(int index) {
  // @@protoc_insertion_point(field_mutable:CBaseUserCmdPB.tickless_moves)
  return _impl_.tickless_moves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTicklessMoveStep >*
CBaseUserCmdPB::mutable_tickless_moves() {
  // @@protoc_insertion_point(field_mutable_list:CBaseUserCmdPB.tickless_moves)
  return &_impl_.tickless_moves_;
}
inline const ::CTicklessMoveStep& CBaseUserCmdPB::_internal_tickless_moves(int index) const {
  return _impl_.tickless_moves_.Get(index);
}
inline const ::CTicklessMoveStep& CBaseUserCmdPB::tickless_moves(int index) const {
  // @@protoc_insertion_point(field_get:CBaseUserCmdPB.tickless_moves)
  return _internal_tickless_moves(index);
}
inline ::CTicklessMoveStep* CBaseUserCmdPB::_internal_add_tickless_moves() {
  return _impl_.tickless_moves_.Add();
}
inline ::CTicklessMoveStep* CBaseUserCmdPB::add_tickless_moves() {
  ::CTicklessMoveStep* _add = _internal_add_tickless_moves();
  // @@protoc_insertion_point(field_add:CBaseUserCmdPB.tickless_moves)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTicklessMoveStep >&
CBaseUserCmdPB::tickless_moves() const {
  // @@protoc_insertion_point(field_list:CBaseUserCmdPB.tickless_moves)
  return _impl_.tickless_moves_;
}

// -------------------------------------------------------------------

// CUserCmdBasePB

// optional .CBaseUserCmdPB base = 1;
inline bool CUserCmdBasePB::_internal_has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline bool CUserCmdBasePB::has_base() const {
  return _internal_has_base();
}
inline void CUserCmdBasePB::clear_base() {
  if (_impl_.base_ != nullptr) _impl_.base_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CBaseUserCmdPB& CUserCmdBasePB::_internal_base() const {
  const ::CBaseUserCmdPB* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::CBaseUserCmdPB&>(
      ::_CBaseUserCmdPB_default_instance_);
}
inline const ::CBaseUserCmdPB& CUserCmdBasePB::base() const {
  // @@protoc_insertion_point(field_get:CUserCmdBasePB.base)
  return _internal_base();
}
inline void CUserCmdBasePB::unsafe_arena_set_allocated_base(
    ::CBaseUserCmdPB* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CUserCmdBasePB.base)
}
inline ::CBaseUserCmdPB* CUserCmdBasePB::release_base() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CBaseUserCmdPB* CUserCmdBasePB::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:CUserCmdBasePB.base)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::CBaseUserCmdPB* CUserCmdBasePB::_internal_mutable_base() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::CBaseUserCmdPB>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::CBaseUserCmdPB* CUserCmdBasePB::mutable_base() {
  ::CBaseUserCmdPB* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:CUserCmdBasePB.base)
  return _msg;
}
inline void CUserCmdBasePB::set_allocated_base(::CBaseUserCmdPB* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:CUserCmdBasePB.base)
}

// -------------------------------------------------------------------

// CHLXUserCmdPB

// optional .CBaseUserCmdPB base = 1;
inline bool CHLXUserCmdPB::_internal_has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline bool CHLXUserCmdPB::has_base() const {
  return _internal_has_base();
}
inline void CHLXUserCmdPB::clear_base() {
  if (_impl_.base_ != nullptr) _impl_.base_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CBaseUserCmdPB& CHLXUserCmdPB::_internal_base() const {
  const ::CBaseUserCmdPB* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::CBaseUserCmdPB&>(
      ::_CBaseUserCmdPB_default_instance_);
}
inline const ::CBaseUserCmdPB& CHLXUserCmdPB::base() const {
  // @@protoc_insertion_point(field_get:CHLXUserCmdPB.base)
  return _internal_base();
}
inline void CHLXUserCmdPB::unsafe_arena_set_allocated_base(
    ::CBaseUserCmdPB* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CHLXUserCmdPB.base)
}
inline ::CBaseUserCmdPB* CHLXUserCmdPB::release_base() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CBaseUserCmdPB* CHLXUserCmdPB::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:CHLXUserCmdPB.base)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::CBaseUserCmdPB* CHLXUserCmdPB::_internal_mutable_base() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::CBaseUserCmdPB>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::CBaseUserCmdPB* CHLXUserCmdPB::mutable_base() {
  ::CBaseUserCmdPB* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:CHLXUserCmdPB.base)
  return _msg;
}
inline void CHLXUserCmdPB::set_allocated_base(::CBaseUserCmdPB* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:CHLXUserCmdPB.base)
}

// -------------------------------------------------------------------

// CDota2UserCmdPB

// optional .CBaseUserCmdPB base = 1;
inline bool CDota2UserCmdPB::_internal_has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline bool CDota2UserCmdPB::has_base() const {
  return _internal_has_base();
}
inline void CDota2UserCmdPB::clear_base() {
  if (_impl_.base_ != nullptr) _impl_.base_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CBaseUserCmdPB& CDota2UserCmdPB::_internal_base() const {
  const ::CBaseUserCmdPB* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::CBaseUserCmdPB&>(
      ::_CBaseUserCmdPB_default_instance_);
}
inline const ::CBaseUserCmdPB& CDota2UserCmdPB::base() const {
  // @@protoc_insertion_point(field_get:CDota2UserCmdPB.base)
  return _internal_base();
}
inline void CDota2UserCmdPB::unsafe_arena_set_allocated_base(
    ::CBaseUserCmdPB* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CDota2UserCmdPB.base)
}
inline ::CBaseUserCmdPB* CDota2UserCmdPB::release_base() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CBaseUserCmdPB* CDota2UserCmdPB::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:CDota2UserCmdPB.base)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::CBaseUserCmdPB* CDota2UserCmdPB::_internal_mutable_base() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::CBaseUserCmdPB>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::CBaseUserCmdPB* CDota2UserCmdPB::mutable_base() {
  ::CBaseUserCmdPB* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:CDota2UserCmdPB.base)
  return _msg;
}
inline void CDota2UserCmdPB::set_allocated_base(::CBaseUserCmdPB* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:CDota2UserCmdPB.base)
}

// optional int32 spectator_query_unit_entindex = 2;
inline bool CDota2UserCmdPB::_internal_has_spectator_query_unit_entindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CDota2UserCmdPB::has_spectator_query_unit_entindex() const {
  return _internal_has_spectator_query_unit_entindex();
}
inline void CDota2UserCmdPB::clear_spectator_query_unit_entindex() {
  _impl_.spectator_query_unit_entindex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CDota2UserCmdPB::_internal_spectator_query_unit_entindex() const {
  return _impl_.spectator_query_unit_entindex_;
}
inline int32_t CDota2UserCmdPB::spectator_query_unit_entindex() const {
  // @@protoc_insertion_point(field_get:CDota2UserCmdPB.spectator_query_unit_entindex)
  return _internal_spectator_query_unit_entindex();
}
inline void CDota2UserCmdPB::_internal_set_spectator_query_unit_entindex(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.spectator_query_unit_entindex_ = value;
}
inline void CDota2UserCmdPB::set_spectator_query_unit_entindex(int32_t value) {
  _internal_set_spectator_query_unit_entindex(value);
  // @@protoc_insertion_point(field_set:CDota2UserCmdPB.spectator_query_unit_entindex)
}

// optional .CMsgVector crosshairtrace = 3;
inline bool CDota2UserCmdPB::_internal_has_crosshairtrace() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.crosshairtrace_ != nullptr);
  return value;
}
inline bool CDota2UserCmdPB::has_crosshairtrace() const {
  return _internal_has_crosshairtrace();
}
inline const ::CMsgVector& CDota2UserCmdPB::_internal_crosshairtrace() const {
  const ::CMsgVector* p = _impl_.crosshairtrace_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CDota2UserCmdPB::crosshairtrace() const {
  // @@protoc_insertion_point(field_get:CDota2UserCmdPB.crosshairtrace)
  return _internal_crosshairtrace();
}
inline void CDota2UserCmdPB::unsafe_arena_set_allocated_crosshairtrace(
    ::CMsgVector* crosshairtrace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.crosshairtrace_);
  }
  _impl_.crosshairtrace_ = crosshairtrace;
  if (crosshairtrace) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CDota2UserCmdPB.crosshairtrace)
}
inline ::CMsgVector* CDota2UserCmdPB::release_crosshairtrace() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgVector* temp = _impl_.crosshairtrace_;
  _impl_.crosshairtrace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CDota2UserCmdPB::unsafe_arena_release_crosshairtrace() {
  // @@protoc_insertion_point(field_release:CDota2UserCmdPB.crosshairtrace)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgVector* temp = _impl_.crosshairtrace_;
  _impl_.crosshairtrace_ = nullptr;
  return temp;
}
inline ::CMsgVector* CDota2UserCmdPB::_internal_mutable_crosshairtrace() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.crosshairtrace_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.crosshairtrace_ = p;
  }
  return _impl_.crosshairtrace_;
}
inline ::CMsgVector* CDota2UserCmdPB::mutable_crosshairtrace() {
  ::CMsgVector* _msg = _internal_mutable_crosshairtrace();
  // @@protoc_insertion_point(field_mutable:CDota2UserCmdPB.crosshairtrace)
  return _msg;
}
inline void CDota2UserCmdPB::set_allocated_crosshairtrace(::CMsgVector* crosshairtrace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.crosshairtrace_);
  }
  if (crosshairtrace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(crosshairtrace));
    if (message_arena != submessage_arena) {
      crosshairtrace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crosshairtrace, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.crosshairtrace_ = crosshairtrace;
  // @@protoc_insertion_point(field_set_allocated:CDota2UserCmdPB.crosshairtrace)
}

// optional int32 cameraposition_x = 4;
inline bool CDota2UserCmdPB::_internal_has_cameraposition_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CDota2UserCmdPB::has_cameraposition_x() const {
  return _internal_has_cameraposition_x();
}
inline void CDota2UserCmdPB::clear_cameraposition_x() {
  _impl_.cameraposition_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t CDota2UserCmdPB::_internal_cameraposition_x() const {
  return _impl_.cameraposition_x_;
}
inline int32_t CDota2UserCmdPB::cameraposition_x() const {
  // @@protoc_insertion_point(field_get:CDota2UserCmdPB.cameraposition_x)
  return _internal_cameraposition_x();
}
inline void CDota2UserCmdPB::_internal_set_cameraposition_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cameraposition_x_ = value;
}
inline void CDota2UserCmdPB::set_cameraposition_x(int32_t value) {
  _internal_set_cameraposition_x(value);
  // @@protoc_insertion_point(field_set:CDota2UserCmdPB.cameraposition_x)
}

// optional int32 cameraposition_y = 5;
inline bool CDota2UserCmdPB::_internal_has_cameraposition_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CDota2UserCmdPB::has_cameraposition_y() const {
  return _internal_has_cameraposition_y();
}
inline void CDota2UserCmdPB::clear_cameraposition_y() {
  _impl_.cameraposition_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t CDota2UserCmdPB::_internal_cameraposition_y() const {
  return _impl_.cameraposition_y_;
}
inline int32_t CDota2UserCmdPB::cameraposition_y() const {
  // @@protoc_insertion_point(field_get:CDota2UserCmdPB.cameraposition_y)
  return _internal_cameraposition_y();
}
inline void CDota2UserCmdPB::_internal_set_cameraposition_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.cameraposition_y_ = value;
}
inline void CDota2UserCmdPB::set_cameraposition_y(int32_t value) {
  _internal_set_cameraposition_y(value);
  // @@protoc_insertion_point(field_set:CDota2UserCmdPB.cameraposition_y)
}

// optional uint32 clickbehavior = 6;
inline bool CDota2UserCmdPB::_internal_has_clickbehavior() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CDota2UserCmdPB::has_clickbehavior() const {
  return _internal_has_clickbehavior();
}
inline void CDota2UserCmdPB::clear_clickbehavior() {
  _impl_.clickbehavior_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CDota2UserCmdPB::_internal_clickbehavior() const {
  return _impl_.clickbehavior_;
}
inline uint32_t CDota2UserCmdPB::clickbehavior() const {
  // @@protoc_insertion_point(field_get:CDota2UserCmdPB.clickbehavior)
  return _internal_clickbehavior();
}
inline void CDota2UserCmdPB::_internal_set_clickbehavior(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.clickbehavior_ = value;
}
inline void CDota2UserCmdPB::set_clickbehavior(uint32_t value) {
  _internal_set_clickbehavior(value);
  // @@protoc_insertion_point(field_set:CDota2UserCmdPB.clickbehavior)
}

// optional uint32 statspanel = 7;
inline bool CDota2UserCmdPB::_internal_has_statspanel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CDota2UserCmdPB::has_statspanel() const {
  return _internal_has_statspanel();
}
inline void CDota2UserCmdPB::clear_statspanel() {
  _impl_.statspanel_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CDota2UserCmdPB::_internal_statspanel() const {
  return _impl_.statspanel_;
}
inline uint32_t CDota2UserCmdPB::statspanel() const {
  // @@protoc_insertion_point(field_get:CDota2UserCmdPB.statspanel)
  return _internal_statspanel();
}
inline void CDota2UserCmdPB::_internal_set_statspanel(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.statspanel_ = value;
}
inline void CDota2UserCmdPB::set_statspanel(uint32_t value) {
  _internal_set_statspanel(value);
  // @@protoc_insertion_point(field_set:CDota2UserCmdPB.statspanel)
}

// optional uint32 shoppanel = 8;
inline bool CDota2UserCmdPB::_internal_has_shoppanel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CDota2UserCmdPB::has_shoppanel() const {
  return _internal_has_shoppanel();
}
inline void CDota2UserCmdPB::clear_shoppanel() {
  _impl_.shoppanel_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CDota2UserCmdPB::_internal_shoppanel() const {
  return _impl_.shoppanel_;
}
inline uint32_t CDota2UserCmdPB::shoppanel() const {
  // @@protoc_insertion_point(field_get:CDota2UserCmdPB.shoppanel)
  return _internal_shoppanel();
}
inline void CDota2UserCmdPB::_internal_set_shoppanel(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.shoppanel_ = value;
}
inline void CDota2UserCmdPB::set_shoppanel(uint32_t value) {
  _internal_set_shoppanel(value);
  // @@protoc_insertion_point(field_set:CDota2UserCmdPB.shoppanel)
}

// optional uint32 stats_dropdown = 9;
inline bool CDota2UserCmdPB::_internal_has_stats_dropdown() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CDota2UserCmdPB::has_stats_dropdown() const {
  return _internal_has_stats_dropdown();
}
inline void CDota2UserCmdPB::clear_stats_dropdown() {
  _impl_.stats_dropdown_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CDota2UserCmdPB::_internal_stats_dropdown() const {
  return _impl_.stats_dropdown_;
}
inline uint32_t CDota2UserCmdPB::stats_dropdown() const {
  // @@protoc_insertion_point(field_get:CDota2UserCmdPB.stats_dropdown)
  return _internal_stats_dropdown();
}
inline void CDota2UserCmdPB::_internal_set_stats_dropdown(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.stats_dropdown_ = value;
}
inline void CDota2UserCmdPB::set_stats_dropdown(uint32_t value) {
  _internal_set_stats_dropdown(value);
  // @@protoc_insertion_point(field_set:CDota2UserCmdPB.stats_dropdown)
}

// optional uint32 stats_dropdown_sort = 10;
inline bool CDota2UserCmdPB::_internal_has_stats_dropdown_sort() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CDota2UserCmdPB::has_stats_dropdown_sort() const {
  return _internal_has_stats_dropdown_sort();
}
inline void CDota2UserCmdPB::clear_stats_dropdown_sort() {
  _impl_.stats_dropdown_sort_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CDota2UserCmdPB::_internal_stats_dropdown_sort() const {
  return _impl_.stats_dropdown_sort_;
}
inline uint32_t CDota2UserCmdPB::stats_dropdown_sort() const {
  // @@protoc_insertion_point(field_get:CDota2UserCmdPB.stats_dropdown_sort)
  return _internal_stats_dropdown_sort();
}
inline void CDota2UserCmdPB::_internal_set_stats_dropdown_sort(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.stats_dropdown_sort_ = value;
}
inline void CDota2UserCmdPB::set_stats_dropdown_sort(uint32_t value) {
  _internal_set_stats_dropdown_sort(value);
  // @@protoc_insertion_point(field_set:CDota2UserCmdPB.stats_dropdown_sort)
}

// -------------------------------------------------------------------

// CCitadelUserCmdPB

// optional .CBaseUserCmdPB base = 1;
inline bool CCitadelUserCmdPB::_internal_has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline bool CCitadelUserCmdPB::has_base() const {
  return _internal_has_base();
}
inline void CCitadelUserCmdPB::clear_base() {
  if (_impl_.base_ != nullptr) _impl_.base_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CBaseUserCmdPB& CCitadelUserCmdPB::_internal_base() const {
  const ::CBaseUserCmdPB* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::CBaseUserCmdPB&>(
      ::_CBaseUserCmdPB_default_instance_);
}
inline const ::CBaseUserCmdPB& CCitadelUserCmdPB::base() const {
  // @@protoc_insertion_point(field_get:CCitadelUserCmdPB.base)
  return _internal_base();
}
inline void CCitadelUserCmdPB::unsafe_arena_set_allocated_base(
    ::CBaseUserCmdPB* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CCitadelUserCmdPB.base)
}
inline ::CBaseUserCmdPB* CCitadelUserCmdPB::release_base() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CBaseUserCmdPB* CCitadelUserCmdPB::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:CCitadelUserCmdPB.base)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::CBaseUserCmdPB* CCitadelUserCmdPB::_internal_mutable_base() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::CBaseUserCmdPB>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::CBaseUserCmdPB* CCitadelUserCmdPB::mutable_base() {
  ::CBaseUserCmdPB* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:CCitadelUserCmdPB.base)
  return _msg;
}
inline void CCitadelUserCmdPB::set_allocated_base(::CBaseUserCmdPB* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:CCitadelUserCmdPB.base)
}

// optional .CMsgVector vec_camera_position = 2;
inline bool CCitadelUserCmdPB::_internal_has_vec_camera_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vec_camera_position_ != nullptr);
  return value;
}
inline bool CCitadelUserCmdPB::has_vec_camera_position() const {
  return _internal_has_vec_camera_position();
}
inline const ::CMsgVector& CCitadelUserCmdPB::_internal_vec_camera_position() const {
  const ::CMsgVector* p = _impl_.vec_camera_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CCitadelUserCmdPB::vec_camera_position() const {
  // @@protoc_insertion_point(field_get:CCitadelUserCmdPB.vec_camera_position)
  return _internal_vec_camera_position();
}
inline void CCitadelUserCmdPB::unsafe_arena_set_allocated_vec_camera_position(
    ::CMsgVector* vec_camera_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vec_camera_position_);
  }
  _impl_.vec_camera_position_ = vec_camera_position;
  if (vec_camera_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CCitadelUserCmdPB.vec_camera_position)
}
inline ::CMsgVector* CCitadelUserCmdPB::release_vec_camera_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgVector* temp = _impl_.vec_camera_position_;
  _impl_.vec_camera_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CCitadelUserCmdPB::unsafe_arena_release_vec_camera_position() {
  // @@protoc_insertion_point(field_release:CCitadelUserCmdPB.vec_camera_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgVector* temp = _impl_.vec_camera_position_;
  _impl_.vec_camera_position_ = nullptr;
  return temp;
}
inline ::CMsgVector* CCitadelUserCmdPB::_internal_mutable_vec_camera_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.vec_camera_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.vec_camera_position_ = p;
  }
  return _impl_.vec_camera_position_;
}
inline ::CMsgVector* CCitadelUserCmdPB::mutable_vec_camera_position() {
  ::CMsgVector* _msg = _internal_mutable_vec_camera_position();
  // @@protoc_insertion_point(field_mutable:CCitadelUserCmdPB.vec_camera_position)
  return _msg;
}
inline void CCitadelUserCmdPB::set_allocated_vec_camera_position(::CMsgVector* vec_camera_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vec_camera_position_);
  }
  if (vec_camera_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vec_camera_position));
    if (message_arena != submessage_arena) {
      vec_camera_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vec_camera_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vec_camera_position_ = vec_camera_position;
  // @@protoc_insertion_point(field_set_allocated:CCitadelUserCmdPB.vec_camera_position)
}

// optional .CMsgQAngle ang_camera_angles = 3;
inline bool CCitadelUserCmdPB::_internal_has_ang_camera_angles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ang_camera_angles_ != nullptr);
  return value;
}
inline bool CCitadelUserCmdPB::has_ang_camera_angles() const {
  return _internal_has_ang_camera_angles();
}
inline const ::CMsgQAngle& CCitadelUserCmdPB::_internal_ang_camera_angles() const {
  const ::CMsgQAngle* p = _impl_.ang_camera_angles_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgQAngle&>(
      ::_CMsgQAngle_default_instance_);
}
inline const ::CMsgQAngle& CCitadelUserCmdPB::ang_camera_angles() const {
  // @@protoc_insertion_point(field_get:CCitadelUserCmdPB.ang_camera_angles)
  return _internal_ang_camera_angles();
}
inline void CCitadelUserCmdPB::unsafe_arena_set_allocated_ang_camera_angles(
    ::CMsgQAngle* ang_camera_angles) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ang_camera_angles_);
  }
  _impl_.ang_camera_angles_ = ang_camera_angles;
  if (ang_camera_angles) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CCitadelUserCmdPB.ang_camera_angles)
}
inline ::CMsgQAngle* CCitadelUserCmdPB::release_ang_camera_angles() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgQAngle* temp = _impl_.ang_camera_angles_;
  _impl_.ang_camera_angles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgQAngle* CCitadelUserCmdPB::unsafe_arena_release_ang_camera_angles() {
  // @@protoc_insertion_point(field_release:CCitadelUserCmdPB.ang_camera_angles)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgQAngle* temp = _impl_.ang_camera_angles_;
  _impl_.ang_camera_angles_ = nullptr;
  return temp;
}
inline ::CMsgQAngle* CCitadelUserCmdPB::_internal_mutable_ang_camera_angles() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ang_camera_angles_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgQAngle>(GetArenaForAllocation());
    _impl_.ang_camera_angles_ = p;
  }
  return _impl_.ang_camera_angles_;
}
inline ::CMsgQAngle* CCitadelUserCmdPB::mutable_ang_camera_angles() {
  ::CMsgQAngle* _msg = _internal_mutable_ang_camera_angles();
  // @@protoc_insertion_point(field_mutable:CCitadelUserCmdPB.ang_camera_angles)
  return _msg;
}
inline void CCitadelUserCmdPB::set_allocated_ang_camera_angles(::CMsgQAngle* ang_camera_angles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ang_camera_angles_);
  }
  if (ang_camera_angles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ang_camera_angles));
    if (message_arena != submessage_arena) {
      ang_camera_angles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ang_camera_angles, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ang_camera_angles_ = ang_camera_angles;
  // @@protoc_insertion_point(field_set_allocated:CCitadelUserCmdPB.ang_camera_angles)
}

// optional int32 execute_ability_indices = 4;
inline bool CCitadelUserCmdPB::_internal_has_execute_ability_indices() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CCitadelUserCmdPB::has_execute_ability_indices() const {
  return _internal_has_execute_ability_indices();
}
inline void CCitadelUserCmdPB::clear_execute_ability_indices() {
  _impl_.execute_ability_indices_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t CCitadelUserCmdPB::_internal_execute_ability_indices() const {
  return _impl_.execute_ability_indices_;
}
inline int32_t CCitadelUserCmdPB::execute_ability_indices() const {
  // @@protoc_insertion_point(field_get:CCitadelUserCmdPB.execute_ability_indices)
  return _internal_execute_ability_indices();
}
inline void CCitadelUserCmdPB::_internal_set_execute_ability_indices(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.execute_ability_indices_ = value;
}
inline void CCitadelUserCmdPB::set_execute_ability_indices(int32_t value) {
  _internal_set_execute_ability_indices(value);
  // @@protoc_insertion_point(field_set:CCitadelUserCmdPB.execute_ability_indices)
}

// optional bool in_shop = 5;
inline bool CCitadelUserCmdPB::_internal_has_in_shop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CCitadelUserCmdPB::has_in_shop() const {
  return _internal_has_in_shop();
}
inline void CCitadelUserCmdPB::clear_in_shop() {
  _impl_.in_shop_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool CCitadelUserCmdPB::_internal_in_shop() const {
  return _impl_.in_shop_;
}
inline bool CCitadelUserCmdPB::in_shop() const {
  // @@protoc_insertion_point(field_get:CCitadelUserCmdPB.in_shop)
  return _internal_in_shop();
}
inline void CCitadelUserCmdPB::_internal_set_in_shop(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.in_shop_ = value;
}
inline void CCitadelUserCmdPB::set_in_shop(bool value) {
  _internal_set_in_shop(value);
  // @@protoc_insertion_point(field_set:CCitadelUserCmdPB.in_shop)
}

// optional float camera_roaming_speed = 6;
inline bool CCitadelUserCmdPB::_internal_has_camera_roaming_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CCitadelUserCmdPB::has_camera_roaming_speed() const {
  return _internal_has_camera_roaming_speed();
}
inline void CCitadelUserCmdPB::clear_camera_roaming_speed() {
  _impl_.camera_roaming_speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float CCitadelUserCmdPB::_internal_camera_roaming_speed() const {
  return _impl_.camera_roaming_speed_;
}
inline float CCitadelUserCmdPB::camera_roaming_speed() const {
  // @@protoc_insertion_point(field_get:CCitadelUserCmdPB.camera_roaming_speed)
  return _internal_camera_roaming_speed();
}
inline void CCitadelUserCmdPB::_internal_set_camera_roaming_speed(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.camera_roaming_speed_ = value;
}
inline void CCitadelUserCmdPB::set_camera_roaming_speed(float value) {
  _internal_set_camera_roaming_speed(value);
  // @@protoc_insertion_point(field_set:CCitadelUserCmdPB.camera_roaming_speed)
}

// optional int32 spec_target = 7 [default = -1];
inline bool CCitadelUserCmdPB::_internal_has_spec_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CCitadelUserCmdPB::has_spec_target() const {
  return _internal_has_spec_target();
}
inline void CCitadelUserCmdPB::clear_spec_target() {
  _impl_.spec_target_ = -1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t CCitadelUserCmdPB::_internal_spec_target() const {
  return _impl_.spec_target_;
}
inline int32_t CCitadelUserCmdPB::spec_target() const {
  // @@protoc_insertion_point(field_get:CCitadelUserCmdPB.spec_target)
  return _internal_spec_target();
}
inline void CCitadelUserCmdPB::_internal_set_spec_target(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.spec_target_ = value;
}
inline void CCitadelUserCmdPB::set_spec_target(int32_t value) {
  _internal_set_spec_target(value);
  // @@protoc_insertion_point(field_set:CCitadelUserCmdPB.spec_target)
}

// -------------------------------------------------------------------

// CSGOInputHistoryEntryPB

// optional .CMsgQAngle view_angles = 2;
inline bool CSGOInputHistoryEntryPB::_internal_has_view_angles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.view_angles_ != nullptr);
  return value;
}
inline bool CSGOInputHistoryEntryPB::has_view_angles() const {
  return _internal_has_view_angles();
}
inline const ::CMsgQAngle& CSGOInputHistoryEntryPB::_internal_view_angles() const {
  const ::CMsgQAngle* p = _impl_.view_angles_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgQAngle&>(
      ::_CMsgQAngle_default_instance_);
}
inline const ::CMsgQAngle& CSGOInputHistoryEntryPB::view_angles() const {
  // @@protoc_insertion_point(field_get:CSGOInputHistoryEntryPB.view_angles)
  return _internal_view_angles();
}
inline void CSGOInputHistoryEntryPB::unsafe_arena_set_allocated_view_angles(
    ::CMsgQAngle* view_angles) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.view_angles_);
  }
  _impl_.view_angles_ = view_angles;
  if (view_angles) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSGOInputHistoryEntryPB.view_angles)
}
inline ::CMsgQAngle* CSGOInputHistoryEntryPB::release_view_angles() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgQAngle* temp = _impl_.view_angles_;
  _impl_.view_angles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgQAngle* CSGOInputHistoryEntryPB::unsafe_arena_release_view_angles() {
  // @@protoc_insertion_point(field_release:CSGOInputHistoryEntryPB.view_angles)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgQAngle* temp = _impl_.view_angles_;
  _impl_.view_angles_ = nullptr;
  return temp;
}
inline ::CMsgQAngle* CSGOInputHistoryEntryPB::_internal_mutable_view_angles() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.view_angles_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgQAngle>(GetArenaForAllocation());
    _impl_.view_angles_ = p;
  }
  return _impl_.view_angles_;
}
inline ::CMsgQAngle* CSGOInputHistoryEntryPB::mutable_view_angles() {
  ::CMsgQAngle* _msg = _internal_mutable_view_angles();
  // @@protoc_insertion_point(field_mutable:CSGOInputHistoryEntryPB.view_angles)
  return _msg;
}
inline void CSGOInputHistoryEntryPB::set_allocated_view_angles(::CMsgQAngle* view_angles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.view_angles_);
  }
  if (view_angles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(view_angles));
    if (message_arena != submessage_arena) {
      view_angles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view_angles, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.view_angles_ = view_angles;
  // @@protoc_insertion_point(field_set_allocated:CSGOInputHistoryEntryPB.view_angles)
}

// optional .CMsgVector shoot_position = 3;
inline bool CSGOInputHistoryEntryPB::_internal_has_shoot_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shoot_position_ != nullptr);
  return value;
}
inline bool CSGOInputHistoryEntryPB::has_shoot_position() const {
  return _internal_has_shoot_position();
}
inline const ::CMsgVector& CSGOInputHistoryEntryPB::_internal_shoot_position() const {
  const ::CMsgVector* p = _impl_.shoot_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CSGOInputHistoryEntryPB::shoot_position() const {
  // @@protoc_insertion_point(field_get:CSGOInputHistoryEntryPB.shoot_position)
  return _internal_shoot_position();
}
inline void CSGOInputHistoryEntryPB::unsafe_arena_set_allocated_shoot_position(
    ::CMsgVector* shoot_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shoot_position_);
  }
  _impl_.shoot_position_ = shoot_position;
  if (shoot_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSGOInputHistoryEntryPB.shoot_position)
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::release_shoot_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgVector* temp = _impl_.shoot_position_;
  _impl_.shoot_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::unsafe_arena_release_shoot_position() {
  // @@protoc_insertion_point(field_release:CSGOInputHistoryEntryPB.shoot_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgVector* temp = _impl_.shoot_position_;
  _impl_.shoot_position_ = nullptr;
  return temp;
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::_internal_mutable_shoot_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.shoot_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.shoot_position_ = p;
  }
  return _impl_.shoot_position_;
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::mutable_shoot_position() {
  ::CMsgVector* _msg = _internal_mutable_shoot_position();
  // @@protoc_insertion_point(field_mutable:CSGOInputHistoryEntryPB.shoot_position)
  return _msg;
}
inline void CSGOInputHistoryEntryPB::set_allocated_shoot_position(::CMsgVector* shoot_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shoot_position_);
  }
  if (shoot_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shoot_position));
    if (message_arena != submessage_arena) {
      shoot_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shoot_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.shoot_position_ = shoot_position;
  // @@protoc_insertion_point(field_set_allocated:CSGOInputHistoryEntryPB.shoot_position)
}

// optional int32 render_tick_count = 4;
inline bool CSGOInputHistoryEntryPB::_internal_has_render_tick_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSGOInputHistoryEntryPB::has_render_tick_count() const {
  return _internal_has_render_tick_count();
}
inline void CSGOInputHistoryEntryPB::clear_render_tick_count() {
  _impl_.render_tick_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t CSGOInputHistoryEntryPB::_internal_render_tick_count() const {
  return _impl_.render_tick_count_;
}
inline int32_t CSGOInputHistoryEntryPB::render_tick_count() const {
  // @@protoc_insertion_point(field_get:CSGOInputHistoryEntryPB.render_tick_count)
  return _internal_render_tick_count();
}
inline void CSGOInputHistoryEntryPB::_internal_set_render_tick_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.render_tick_count_ = value;
}
inline void CSGOInputHistoryEntryPB::set_render_tick_count(int32_t value) {
  _internal_set_render_tick_count(value);
  // @@protoc_insertion_point(field_set:CSGOInputHistoryEntryPB.render_tick_count)
}

// optional float render_tick_fraction = 5;
inline bool CSGOInputHistoryEntryPB::_internal_has_render_tick_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CSGOInputHistoryEntryPB::has_render_tick_fraction() const {
  return _internal_has_render_tick_fraction();
}
inline void CSGOInputHistoryEntryPB::clear_render_tick_fraction() {
  _impl_.render_tick_fraction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float CSGOInputHistoryEntryPB::_internal_render_tick_fraction() const {
  return _impl_.render_tick_fraction_;
}
inline float CSGOInputHistoryEntryPB::render_tick_fraction() const {
  // @@protoc_insertion_point(field_get:CSGOInputHistoryEntryPB.render_tick_fraction)
  return _internal_render_tick_fraction();
}
inline void CSGOInputHistoryEntryPB::_internal_set_render_tick_fraction(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.render_tick_fraction_ = value;
}
inline void CSGOInputHistoryEntryPB::set_render_tick_fraction(float value) {
  _internal_set_render_tick_fraction(value);
  // @@protoc_insertion_point(field_set:CSGOInputHistoryEntryPB.render_tick_fraction)
}

// optional int32 player_tick_count = 6;
inline bool CSGOInputHistoryEntryPB::_internal_has_player_tick_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CSGOInputHistoryEntryPB::has_player_tick_count() const {
  return _internal_has_player_tick_count();
}
inline void CSGOInputHistoryEntryPB::clear_player_tick_count() {
  _impl_.player_tick_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t CSGOInputHistoryEntryPB::_internal_player_tick_count() const {
  return _impl_.player_tick_count_;
}
inline int32_t CSGOInputHistoryEntryPB::player_tick_count() const {
  // @@protoc_insertion_point(field_get:CSGOInputHistoryEntryPB.player_tick_count)
  return _internal_player_tick_count();
}
inline void CSGOInputHistoryEntryPB::_internal_set_player_tick_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.player_tick_count_ = value;
}
inline void CSGOInputHistoryEntryPB::set_player_tick_count(int32_t value) {
  _internal_set_player_tick_count(value);
  // @@protoc_insertion_point(field_set:CSGOInputHistoryEntryPB.player_tick_count)
}

// optional float player_tick_fraction = 7;
inline bool CSGOInputHistoryEntryPB::_internal_has_player_tick_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CSGOInputHistoryEntryPB::has_player_tick_fraction() const {
  return _internal_has_player_tick_fraction();
}
inline void CSGOInputHistoryEntryPB::clear_player_tick_fraction() {
  _impl_.player_tick_fraction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float CSGOInputHistoryEntryPB::_internal_player_tick_fraction() const {
  return _impl_.player_tick_fraction_;
}
inline float CSGOInputHistoryEntryPB::player_tick_fraction() const {
  // @@protoc_insertion_point(field_get:CSGOInputHistoryEntryPB.player_tick_fraction)
  return _internal_player_tick_fraction();
}
inline void CSGOInputHistoryEntryPB::_internal_set_player_tick_fraction(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.player_tick_fraction_ = value;
}
inline void CSGOInputHistoryEntryPB::set_player_tick_fraction(float value) {
  _internal_set_player_tick_fraction(value);
  // @@protoc_insertion_point(field_set:CSGOInputHistoryEntryPB.player_tick_fraction)
}

// optional int32 target_ent_index = 8;
inline bool CSGOInputHistoryEntryPB::_internal_has_target_ent_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CSGOInputHistoryEntryPB::has_target_ent_index() const {
  return _internal_has_target_ent_index();
}
inline void CSGOInputHistoryEntryPB::clear_target_ent_index() {
  _impl_.target_ent_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t CSGOInputHistoryEntryPB::_internal_target_ent_index() const {
  return _impl_.target_ent_index_;
}
inline int32_t CSGOInputHistoryEntryPB::target_ent_index() const {
  // @@protoc_insertion_point(field_get:CSGOInputHistoryEntryPB.target_ent_index)
  return _internal_target_ent_index();
}
inline void CSGOInputHistoryEntryPB::_internal_set_target_ent_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.target_ent_index_ = value;
}
inline void CSGOInputHistoryEntryPB::set_target_ent_index(int32_t value) {
  _internal_set_target_ent_index(value);
  // @@protoc_insertion_point(field_set:CSGOInputHistoryEntryPB.target_ent_index)
}

// optional .CMsgVector target_head_pos_check = 9;
inline bool CSGOInputHistoryEntryPB::_internal_has_target_head_pos_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_head_pos_check_ != nullptr);
  return value;
}
inline bool CSGOInputHistoryEntryPB::has_target_head_pos_check() const {
  return _internal_has_target_head_pos_check();
}
inline const ::CMsgVector& CSGOInputHistoryEntryPB::_internal_target_head_pos_check() const {
  const ::CMsgVector* p = _impl_.target_head_pos_check_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CSGOInputHistoryEntryPB::target_head_pos_check() const {
  // @@protoc_insertion_point(field_get:CSGOInputHistoryEntryPB.target_head_pos_check)
  return _internal_target_head_pos_check();
}
inline void CSGOInputHistoryEntryPB::unsafe_arena_set_allocated_target_head_pos_check(
    ::CMsgVector* target_head_pos_check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_head_pos_check_);
  }
  _impl_.target_head_pos_check_ = target_head_pos_check;
  if (target_head_pos_check) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSGOInputHistoryEntryPB.target_head_pos_check)
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::release_target_head_pos_check() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgVector* temp = _impl_.target_head_pos_check_;
  _impl_.target_head_pos_check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::unsafe_arena_release_target_head_pos_check() {
  // @@protoc_insertion_point(field_release:CSGOInputHistoryEntryPB.target_head_pos_check)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgVector* temp = _impl_.target_head_pos_check_;
  _impl_.target_head_pos_check_ = nullptr;
  return temp;
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::_internal_mutable_target_head_pos_check() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.target_head_pos_check_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.target_head_pos_check_ = p;
  }
  return _impl_.target_head_pos_check_;
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::mutable_target_head_pos_check() {
  ::CMsgVector* _msg = _internal_mutable_target_head_pos_check();
  // @@protoc_insertion_point(field_mutable:CSGOInputHistoryEntryPB.target_head_pos_check)
  return _msg;
}
inline void CSGOInputHistoryEntryPB::set_allocated_target_head_pos_check(::CMsgVector* target_head_pos_check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_head_pos_check_);
  }
  if (target_head_pos_check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_head_pos_check));
    if (message_arena != submessage_arena) {
      target_head_pos_check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_head_pos_check, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.target_head_pos_check_ = target_head_pos_check;
  // @@protoc_insertion_point(field_set_allocated:CSGOInputHistoryEntryPB.target_head_pos_check)
}

// optional .CMsgVector target_pos_check = 10;
inline bool CSGOInputHistoryEntryPB::_internal_has_target_pos_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_pos_check_ != nullptr);
  return value;
}
inline bool CSGOInputHistoryEntryPB::has_target_pos_check() const {
  return _internal_has_target_pos_check();
}
inline const ::CMsgVector& CSGOInputHistoryEntryPB::_internal_target_pos_check() const {
  const ::CMsgVector* p = _impl_.target_pos_check_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CSGOInputHistoryEntryPB::target_pos_check() const {
  // @@protoc_insertion_point(field_get:CSGOInputHistoryEntryPB.target_pos_check)
  return _internal_target_pos_check();
}
inline void CSGOInputHistoryEntryPB::unsafe_arena_set_allocated_target_pos_check(
    ::CMsgVector* target_pos_check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_pos_check_);
  }
  _impl_.target_pos_check_ = target_pos_check;
  if (target_pos_check) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSGOInputHistoryEntryPB.target_pos_check)
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::release_target_pos_check() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgVector* temp = _impl_.target_pos_check_;
  _impl_.target_pos_check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::unsafe_arena_release_target_pos_check() {
  // @@protoc_insertion_point(field_release:CSGOInputHistoryEntryPB.target_pos_check)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgVector* temp = _impl_.target_pos_check_;
  _impl_.target_pos_check_ = nullptr;
  return temp;
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::_internal_mutable_target_pos_check() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.target_pos_check_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.target_pos_check_ = p;
  }
  return _impl_.target_pos_check_;
}
inline ::CMsgVector* CSGOInputHistoryEntryPB::mutable_target_pos_check() {
  ::CMsgVector* _msg = _internal_mutable_target_pos_check();
  // @@protoc_insertion_point(field_mutable:CSGOInputHistoryEntryPB.target_pos_check)
  return _msg;
}
inline void CSGOInputHistoryEntryPB::set_allocated_target_pos_check(::CMsgVector* target_pos_check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_pos_check_);
  }
  if (target_pos_check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_pos_check));
    if (message_arena != submessage_arena) {
      target_pos_check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_pos_check, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.target_pos_check_ = target_pos_check;
  // @@protoc_insertion_point(field_set_allocated:CSGOInputHistoryEntryPB.target_pos_check)
}

// -------------------------------------------------------------------

// CSGOUserCmdPB

// optional .CBaseUserCmdPB base = 1;
inline bool CSGOUserCmdPB::_internal_has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline bool CSGOUserCmdPB::has_base() const {
  return _internal_has_base();
}
inline void CSGOUserCmdPB::clear_base() {
  if (_impl_.base_ != nullptr) _impl_.base_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CBaseUserCmdPB& CSGOUserCmdPB::_internal_base() const {
  const ::CBaseUserCmdPB* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::CBaseUserCmdPB&>(
      ::_CBaseUserCmdPB_default_instance_);
}
inline const ::CBaseUserCmdPB& CSGOUserCmdPB::base() const {
  // @@protoc_insertion_point(field_get:CSGOUserCmdPB.base)
  return _internal_base();
}
inline void CSGOUserCmdPB::unsafe_arena_set_allocated_base(
    ::CBaseUserCmdPB* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSGOUserCmdPB.base)
}
inline ::CBaseUserCmdPB* CSGOUserCmdPB::release_base() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CBaseUserCmdPB* CSGOUserCmdPB::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:CSGOUserCmdPB.base)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::CBaseUserCmdPB* CSGOUserCmdPB::_internal_mutable_base() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::CBaseUserCmdPB>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::CBaseUserCmdPB* CSGOUserCmdPB::mutable_base() {
  ::CBaseUserCmdPB* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:CSGOUserCmdPB.base)
  return _msg;
}
inline void CSGOUserCmdPB::set_allocated_base(::CBaseUserCmdPB* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:CSGOUserCmdPB.base)
}

// repeated .CSGOInputHistoryEntryPB input_history = 2;
inline int CSGOUserCmdPB::_internal_input_history_size() const {
  return _impl_.input_history_.size();
}
inline int CSGOUserCmdPB::input_history_size() const {
  return _internal_input_history_size();
}
inline void CSGOUserCmdPB::clear_input_history() {
  _impl_.input_history_.Clear();
}
inline ::CSGOInputHistoryEntryPB* CSGOUserCmdPB::mutable_input_history(int index) {
  // @@protoc_insertion_point(field_mutable:CSGOUserCmdPB.input_history)
  return _impl_.input_history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSGOInputHistoryEntryPB >*
CSGOUserCmdPB::mutable_input_history() {
  // @@protoc_insertion_point(field_mutable_list:CSGOUserCmdPB.input_history)
  return &_impl_.input_history_;
}
inline const ::CSGOInputHistoryEntryPB& CSGOUserCmdPB::_internal_input_history(int index) const {
  return _impl_.input_history_.Get(index);
}
inline const ::CSGOInputHistoryEntryPB& CSGOUserCmdPB::input_history(int index) const {
  // @@protoc_insertion_point(field_get:CSGOUserCmdPB.input_history)
  return _internal_input_history(index);
}
inline ::CSGOInputHistoryEntryPB* CSGOUserCmdPB::_internal_add_input_history() {
  return _impl_.input_history_.Add();
}
inline ::CSGOInputHistoryEntryPB* CSGOUserCmdPB::add_input_history() {
  ::CSGOInputHistoryEntryPB* _add = _internal_add_input_history();
  // @@protoc_insertion_point(field_add:CSGOUserCmdPB.input_history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSGOInputHistoryEntryPB >&
CSGOUserCmdPB::input_history() const {
  // @@protoc_insertion_point(field_list:CSGOUserCmdPB.input_history)
  return _impl_.input_history_;
}

// optional int32 attack1_start_history_index = 6 [default = -1];
inline bool CSGOUserCmdPB::_internal_has_attack1_start_history_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSGOUserCmdPB::has_attack1_start_history_index() const {
  return _internal_has_attack1_start_history_index();
}
inline void CSGOUserCmdPB::clear_attack1_start_history_index() {
  _impl_.attack1_start_history_index_ = -1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CSGOUserCmdPB::_internal_attack1_start_history_index() const {
  return _impl_.attack1_start_history_index_;
}
inline int32_t CSGOUserCmdPB::attack1_start_history_index() const {
  // @@protoc_insertion_point(field_get:CSGOUserCmdPB.attack1_start_history_index)
  return _internal_attack1_start_history_index();
}
inline void CSGOUserCmdPB::_internal_set_attack1_start_history_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.attack1_start_history_index_ = value;
}
inline void CSGOUserCmdPB::set_attack1_start_history_index(int32_t value) {
  _internal_set_attack1_start_history_index(value);
  // @@protoc_insertion_point(field_set:CSGOUserCmdPB.attack1_start_history_index)
}

// optional int32 attack2_start_history_index = 7 [default = -1];
inline bool CSGOUserCmdPB::_internal_has_attack2_start_history_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSGOUserCmdPB::has_attack2_start_history_index() const {
  return _internal_has_attack2_start_history_index();
}
inline void CSGOUserCmdPB::clear_attack2_start_history_index() {
  _impl_.attack2_start_history_index_ = -1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CSGOUserCmdPB::_internal_attack2_start_history_index() const {
  return _impl_.attack2_start_history_index_;
}
inline int32_t CSGOUserCmdPB::attack2_start_history_index() const {
  // @@protoc_insertion_point(field_get:CSGOUserCmdPB.attack2_start_history_index)
  return _internal_attack2_start_history_index();
}
inline void CSGOUserCmdPB::_internal_set_attack2_start_history_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.attack2_start_history_index_ = value;
}
inline void CSGOUserCmdPB::set_attack2_start_history_index(int32_t value) {
  _internal_set_attack2_start_history_index(value);
  // @@protoc_insertion_point(field_set:CSGOUserCmdPB.attack2_start_history_index)
}

// -------------------------------------------------------------------

// CMsgVRHandInfo

// optional .CMsgVector vposition = 1;
inline bool CMsgVRHandInfo::_internal_has_vposition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vposition_ != nullptr);
  return value;
}
inline bool CMsgVRHandInfo::has_vposition() const {
  return _internal_has_vposition();
}
inline const ::CMsgVector& CMsgVRHandInfo::_internal_vposition() const {
  const ::CMsgVector* p = _impl_.vposition_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CMsgVRHandInfo::vposition() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.vposition)
  return _internal_vposition();
}
inline void CMsgVRHandInfo::unsafe_arena_set_allocated_vposition(
    ::CMsgVector* vposition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vposition_);
  }
  _impl_.vposition_ = vposition;
  if (vposition) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgVRHandInfo.vposition)
}
inline ::CMsgVector* CMsgVRHandInfo::release_vposition() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgVector* temp = _impl_.vposition_;
  _impl_.vposition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::unsafe_arena_release_vposition() {
  // @@protoc_insertion_point(field_release:CMsgVRHandInfo.vposition)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgVector* temp = _impl_.vposition_;
  _impl_.vposition_ = nullptr;
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::_internal_mutable_vposition() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.vposition_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.vposition_ = p;
  }
  return _impl_.vposition_;
}
inline ::CMsgVector* CMsgVRHandInfo::mutable_vposition() {
  ::CMsgVector* _msg = _internal_mutable_vposition();
  // @@protoc_insertion_point(field_mutable:CMsgVRHandInfo.vposition)
  return _msg;
}
inline void CMsgVRHandInfo::set_allocated_vposition(::CMsgVector* vposition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vposition_);
  }
  if (vposition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vposition));
    if (message_arena != submessage_arena) {
      vposition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vposition, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vposition_ = vposition;
  // @@protoc_insertion_point(field_set_allocated:CMsgVRHandInfo.vposition)
}

// optional .CMsgQAngle angles = 2;
inline bool CMsgVRHandInfo::_internal_has_angles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.angles_ != nullptr);
  return value;
}
inline bool CMsgVRHandInfo::has_angles() const {
  return _internal_has_angles();
}
inline const ::CMsgQAngle& CMsgVRHandInfo::_internal_angles() const {
  const ::CMsgQAngle* p = _impl_.angles_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgQAngle&>(
      ::_CMsgQAngle_default_instance_);
}
inline const ::CMsgQAngle& CMsgVRHandInfo::angles() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.angles)
  return _internal_angles();
}
inline void CMsgVRHandInfo::unsafe_arena_set_allocated_angles(
    ::CMsgQAngle* angles) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angles_);
  }
  _impl_.angles_ = angles;
  if (angles) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgVRHandInfo.angles)
}
inline ::CMsgQAngle* CMsgVRHandInfo::release_angles() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgQAngle* temp = _impl_.angles_;
  _impl_.angles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgQAngle* CMsgVRHandInfo::unsafe_arena_release_angles() {
  // @@protoc_insertion_point(field_release:CMsgVRHandInfo.angles)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgQAngle* temp = _impl_.angles_;
  _impl_.angles_ = nullptr;
  return temp;
}
inline ::CMsgQAngle* CMsgVRHandInfo::_internal_mutable_angles() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.angles_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgQAngle>(GetArenaForAllocation());
    _impl_.angles_ = p;
  }
  return _impl_.angles_;
}
inline ::CMsgQAngle* CMsgVRHandInfo::mutable_angles() {
  ::CMsgQAngle* _msg = _internal_mutable_angles();
  // @@protoc_insertion_point(field_mutable:CMsgVRHandInfo.angles)
  return _msg;
}
inline void CMsgVRHandInfo::set_allocated_angles(::CMsgQAngle* angles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angles_);
  }
  if (angles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angles));
    if (message_arena != submessage_arena) {
      angles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angles, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.angles_ = angles;
  // @@protoc_insertion_point(field_set_allocated:CMsgVRHandInfo.angles)
}

// optional .CMsgVector velocity = 3;
inline bool CMsgVRHandInfo::_internal_has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline bool CMsgVRHandInfo::has_velocity() const {
  return _internal_has_velocity();
}
inline const ::CMsgVector& CMsgVRHandInfo::_internal_velocity() const {
  const ::CMsgVector* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CMsgVRHandInfo::velocity() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.velocity)
  return _internal_velocity();
}
inline void CMsgVRHandInfo::unsafe_arena_set_allocated_velocity(
    ::CMsgVector* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgVRHandInfo.velocity)
}
inline ::CMsgVector* CMsgVRHandInfo::release_velocity() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgVector* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:CMsgVRHandInfo.velocity)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgVector* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::_internal_mutable_velocity() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::CMsgVector* CMsgVRHandInfo::mutable_velocity() {
  ::CMsgVector* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:CMsgVRHandInfo.velocity)
  return _msg;
}
inline void CMsgVRHandInfo::set_allocated_velocity(::CMsgVector* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity));
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:CMsgVRHandInfo.velocity)
}

// optional .CMsgVector localposition = 4;
inline bool CMsgVRHandInfo::_internal_has_localposition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.localposition_ != nullptr);
  return value;
}
inline bool CMsgVRHandInfo::has_localposition() const {
  return _internal_has_localposition();
}
inline const ::CMsgVector& CMsgVRHandInfo::_internal_localposition() const {
  const ::CMsgVector* p = _impl_.localposition_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CMsgVRHandInfo::localposition() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.localposition)
  return _internal_localposition();
}
inline void CMsgVRHandInfo::unsafe_arena_set_allocated_localposition(
    ::CMsgVector* localposition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localposition_);
  }
  _impl_.localposition_ = localposition;
  if (localposition) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgVRHandInfo.localposition)
}
inline ::CMsgVector* CMsgVRHandInfo::release_localposition() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgVector* temp = _impl_.localposition_;
  _impl_.localposition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::unsafe_arena_release_localposition() {
  // @@protoc_insertion_point(field_release:CMsgVRHandInfo.localposition)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgVector* temp = _impl_.localposition_;
  _impl_.localposition_ = nullptr;
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::_internal_mutable_localposition() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.localposition_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.localposition_ = p;
  }
  return _impl_.localposition_;
}
inline ::CMsgVector* CMsgVRHandInfo::mutable_localposition() {
  ::CMsgVector* _msg = _internal_mutable_localposition();
  // @@protoc_insertion_point(field_mutable:CMsgVRHandInfo.localposition)
  return _msg;
}
inline void CMsgVRHandInfo::set_allocated_localposition(::CMsgVector* localposition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localposition_);
  }
  if (localposition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(localposition));
    if (message_arena != submessage_arena) {
      localposition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localposition, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.localposition_ = localposition;
  // @@protoc_insertion_point(field_set_allocated:CMsgVRHandInfo.localposition)
}

// optional .CMsgQAngle localangles = 5;
inline bool CMsgVRHandInfo::_internal_has_localangles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.localangles_ != nullptr);
  return value;
}
inline bool CMsgVRHandInfo::has_localangles() const {
  return _internal_has_localangles();
}
inline const ::CMsgQAngle& CMsgVRHandInfo::_internal_localangles() const {
  const ::CMsgQAngle* p = _impl_.localangles_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgQAngle&>(
      ::_CMsgQAngle_default_instance_);
}
inline const ::CMsgQAngle& CMsgVRHandInfo::localangles() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.localangles)
  return _internal_localangles();
}
inline void CMsgVRHandInfo::unsafe_arena_set_allocated_localangles(
    ::CMsgQAngle* localangles) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localangles_);
  }
  _impl_.localangles_ = localangles;
  if (localangles) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgVRHandInfo.localangles)
}
inline ::CMsgQAngle* CMsgVRHandInfo::release_localangles() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::CMsgQAngle* temp = _impl_.localangles_;
  _impl_.localangles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgQAngle* CMsgVRHandInfo::unsafe_arena_release_localangles() {
  // @@protoc_insertion_point(field_release:CMsgVRHandInfo.localangles)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::CMsgQAngle* temp = _impl_.localangles_;
  _impl_.localangles_ = nullptr;
  return temp;
}
inline ::CMsgQAngle* CMsgVRHandInfo::_internal_mutable_localangles() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.localangles_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgQAngle>(GetArenaForAllocation());
    _impl_.localangles_ = p;
  }
  return _impl_.localangles_;
}
inline ::CMsgQAngle* CMsgVRHandInfo::mutable_localangles() {
  ::CMsgQAngle* _msg = _internal_mutable_localangles();
  // @@protoc_insertion_point(field_mutable:CMsgVRHandInfo.localangles)
  return _msg;
}
inline void CMsgVRHandInfo::set_allocated_localangles(::CMsgQAngle* localangles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localangles_);
  }
  if (localangles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(localangles));
    if (message_arena != submessage_arena) {
      localangles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localangles, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.localangles_ = localangles;
  // @@protoc_insertion_point(field_set_allocated:CMsgVRHandInfo.localangles)
}

// optional float sampletime = 6;
inline bool CMsgVRHandInfo::_internal_has_sampletime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_sampletime() const {
  return _internal_has_sampletime();
}
inline void CMsgVRHandInfo::clear_sampletime() {
  _impl_.sampletime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float CMsgVRHandInfo::_internal_sampletime() const {
  return _impl_.sampletime_;
}
inline float CMsgVRHandInfo::sampletime() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.sampletime)
  return _internal_sampletime();
}
inline void CMsgVRHandInfo::_internal_set_sampletime(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.sampletime_ = value;
}
inline void CMsgVRHandInfo::set_sampletime(float value) {
  _internal_set_sampletime(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.sampletime)
}

// optional .CMsgVector filteredposition = 7;
inline bool CMsgVRHandInfo::_internal_has_filteredposition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filteredposition_ != nullptr);
  return value;
}
inline bool CMsgVRHandInfo::has_filteredposition() const {
  return _internal_has_filteredposition();
}
inline const ::CMsgVector& CMsgVRHandInfo::_internal_filteredposition() const {
  const ::CMsgVector* p = _impl_.filteredposition_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CMsgVRHandInfo::filteredposition() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.filteredposition)
  return _internal_filteredposition();
}
inline void CMsgVRHandInfo::unsafe_arena_set_allocated_filteredposition(
    ::CMsgVector* filteredposition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filteredposition_);
  }
  _impl_.filteredposition_ = filteredposition;
  if (filteredposition) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgVRHandInfo.filteredposition)
}
inline ::CMsgVector* CMsgVRHandInfo::release_filteredposition() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::CMsgVector* temp = _impl_.filteredposition_;
  _impl_.filteredposition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::unsafe_arena_release_filteredposition() {
  // @@protoc_insertion_point(field_release:CMsgVRHandInfo.filteredposition)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::CMsgVector* temp = _impl_.filteredposition_;
  _impl_.filteredposition_ = nullptr;
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::_internal_mutable_filteredposition() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.filteredposition_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.filteredposition_ = p;
  }
  return _impl_.filteredposition_;
}
inline ::CMsgVector* CMsgVRHandInfo::mutable_filteredposition() {
  ::CMsgVector* _msg = _internal_mutable_filteredposition();
  // @@protoc_insertion_point(field_mutable:CMsgVRHandInfo.filteredposition)
  return _msg;
}
inline void CMsgVRHandInfo::set_allocated_filteredposition(::CMsgVector* filteredposition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filteredposition_);
  }
  if (filteredposition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filteredposition));
    if (message_arena != submessage_arena) {
      filteredposition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filteredposition, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.filteredposition_ = filteredposition;
  // @@protoc_insertion_point(field_set_allocated:CMsgVRHandInfo.filteredposition)
}

// optional .CMsgQAngle filteredangles = 8;
inline bool CMsgVRHandInfo::_internal_has_filteredangles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filteredangles_ != nullptr);
  return value;
}
inline bool CMsgVRHandInfo::has_filteredangles() const {
  return _internal_has_filteredangles();
}
inline const ::CMsgQAngle& CMsgVRHandInfo::_internal_filteredangles() const {
  const ::CMsgQAngle* p = _impl_.filteredangles_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgQAngle&>(
      ::_CMsgQAngle_default_instance_);
}
inline const ::CMsgQAngle& CMsgVRHandInfo::filteredangles() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.filteredangles)
  return _internal_filteredangles();
}
inline void CMsgVRHandInfo::unsafe_arena_set_allocated_filteredangles(
    ::CMsgQAngle* filteredangles) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filteredangles_);
  }
  _impl_.filteredangles_ = filteredangles;
  if (filteredangles) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgVRHandInfo.filteredangles)
}
inline ::CMsgQAngle* CMsgVRHandInfo::release_filteredangles() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::CMsgQAngle* temp = _impl_.filteredangles_;
  _impl_.filteredangles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgQAngle* CMsgVRHandInfo::unsafe_arena_release_filteredangles() {
  // @@protoc_insertion_point(field_release:CMsgVRHandInfo.filteredangles)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::CMsgQAngle* temp = _impl_.filteredangles_;
  _impl_.filteredangles_ = nullptr;
  return temp;
}
inline ::CMsgQAngle* CMsgVRHandInfo::_internal_mutable_filteredangles() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.filteredangles_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgQAngle>(GetArenaForAllocation());
    _impl_.filteredangles_ = p;
  }
  return _impl_.filteredangles_;
}
inline ::CMsgQAngle* CMsgVRHandInfo::mutable_filteredangles() {
  ::CMsgQAngle* _msg = _internal_mutable_filteredangles();
  // @@protoc_insertion_point(field_mutable:CMsgVRHandInfo.filteredangles)
  return _msg;
}
inline void CMsgVRHandInfo::set_allocated_filteredangles(::CMsgQAngle* filteredangles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filteredangles_);
  }
  if (filteredangles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filteredangles));
    if (message_arena != submessage_arena) {
      filteredangles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filteredangles, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.filteredangles_ = filteredangles;
  // @@protoc_insertion_point(field_set_allocated:CMsgVRHandInfo.filteredangles)
}

// optional .CMsgVector filteredvelocity = 9;
inline bool CMsgVRHandInfo::_internal_has_filteredvelocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filteredvelocity_ != nullptr);
  return value;
}
inline bool CMsgVRHandInfo::has_filteredvelocity() const {
  return _internal_has_filteredvelocity();
}
inline const ::CMsgVector& CMsgVRHandInfo::_internal_filteredvelocity() const {
  const ::CMsgVector* p = _impl_.filteredvelocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CMsgVRHandInfo::filteredvelocity() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.filteredvelocity)
  return _internal_filteredvelocity();
}
inline void CMsgVRHandInfo::unsafe_arena_set_allocated_filteredvelocity(
    ::CMsgVector* filteredvelocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filteredvelocity_);
  }
  _impl_.filteredvelocity_ = filteredvelocity;
  if (filteredvelocity) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgVRHandInfo.filteredvelocity)
}
inline ::CMsgVector* CMsgVRHandInfo::release_filteredvelocity() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::CMsgVector* temp = _impl_.filteredvelocity_;
  _impl_.filteredvelocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::unsafe_arena_release_filteredvelocity() {
  // @@protoc_insertion_point(field_release:CMsgVRHandInfo.filteredvelocity)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::CMsgVector* temp = _impl_.filteredvelocity_;
  _impl_.filteredvelocity_ = nullptr;
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::_internal_mutable_filteredvelocity() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.filteredvelocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.filteredvelocity_ = p;
  }
  return _impl_.filteredvelocity_;
}
inline ::CMsgVector* CMsgVRHandInfo::mutable_filteredvelocity() {
  ::CMsgVector* _msg = _internal_mutable_filteredvelocity();
  // @@protoc_insertion_point(field_mutable:CMsgVRHandInfo.filteredvelocity)
  return _msg;
}
inline void CMsgVRHandInfo::set_allocated_filteredvelocity(::CMsgVector* filteredvelocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filteredvelocity_);
  }
  if (filteredvelocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filteredvelocity));
    if (message_arena != submessage_arena) {
      filteredvelocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filteredvelocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.filteredvelocity_ = filteredvelocity;
  // @@protoc_insertion_point(field_set_allocated:CMsgVRHandInfo.filteredvelocity)
}

// optional .CMsgVector filteredangularvel = 10;
inline bool CMsgVRHandInfo::_internal_has_filteredangularvel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filteredangularvel_ != nullptr);
  return value;
}
inline bool CMsgVRHandInfo::has_filteredangularvel() const {
  return _internal_has_filteredangularvel();
}
inline const ::CMsgVector& CMsgVRHandInfo::_internal_filteredangularvel() const {
  const ::CMsgVector* p = _impl_.filteredangularvel_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CMsgVRHandInfo::filteredangularvel() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.filteredangularvel)
  return _internal_filteredangularvel();
}
inline void CMsgVRHandInfo::unsafe_arena_set_allocated_filteredangularvel(
    ::CMsgVector* filteredangularvel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filteredangularvel_);
  }
  _impl_.filteredangularvel_ = filteredangularvel;
  if (filteredangularvel) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgVRHandInfo.filteredangularvel)
}
inline ::CMsgVector* CMsgVRHandInfo::release_filteredangularvel() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::CMsgVector* temp = _impl_.filteredangularvel_;
  _impl_.filteredangularvel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::unsafe_arena_release_filteredangularvel() {
  // @@protoc_insertion_point(field_release:CMsgVRHandInfo.filteredangularvel)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::CMsgVector* temp = _impl_.filteredangularvel_;
  _impl_.filteredangularvel_ = nullptr;
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::_internal_mutable_filteredangularvel() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.filteredangularvel_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.filteredangularvel_ = p;
  }
  return _impl_.filteredangularvel_;
}
inline ::CMsgVector* CMsgVRHandInfo::mutable_filteredangularvel() {
  ::CMsgVector* _msg = _internal_mutable_filteredangularvel();
  // @@protoc_insertion_point(field_mutable:CMsgVRHandInfo.filteredangularvel)
  return _msg;
}
inline void CMsgVRHandInfo::set_allocated_filteredangularvel(::CMsgVector* filteredangularvel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filteredangularvel_);
  }
  if (filteredangularvel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filteredangularvel));
    if (message_arena != submessage_arena) {
      filteredangularvel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filteredangularvel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.filteredangularvel_ = filteredangularvel;
  // @@protoc_insertion_point(field_set_allocated:CMsgVRHandInfo.filteredangularvel)
}

// optional .CMsgVector filteredthrowvel = 11;
inline bool CMsgVRHandInfo::_internal_has_filteredthrowvel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filteredthrowvel_ != nullptr);
  return value;
}
inline bool CMsgVRHandInfo::has_filteredthrowvel() const {
  return _internal_has_filteredthrowvel();
}
inline const ::CMsgVector& CMsgVRHandInfo::_internal_filteredthrowvel() const {
  const ::CMsgVector* p = _impl_.filteredthrowvel_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CMsgVRHandInfo::filteredthrowvel() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.filteredthrowvel)
  return _internal_filteredthrowvel();
}
inline void CMsgVRHandInfo::unsafe_arena_set_allocated_filteredthrowvel(
    ::CMsgVector* filteredthrowvel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filteredthrowvel_);
  }
  _impl_.filteredthrowvel_ = filteredthrowvel;
  if (filteredthrowvel) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgVRHandInfo.filteredthrowvel)
}
inline ::CMsgVector* CMsgVRHandInfo::release_filteredthrowvel() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::CMsgVector* temp = _impl_.filteredthrowvel_;
  _impl_.filteredthrowvel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::unsafe_arena_release_filteredthrowvel() {
  // @@protoc_insertion_point(field_release:CMsgVRHandInfo.filteredthrowvel)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::CMsgVector* temp = _impl_.filteredthrowvel_;
  _impl_.filteredthrowvel_ = nullptr;
  return temp;
}
inline ::CMsgVector* CMsgVRHandInfo::_internal_mutable_filteredthrowvel() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.filteredthrowvel_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.filteredthrowvel_ = p;
  }
  return _impl_.filteredthrowvel_;
}
inline ::CMsgVector* CMsgVRHandInfo::mutable_filteredthrowvel() {
  ::CMsgVector* _msg = _internal_mutable_filteredthrowvel();
  // @@protoc_insertion_point(field_mutable:CMsgVRHandInfo.filteredthrowvel)
  return _msg;
}
inline void CMsgVRHandInfo::set_allocated_filteredthrowvel(::CMsgVector* filteredthrowvel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filteredthrowvel_);
  }
  if (filteredthrowvel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filteredthrowvel));
    if (message_arena != submessage_arena) {
      filteredthrowvel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filteredthrowvel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.filteredthrowvel_ = filteredthrowvel;
  // @@protoc_insertion_point(field_set_allocated:CMsgVRHandInfo.filteredthrowvel)
}

// optional float triggeranalogvalue = 12;
inline bool CMsgVRHandInfo::_internal_has_triggeranalogvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_triggeranalogvalue() const {
  return _internal_has_triggeranalogvalue();
}
inline void CMsgVRHandInfo::clear_triggeranalogvalue() {
  _impl_.triggeranalogvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float CMsgVRHandInfo::_internal_triggeranalogvalue() const {
  return _impl_.triggeranalogvalue_;
}
inline float CMsgVRHandInfo::triggeranalogvalue() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.triggeranalogvalue)
  return _internal_triggeranalogvalue();
}
inline void CMsgVRHandInfo::_internal_set_triggeranalogvalue(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.triggeranalogvalue_ = value;
}
inline void CMsgVRHandInfo::set_triggeranalogvalue(float value) {
  _internal_set_triggeranalogvalue(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.triggeranalogvalue)
}

// optional float gripanalogvalue = 13;
inline bool CMsgVRHandInfo::_internal_has_gripanalogvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_gripanalogvalue() const {
  return _internal_has_gripanalogvalue();
}
inline void CMsgVRHandInfo::clear_gripanalogvalue() {
  _impl_.gripanalogvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float CMsgVRHandInfo::_internal_gripanalogvalue() const {
  return _impl_.gripanalogvalue_;
}
inline float CMsgVRHandInfo::gripanalogvalue() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.gripanalogvalue)
  return _internal_gripanalogvalue();
}
inline void CMsgVRHandInfo::_internal_set_gripanalogvalue(float value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.gripanalogvalue_ = value;
}
inline void CMsgVRHandInfo::set_gripanalogvalue(float value) {
  _internal_set_gripanalogvalue(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.gripanalogvalue)
}

// optional float finger0 = 14;
inline bool CMsgVRHandInfo::_internal_has_finger0() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_finger0() const {
  return _internal_has_finger0();
}
inline void CMsgVRHandInfo::clear_finger0() {
  _impl_.finger0_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float CMsgVRHandInfo::_internal_finger0() const {
  return _impl_.finger0_;
}
inline float CMsgVRHandInfo::finger0() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.finger0)
  return _internal_finger0();
}
inline void CMsgVRHandInfo::_internal_set_finger0(float value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.finger0_ = value;
}
inline void CMsgVRHandInfo::set_finger0(float value) {
  _internal_set_finger0(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.finger0)
}

// optional float finger1 = 15;
inline bool CMsgVRHandInfo::_internal_has_finger1() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_finger1() const {
  return _internal_has_finger1();
}
inline void CMsgVRHandInfo::clear_finger1() {
  _impl_.finger1_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float CMsgVRHandInfo::_internal_finger1() const {
  return _impl_.finger1_;
}
inline float CMsgVRHandInfo::finger1() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.finger1)
  return _internal_finger1();
}
inline void CMsgVRHandInfo::_internal_set_finger1(float value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.finger1_ = value;
}
inline void CMsgVRHandInfo::set_finger1(float value) {
  _internal_set_finger1(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.finger1)
}

// optional float finger2 = 16;
inline bool CMsgVRHandInfo::_internal_has_finger2() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_finger2() const {
  return _internal_has_finger2();
}
inline void CMsgVRHandInfo::clear_finger2() {
  _impl_.finger2_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline float CMsgVRHandInfo::_internal_finger2() const {
  return _impl_.finger2_;
}
inline float CMsgVRHandInfo::finger2() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.finger2)
  return _internal_finger2();
}
inline void CMsgVRHandInfo::_internal_set_finger2(float value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.finger2_ = value;
}
inline void CMsgVRHandInfo::set_finger2(float value) {
  _internal_set_finger2(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.finger2)
}

// optional float finger3 = 17;
inline bool CMsgVRHandInfo::_internal_has_finger3() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_finger3() const {
  return _internal_has_finger3();
}
inline void CMsgVRHandInfo::clear_finger3() {
  _impl_.finger3_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline float CMsgVRHandInfo::_internal_finger3() const {
  return _impl_.finger3_;
}
inline float CMsgVRHandInfo::finger3() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.finger3)
  return _internal_finger3();
}
inline void CMsgVRHandInfo::_internal_set_finger3(float value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.finger3_ = value;
}
inline void CMsgVRHandInfo::set_finger3(float value) {
  _internal_set_finger3(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.finger3)
}

// optional float finger4 = 18;
inline bool CMsgVRHandInfo::_internal_has_finger4() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_finger4() const {
  return _internal_has_finger4();
}
inline void CMsgVRHandInfo::clear_finger4() {
  _impl_.finger4_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline float CMsgVRHandInfo::_internal_finger4() const {
  return _impl_.finger4_;
}
inline float CMsgVRHandInfo::finger4() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.finger4)
  return _internal_finger4();
}
inline void CMsgVRHandInfo::_internal_set_finger4(float value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.finger4_ = value;
}
inline void CMsgVRHandInfo::set_finger4(float value) {
  _internal_set_finger4(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.finger4)
}

// optional float fingersplay0 = 19;
inline bool CMsgVRHandInfo::_internal_has_fingersplay0() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_fingersplay0() const {
  return _internal_has_fingersplay0();
}
inline void CMsgVRHandInfo::clear_fingersplay0() {
  _impl_.fingersplay0_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline float CMsgVRHandInfo::_internal_fingersplay0() const {
  return _impl_.fingersplay0_;
}
inline float CMsgVRHandInfo::fingersplay0() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.fingersplay0)
  return _internal_fingersplay0();
}
inline void CMsgVRHandInfo::_internal_set_fingersplay0(float value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.fingersplay0_ = value;
}
inline void CMsgVRHandInfo::set_fingersplay0(float value) {
  _internal_set_fingersplay0(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.fingersplay0)
}

// optional float fingersplay1 = 20;
inline bool CMsgVRHandInfo::_internal_has_fingersplay1() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_fingersplay1() const {
  return _internal_has_fingersplay1();
}
inline void CMsgVRHandInfo::clear_fingersplay1() {
  _impl_.fingersplay1_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline float CMsgVRHandInfo::_internal_fingersplay1() const {
  return _impl_.fingersplay1_;
}
inline float CMsgVRHandInfo::fingersplay1() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.fingersplay1)
  return _internal_fingersplay1();
}
inline void CMsgVRHandInfo::_internal_set_fingersplay1(float value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.fingersplay1_ = value;
}
inline void CMsgVRHandInfo::set_fingersplay1(float value) {
  _internal_set_fingersplay1(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.fingersplay1)
}

// optional float fingersplay2 = 21;
inline bool CMsgVRHandInfo::_internal_has_fingersplay2() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_fingersplay2() const {
  return _internal_has_fingersplay2();
}
inline void CMsgVRHandInfo::clear_fingersplay2() {
  _impl_.fingersplay2_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline float CMsgVRHandInfo::_internal_fingersplay2() const {
  return _impl_.fingersplay2_;
}
inline float CMsgVRHandInfo::fingersplay2() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.fingersplay2)
  return _internal_fingersplay2();
}
inline void CMsgVRHandInfo::_internal_set_fingersplay2(float value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.fingersplay2_ = value;
}
inline void CMsgVRHandInfo::set_fingersplay2(float value) {
  _internal_set_fingersplay2(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.fingersplay2)
}

// optional float fingersplay3 = 22;
inline bool CMsgVRHandInfo::_internal_has_fingersplay3() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_fingersplay3() const {
  return _internal_has_fingersplay3();
}
inline void CMsgVRHandInfo::clear_fingersplay3() {
  _impl_.fingersplay3_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline float CMsgVRHandInfo::_internal_fingersplay3() const {
  return _impl_.fingersplay3_;
}
inline float CMsgVRHandInfo::fingersplay3() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.fingersplay3)
  return _internal_fingersplay3();
}
inline void CMsgVRHandInfo::_internal_set_fingersplay3(float value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.fingersplay3_ = value;
}
inline void CMsgVRHandInfo::set_fingersplay3(float value) {
  _internal_set_fingersplay3(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.fingersplay3)
}

// optional float trackpadanalogvaluex = 23;
inline bool CMsgVRHandInfo::_internal_has_trackpadanalogvaluex() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_trackpadanalogvaluex() const {
  return _internal_has_trackpadanalogvaluex();
}
inline void CMsgVRHandInfo::clear_trackpadanalogvaluex() {
  _impl_.trackpadanalogvaluex_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline float CMsgVRHandInfo::_internal_trackpadanalogvaluex() const {
  return _impl_.trackpadanalogvaluex_;
}
inline float CMsgVRHandInfo::trackpadanalogvaluex() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.trackpadanalogvaluex)
  return _internal_trackpadanalogvaluex();
}
inline void CMsgVRHandInfo::_internal_set_trackpadanalogvaluex(float value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.trackpadanalogvaluex_ = value;
}
inline void CMsgVRHandInfo::set_trackpadanalogvaluex(float value) {
  _internal_set_trackpadanalogvaluex(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.trackpadanalogvaluex)
}

// optional float trackpadanalogvaluey = 24;
inline bool CMsgVRHandInfo::_internal_has_trackpadanalogvaluey() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_trackpadanalogvaluey() const {
  return _internal_has_trackpadanalogvaluey();
}
inline void CMsgVRHandInfo::clear_trackpadanalogvaluey() {
  _impl_.trackpadanalogvaluey_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline float CMsgVRHandInfo::_internal_trackpadanalogvaluey() const {
  return _impl_.trackpadanalogvaluey_;
}
inline float CMsgVRHandInfo::trackpadanalogvaluey() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.trackpadanalogvaluey)
  return _internal_trackpadanalogvaluey();
}
inline void CMsgVRHandInfo::_internal_set_trackpadanalogvaluey(float value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.trackpadanalogvaluey_ = value;
}
inline void CMsgVRHandInfo::set_trackpadanalogvaluey(float value) {
  _internal_set_trackpadanalogvaluey(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.trackpadanalogvaluey)
}

// optional float joystickanalogvaluex = 25;
inline bool CMsgVRHandInfo::_internal_has_joystickanalogvaluex() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_joystickanalogvaluex() const {
  return _internal_has_joystickanalogvaluex();
}
inline void CMsgVRHandInfo::clear_joystickanalogvaluex() {
  _impl_.joystickanalogvaluex_ = 0;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline float CMsgVRHandInfo::_internal_joystickanalogvaluex() const {
  return _impl_.joystickanalogvaluex_;
}
inline float CMsgVRHandInfo::joystickanalogvaluex() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.joystickanalogvaluex)
  return _internal_joystickanalogvaluex();
}
inline void CMsgVRHandInfo::_internal_set_joystickanalogvaluex(float value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.joystickanalogvaluex_ = value;
}
inline void CMsgVRHandInfo::set_joystickanalogvaluex(float value) {
  _internal_set_joystickanalogvaluex(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.joystickanalogvaluex)
}

// optional float joystickanalogvaluey = 26;
inline bool CMsgVRHandInfo::_internal_has_joystickanalogvaluey() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool CMsgVRHandInfo::has_joystickanalogvaluey() const {
  return _internal_has_joystickanalogvaluey();
}
inline void CMsgVRHandInfo::clear_joystickanalogvaluey() {
  _impl_.joystickanalogvaluey_ = 0;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline float CMsgVRHandInfo::_internal_joystickanalogvaluey() const {
  return _impl_.joystickanalogvaluey_;
}
inline float CMsgVRHandInfo::joystickanalogvaluey() const {
  // @@protoc_insertion_point(field_get:CMsgVRHandInfo.joystickanalogvaluey)
  return _internal_joystickanalogvaluey();
}
inline void CMsgVRHandInfo::_internal_set_joystickanalogvaluey(float value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.joystickanalogvaluey_ = value;
}
inline void CMsgVRHandInfo::set_joystickanalogvaluey(float value) {
  _internal_set_joystickanalogvaluey(value);
  // @@protoc_insertion_point(field_set:CMsgVRHandInfo.joystickanalogvaluey)
}

// -------------------------------------------------------------------

// CMsgVRController

// optional bool active = 1;
inline bool CMsgVRController::_internal_has_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgVRController::has_active() const {
  return _internal_has_active();
}
inline void CMsgVRController::clear_active() {
  _impl_.active_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CMsgVRController::_internal_active() const {
  return _impl_.active_;
}
inline bool CMsgVRController::active() const {
  // @@protoc_insertion_point(field_get:CMsgVRController.active)
  return _internal_active();
}
inline void CMsgVRController::_internal_set_active(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.active_ = value;
}
inline void CMsgVRController::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:CMsgVRController.active)
}

// optional bool supports_skeleton = 2;
inline bool CMsgVRController::_internal_has_supports_skeleton() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgVRController::has_supports_skeleton() const {
  return _internal_has_supports_skeleton();
}
inline void CMsgVRController::clear_supports_skeleton() {
  _impl_.supports_skeleton_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CMsgVRController::_internal_supports_skeleton() const {
  return _impl_.supports_skeleton_;
}
inline bool CMsgVRController::supports_skeleton() const {
  // @@protoc_insertion_point(field_get:CMsgVRController.supports_skeleton)
  return _internal_supports_skeleton();
}
inline void CMsgVRController::_internal_set_supports_skeleton(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.supports_skeleton_ = value;
}
inline void CMsgVRController::set_supports_skeleton(bool value) {
  _internal_set_supports_skeleton(value);
  // @@protoc_insertion_point(field_set:CMsgVRController.supports_skeleton)
}

// optional .CMsgVRHandInfo info = 3;
inline bool CMsgVRController::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool CMsgVRController::has_info() const {
  return _internal_has_info();
}
inline void CMsgVRController::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgVRHandInfo& CMsgVRController::_internal_info() const {
  const ::CMsgVRHandInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVRHandInfo&>(
      ::_CMsgVRHandInfo_default_instance_);
}
inline const ::CMsgVRHandInfo& CMsgVRController::info() const {
  // @@protoc_insertion_point(field_get:CMsgVRController.info)
  return _internal_info();
}
inline void CMsgVRController::unsafe_arena_set_allocated_info(
    ::CMsgVRHandInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgVRController.info)
}
inline ::CMsgVRHandInfo* CMsgVRController::release_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgVRHandInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVRHandInfo* CMsgVRController::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:CMsgVRController.info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgVRHandInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::CMsgVRHandInfo* CMsgVRController::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVRHandInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::CMsgVRHandInfo* CMsgVRController::mutable_info() {
  ::CMsgVRHandInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:CMsgVRController.info)
  return _msg;
}
inline void CMsgVRController::set_allocated_info(::CMsgVRHandInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:CMsgVRController.info)
}

// -------------------------------------------------------------------

// CUserMsgVRCore

// optional bool active = 1;
inline bool CUserMsgVRCore::_internal_has_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CUserMsgVRCore::has_active() const {
  return _internal_has_active();
}
inline void CUserMsgVRCore::clear_active() {
  _impl_.active_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CUserMsgVRCore::_internal_active() const {
  return _impl_.active_;
}
inline bool CUserMsgVRCore::active() const {
  // @@protoc_insertion_point(field_get:CUserMsgVRCore.active)
  return _internal_active();
}
inline void CUserMsgVRCore::_internal_set_active(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.active_ = value;
}
inline void CUserMsgVRCore::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:CUserMsgVRCore.active)
}

// optional bool targeting_mode = 2;
inline bool CUserMsgVRCore::_internal_has_targeting_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CUserMsgVRCore::has_targeting_mode() const {
  return _internal_has_targeting_mode();
}
inline void CUserMsgVRCore::clear_targeting_mode() {
  _impl_.targeting_mode_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool CUserMsgVRCore::_internal_targeting_mode() const {
  return _impl_.targeting_mode_;
}
inline bool CUserMsgVRCore::targeting_mode() const {
  // @@protoc_insertion_point(field_get:CUserMsgVRCore.targeting_mode)
  return _internal_targeting_mode();
}
inline void CUserMsgVRCore::_internal_set_targeting_mode(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.targeting_mode_ = value;
}
inline void CUserMsgVRCore::set_targeting_mode(bool value) {
  _internal_set_targeting_mode(value);
  // @@protoc_insertion_point(field_set:CUserMsgVRCore.targeting_mode)
}

// optional uint32 controller_type = 3;
inline bool CUserMsgVRCore::_internal_has_controller_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CUserMsgVRCore::has_controller_type() const {
  return _internal_has_controller_type();
}
inline void CUserMsgVRCore::clear_controller_type() {
  _impl_.controller_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CUserMsgVRCore::_internal_controller_type() const {
  return _impl_.controller_type_;
}
inline uint32_t CUserMsgVRCore::controller_type() const {
  // @@protoc_insertion_point(field_get:CUserMsgVRCore.controller_type)
  return _internal_controller_type();
}
inline void CUserMsgVRCore::_internal_set_controller_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.controller_type_ = value;
}
inline void CUserMsgVRCore::set_controller_type(uint32_t value) {
  _internal_set_controller_type(value);
  // @@protoc_insertion_point(field_set:CUserMsgVRCore.controller_type)
}

// optional .CMsgVector middle_eye_local = 4;
inline bool CUserMsgVRCore::_internal_has_middle_eye_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.middle_eye_local_ != nullptr);
  return value;
}
inline bool CUserMsgVRCore::has_middle_eye_local() const {
  return _internal_has_middle_eye_local();
}
inline const ::CMsgVector& CUserMsgVRCore::_internal_middle_eye_local() const {
  const ::CMsgVector* p = _impl_.middle_eye_local_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& CUserMsgVRCore::middle_eye_local() const {
  // @@protoc_insertion_point(field_get:CUserMsgVRCore.middle_eye_local)
  return _internal_middle_eye_local();
}
inline void CUserMsgVRCore::unsafe_arena_set_allocated_middle_eye_local(
    ::CMsgVector* middle_eye_local) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.middle_eye_local_);
  }
  _impl_.middle_eye_local_ = middle_eye_local;
  if (middle_eye_local) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CUserMsgVRCore.middle_eye_local)
}
inline ::CMsgVector* CUserMsgVRCore::release_middle_eye_local() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgVector* temp = _impl_.middle_eye_local_;
  _impl_.middle_eye_local_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* CUserMsgVRCore::unsafe_arena_release_middle_eye_local() {
  // @@protoc_insertion_point(field_release:CUserMsgVRCore.middle_eye_local)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgVector* temp = _impl_.middle_eye_local_;
  _impl_.middle_eye_local_ = nullptr;
  return temp;
}
inline ::CMsgVector* CUserMsgVRCore::_internal_mutable_middle_eye_local() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.middle_eye_local_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.middle_eye_local_ = p;
  }
  return _impl_.middle_eye_local_;
}
inline ::CMsgVector* CUserMsgVRCore::mutable_middle_eye_local() {
  ::CMsgVector* _msg = _internal_mutable_middle_eye_local();
  // @@protoc_insertion_point(field_mutable:CUserMsgVRCore.middle_eye_local)
  return _msg;
}
inline void CUserMsgVRCore::set_allocated_middle_eye_local(::CMsgVector* middle_eye_local) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.middle_eye_local_);
  }
  if (middle_eye_local) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(middle_eye_local));
    if (message_arena != submessage_arena) {
      middle_eye_local = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, middle_eye_local, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.middle_eye_local_ = middle_eye_local;
  // @@protoc_insertion_point(field_set_allocated:CUserMsgVRCore.middle_eye_local)
}

// optional .CMsgQAngle viewangles_local = 5;
inline bool CUserMsgVRCore::_internal_has_viewangles_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.viewangles_local_ != nullptr);
  return value;
}
inline bool CUserMsgVRCore::has_viewangles_local() const {
  return _internal_has_viewangles_local();
}
inline const ::CMsgQAngle& CUserMsgVRCore::_internal_viewangles_local() const {
  const ::CMsgQAngle* p = _impl_.viewangles_local_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgQAngle&>(
      ::_CMsgQAngle_default_instance_);
}
inline const ::CMsgQAngle& CUserMsgVRCore::viewangles_local() const {
  // @@protoc_insertion_point(field_get:CUserMsgVRCore.viewangles_local)
  return _internal_viewangles_local();
}
inline void CUserMsgVRCore::unsafe_arena_set_allocated_viewangles_local(
    ::CMsgQAngle* viewangles_local) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.viewangles_local_);
  }
  _impl_.viewangles_local_ = viewangles_local;
  if (viewangles_local) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CUserMsgVRCore.viewangles_local)
}
inline ::CMsgQAngle* CUserMsgVRCore::release_viewangles_local() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgQAngle* temp = _impl_.viewangles_local_;
  _impl_.viewangles_local_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgQAngle* CUserMsgVRCore::unsafe_arena_release_viewangles_local() {
  // @@protoc_insertion_point(field_release:CUserMsgVRCore.viewangles_local)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgQAngle* temp = _impl_.viewangles_local_;
  _impl_.viewangles_local_ = nullptr;
  return temp;
}
inline ::CMsgQAngle* CUserMsgVRCore::_internal_mutable_viewangles_local() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.viewangles_local_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgQAngle>(GetArenaForAllocation());
    _impl_.viewangles_local_ = p;
  }
  return _impl_.viewangles_local_;
}
inline ::CMsgQAngle* CUserMsgVRCore::mutable_viewangles_local() {
  ::CMsgQAngle* _msg = _internal_mutable_viewangles_local();
  // @@protoc_insertion_point(field_mutable:CUserMsgVRCore.viewangles_local)
  return _msg;
}
inline void CUserMsgVRCore::set_allocated_viewangles_local(::CMsgQAngle* viewangles_local) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.viewangles_local_);
  }
  if (viewangles_local) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(viewangles_local));
    if (message_arena != submessage_arena) {
      viewangles_local = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, viewangles_local, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.viewangles_local_ = viewangles_local;
  // @@protoc_insertion_point(field_set_allocated:CUserMsgVRCore.viewangles_local)
}

// repeated .CMsgVRController hmd_controllers = 6;
inline int CUserMsgVRCore::_internal_hmd_controllers_size() const {
  return _impl_.hmd_controllers_.size();
}
inline int CUserMsgVRCore::hmd_controllers_size() const {
  return _internal_hmd_controllers_size();
}
inline void CUserMsgVRCore::clear_hmd_controllers() {
  _impl_.hmd_controllers_.Clear();
}
inline ::CMsgVRController* CUserMsgVRCore::mutable_hmd_controllers(int index) {
  // @@protoc_insertion_point(field_mutable:CUserMsgVRCore.hmd_controllers)
  return _impl_.hmd_controllers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgVRController >*
CUserMsgVRCore::mutable_hmd_controllers() {
  // @@protoc_insertion_point(field_mutable_list:CUserMsgVRCore.hmd_controllers)
  return &_impl_.hmd_controllers_;
}
inline const ::CMsgVRController& CUserMsgVRCore::_internal_hmd_controllers(int index) const {
  return _impl_.hmd_controllers_.Get(index);
}
inline const ::CMsgVRController& CUserMsgVRCore::hmd_controllers(int index) const {
  // @@protoc_insertion_point(field_get:CUserMsgVRCore.hmd_controllers)
  return _internal_hmd_controllers(index);
}
inline ::CMsgVRController* CUserMsgVRCore::_internal_add_hmd_controllers() {
  return _impl_.hmd_controllers_.Add();
}
inline ::CMsgVRController* CUserMsgVRCore::add_hmd_controllers() {
  ::CMsgVRController* _add = _internal_add_hmd_controllers();
  // @@protoc_insertion_point(field_add:CUserMsgVRCore.hmd_controllers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgVRController >&
CUserMsgVRCore::hmd_controllers() const {
  // @@protoc_insertion_point(field_list:CUserMsgVRCore.hmd_controllers)
  return _impl_.hmd_controllers_;
}

// -------------------------------------------------------------------

// VrInputDigitalActionData

// optional uint64 activeorigin = 1;
inline bool VrInputDigitalActionData::_internal_has_activeorigin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VrInputDigitalActionData::has_activeorigin() const {
  return _internal_has_activeorigin();
}
inline void VrInputDigitalActionData::clear_activeorigin() {
  _impl_.activeorigin_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t VrInputDigitalActionData::_internal_activeorigin() const {
  return _impl_.activeorigin_;
}
inline uint64_t VrInputDigitalActionData::activeorigin() const {
  // @@protoc_insertion_point(field_get:VrInputDigitalActionData.activeorigin)
  return _internal_activeorigin();
}
inline void VrInputDigitalActionData::_internal_set_activeorigin(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.activeorigin_ = value;
}
inline void VrInputDigitalActionData::set_activeorigin(uint64_t value) {
  _internal_set_activeorigin(value);
  // @@protoc_insertion_point(field_set:VrInputDigitalActionData.activeorigin)
}

// optional bool active = 2;
inline bool VrInputDigitalActionData::_internal_has_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VrInputDigitalActionData::has_active() const {
  return _internal_has_active();
}
inline void VrInputDigitalActionData::clear_active() {
  _impl_.active_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool VrInputDigitalActionData::_internal_active() const {
  return _impl_.active_;
}
inline bool VrInputDigitalActionData::active() const {
  // @@protoc_insertion_point(field_get:VrInputDigitalActionData.active)
  return _internal_active();
}
inline void VrInputDigitalActionData::_internal_set_active(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.active_ = value;
}
inline void VrInputDigitalActionData::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:VrInputDigitalActionData.active)
}

// optional bool state = 3;
inline bool VrInputDigitalActionData::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VrInputDigitalActionData::has_state() const {
  return _internal_has_state();
}
inline void VrInputDigitalActionData::clear_state() {
  _impl_.state_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool VrInputDigitalActionData::_internal_state() const {
  return _impl_.state_;
}
inline bool VrInputDigitalActionData::state() const {
  // @@protoc_insertion_point(field_get:VrInputDigitalActionData.state)
  return _internal_state();
}
inline void VrInputDigitalActionData::_internal_set_state(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.state_ = value;
}
inline void VrInputDigitalActionData::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:VrInputDigitalActionData.state)
}

// optional bool changed = 4;
inline bool VrInputDigitalActionData::_internal_has_changed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VrInputDigitalActionData::has_changed() const {
  return _internal_has_changed();
}
inline void VrInputDigitalActionData::clear_changed() {
  _impl_.changed_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool VrInputDigitalActionData::_internal_changed() const {
  return _impl_.changed_;
}
inline bool VrInputDigitalActionData::changed() const {
  // @@protoc_insertion_point(field_get:VrInputDigitalActionData.changed)
  return _internal_changed();
}
inline void VrInputDigitalActionData::_internal_set_changed(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.changed_ = value;
}
inline void VrInputDigitalActionData::set_changed(bool value) {
  _internal_set_changed(value);
  // @@protoc_insertion_point(field_set:VrInputDigitalActionData.changed)
}

// optional float updatetime = 5;
inline bool VrInputDigitalActionData::_internal_has_updatetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VrInputDigitalActionData::has_updatetime() const {
  return _internal_has_updatetime();
}
inline void VrInputDigitalActionData::clear_updatetime() {
  _impl_.updatetime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float VrInputDigitalActionData::_internal_updatetime() const {
  return _impl_.updatetime_;
}
inline float VrInputDigitalActionData::updatetime() const {
  // @@protoc_insertion_point(field_get:VrInputDigitalActionData.updatetime)
  return _internal_updatetime();
}
inline void VrInputDigitalActionData::_internal_set_updatetime(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.updatetime_ = value;
}
inline void VrInputDigitalActionData::set_updatetime(float value) {
  _internal_set_updatetime(value);
  // @@protoc_insertion_point(field_set:VrInputDigitalActionData.updatetime)
}

// -------------------------------------------------------------------

// VrInputAnalogActionData

// optional uint64 activeorigin = 1;
inline bool VrInputAnalogActionData::_internal_has_activeorigin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VrInputAnalogActionData::has_activeorigin() const {
  return _internal_has_activeorigin();
}
inline void VrInputAnalogActionData::clear_activeorigin() {
  _impl_.activeorigin_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t VrInputAnalogActionData::_internal_activeorigin() const {
  return _impl_.activeorigin_;
}
inline uint64_t VrInputAnalogActionData::activeorigin() const {
  // @@protoc_insertion_point(field_get:VrInputAnalogActionData.activeorigin)
  return _internal_activeorigin();
}
inline void VrInputAnalogActionData::_internal_set_activeorigin(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.activeorigin_ = value;
}
inline void VrInputAnalogActionData::set_activeorigin(uint64_t value) {
  _internal_set_activeorigin(value);
  // @@protoc_insertion_point(field_set:VrInputAnalogActionData.activeorigin)
}

// optional .CMsgVector position = 2;
inline bool VrInputAnalogActionData::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool VrInputAnalogActionData::has_position() const {
  return _internal_has_position();
}
inline const ::CMsgVector& VrInputAnalogActionData::_internal_position() const {
  const ::CMsgVector* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& VrInputAnalogActionData::position() const {
  // @@protoc_insertion_point(field_get:VrInputAnalogActionData.position)
  return _internal_position();
}
inline void VrInputAnalogActionData::unsafe_arena_set_allocated_position(
    ::CMsgVector* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VrInputAnalogActionData.position)
}
inline ::CMsgVector* VrInputAnalogActionData::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgVector* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* VrInputAnalogActionData::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:VrInputAnalogActionData.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgVector* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::CMsgVector* VrInputAnalogActionData::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::CMsgVector* VrInputAnalogActionData::mutable_position() {
  ::CMsgVector* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:VrInputAnalogActionData.position)
  return _msg;
}
inline void VrInputAnalogActionData::set_allocated_position(::CMsgVector* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:VrInputAnalogActionData.position)
}

// optional .CMsgVector delta = 3;
inline bool VrInputAnalogActionData::_internal_has_delta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.delta_ != nullptr);
  return value;
}
inline bool VrInputAnalogActionData::has_delta() const {
  return _internal_has_delta();
}
inline const ::CMsgVector& VrInputAnalogActionData::_internal_delta() const {
  const ::CMsgVector* p = _impl_.delta_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& VrInputAnalogActionData::delta() const {
  // @@protoc_insertion_point(field_get:VrInputAnalogActionData.delta)
  return _internal_delta();
}
inline void VrInputAnalogActionData::unsafe_arena_set_allocated_delta(
    ::CMsgVector* delta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delta_);
  }
  _impl_.delta_ = delta;
  if (delta) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VrInputAnalogActionData.delta)
}
inline ::CMsgVector* VrInputAnalogActionData::release_delta() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgVector* temp = _impl_.delta_;
  _impl_.delta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* VrInputAnalogActionData::unsafe_arena_release_delta() {
  // @@protoc_insertion_point(field_release:VrInputAnalogActionData.delta)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgVector* temp = _impl_.delta_;
  _impl_.delta_ = nullptr;
  return temp;
}
inline ::CMsgVector* VrInputAnalogActionData::_internal_mutable_delta() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.delta_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.delta_ = p;
  }
  return _impl_.delta_;
}
inline ::CMsgVector* VrInputAnalogActionData::mutable_delta() {
  ::CMsgVector* _msg = _internal_mutable_delta();
  // @@protoc_insertion_point(field_mutable:VrInputAnalogActionData.delta)
  return _msg;
}
inline void VrInputAnalogActionData::set_allocated_delta(::CMsgVector* delta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delta_);
  }
  if (delta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delta));
    if (message_arena != submessage_arena) {
      delta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.delta_ = delta;
  // @@protoc_insertion_point(field_set_allocated:VrInputAnalogActionData.delta)
}

// optional bool active = 4;
inline bool VrInputAnalogActionData::_internal_has_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VrInputAnalogActionData::has_active() const {
  return _internal_has_active();
}
inline void VrInputAnalogActionData::clear_active() {
  _impl_.active_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool VrInputAnalogActionData::_internal_active() const {
  return _impl_.active_;
}
inline bool VrInputAnalogActionData::active() const {
  // @@protoc_insertion_point(field_get:VrInputAnalogActionData.active)
  return _internal_active();
}
inline void VrInputAnalogActionData::_internal_set_active(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.active_ = value;
}
inline void VrInputAnalogActionData::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:VrInputAnalogActionData.active)
}

// optional float updatetime = 5;
inline bool VrInputAnalogActionData::_internal_has_updatetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VrInputAnalogActionData::has_updatetime() const {
  return _internal_has_updatetime();
}
inline void VrInputAnalogActionData::clear_updatetime() {
  _impl_.updatetime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float VrInputAnalogActionData::_internal_updatetime() const {
  return _impl_.updatetime_;
}
inline float VrInputAnalogActionData::updatetime() const {
  // @@protoc_insertion_point(field_get:VrInputAnalogActionData.updatetime)
  return _internal_updatetime();
}
inline void VrInputAnalogActionData::_internal_set_updatetime(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.updatetime_ = value;
}
inline void VrInputAnalogActionData::set_updatetime(float value) {
  _internal_set_updatetime(value);
  // @@protoc_insertion_point(field_set:VrInputAnalogActionData.updatetime)
}

// -------------------------------------------------------------------

// VrInputSkeletalActionData

// optional bool active = 1;
inline bool VrInputSkeletalActionData::_internal_has_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VrInputSkeletalActionData::has_active() const {
  return _internal_has_active();
}
inline void VrInputSkeletalActionData::clear_active() {
  _impl_.active_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool VrInputSkeletalActionData::_internal_active() const {
  return _impl_.active_;
}
inline bool VrInputSkeletalActionData::active() const {
  // @@protoc_insertion_point(field_get:VrInputSkeletalActionData.active)
  return _internal_active();
}
inline void VrInputSkeletalActionData::_internal_set_active(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.active_ = value;
}
inline void VrInputSkeletalActionData::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:VrInputSkeletalActionData.active)
}

// optional uint64 activeorigin = 2;
inline bool VrInputSkeletalActionData::_internal_has_activeorigin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VrInputSkeletalActionData::has_activeorigin() const {
  return _internal_has_activeorigin();
}
inline void VrInputSkeletalActionData::clear_activeorigin() {
  _impl_.activeorigin_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t VrInputSkeletalActionData::_internal_activeorigin() const {
  return _impl_.activeorigin_;
}
inline uint64_t VrInputSkeletalActionData::activeorigin() const {
  // @@protoc_insertion_point(field_get:VrInputSkeletalActionData.activeorigin)
  return _internal_activeorigin();
}
inline void VrInputSkeletalActionData::_internal_set_activeorigin(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.activeorigin_ = value;
}
inline void VrInputSkeletalActionData::set_activeorigin(uint64_t value) {
  _internal_set_activeorigin(value);
  // @@protoc_insertion_point(field_set:VrInputSkeletalActionData.activeorigin)
}

// -------------------------------------------------------------------

// VrSkeletalSummaryData

// repeated float fingercurl = 1;
inline int VrSkeletalSummaryData::_internal_fingercurl_size() const {
  return _impl_.fingercurl_.size();
}
inline int VrSkeletalSummaryData::fingercurl_size() const {
  return _internal_fingercurl_size();
}
inline void VrSkeletalSummaryData::clear_fingercurl() {
  _impl_.fingercurl_.Clear();
}
inline float VrSkeletalSummaryData::_internal_fingercurl(int index) const {
  return _impl_.fingercurl_.Get(index);
}
inline float VrSkeletalSummaryData::fingercurl(int index) const {
  // @@protoc_insertion_point(field_get:VrSkeletalSummaryData.fingercurl)
  return _internal_fingercurl(index);
}
inline void VrSkeletalSummaryData::set_fingercurl(int index, float value) {
  _impl_.fingercurl_.Set(index, value);
  // @@protoc_insertion_point(field_set:VrSkeletalSummaryData.fingercurl)
}
inline void VrSkeletalSummaryData::_internal_add_fingercurl(float value) {
  _impl_.fingercurl_.Add(value);
}
inline void VrSkeletalSummaryData::add_fingercurl(float value) {
  _internal_add_fingercurl(value);
  // @@protoc_insertion_point(field_add:VrSkeletalSummaryData.fingercurl)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VrSkeletalSummaryData::_internal_fingercurl() const {
  return _impl_.fingercurl_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VrSkeletalSummaryData::fingercurl() const {
  // @@protoc_insertion_point(field_list:VrSkeletalSummaryData.fingercurl)
  return _internal_fingercurl();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VrSkeletalSummaryData::_internal_mutable_fingercurl() {
  return &_impl_.fingercurl_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VrSkeletalSummaryData::mutable_fingercurl() {
  // @@protoc_insertion_point(field_mutable_list:VrSkeletalSummaryData.fingercurl)
  return _internal_mutable_fingercurl();
}

// repeated float fingersplay = 2;
inline int VrSkeletalSummaryData::_internal_fingersplay_size() const {
  return _impl_.fingersplay_.size();
}
inline int VrSkeletalSummaryData::fingersplay_size() const {
  return _internal_fingersplay_size();
}
inline void VrSkeletalSummaryData::clear_fingersplay() {
  _impl_.fingersplay_.Clear();
}
inline float VrSkeletalSummaryData::_internal_fingersplay(int index) const {
  return _impl_.fingersplay_.Get(index);
}
inline float VrSkeletalSummaryData::fingersplay(int index) const {
  // @@protoc_insertion_point(field_get:VrSkeletalSummaryData.fingersplay)
  return _internal_fingersplay(index);
}
inline void VrSkeletalSummaryData::set_fingersplay(int index, float value) {
  _impl_.fingersplay_.Set(index, value);
  // @@protoc_insertion_point(field_set:VrSkeletalSummaryData.fingersplay)
}
inline void VrSkeletalSummaryData::_internal_add_fingersplay(float value) {
  _impl_.fingersplay_.Add(value);
}
inline void VrSkeletalSummaryData::add_fingersplay(float value) {
  _internal_add_fingersplay(value);
  // @@protoc_insertion_point(field_add:VrSkeletalSummaryData.fingersplay)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VrSkeletalSummaryData::_internal_fingersplay() const {
  return _impl_.fingersplay_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VrSkeletalSummaryData::fingersplay() const {
  // @@protoc_insertion_point(field_list:VrSkeletalSummaryData.fingersplay)
  return _internal_fingersplay();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VrSkeletalSummaryData::_internal_mutable_fingersplay() {
  return &_impl_.fingersplay_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VrSkeletalSummaryData::mutable_fingersplay() {
  // @@protoc_insertion_point(field_mutable_list:VrSkeletalSummaryData.fingersplay)
  return _internal_mutable_fingersplay();
}

// -------------------------------------------------------------------

// VrSkeletalData

// optional .VrInputSkeletalActionData skeletal_action_data = 1;
inline bool VrSkeletalData::_internal_has_skeletal_action_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.skeletal_action_data_ != nullptr);
  return value;
}
inline bool VrSkeletalData::has_skeletal_action_data() const {
  return _internal_has_skeletal_action_data();
}
inline void VrSkeletalData::clear_skeletal_action_data() {
  if (_impl_.skeletal_action_data_ != nullptr) _impl_.skeletal_action_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::VrInputSkeletalActionData& VrSkeletalData::_internal_skeletal_action_data() const {
  const ::VrInputSkeletalActionData* p = _impl_.skeletal_action_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::VrInputSkeletalActionData&>(
      ::_VrInputSkeletalActionData_default_instance_);
}
inline const ::VrInputSkeletalActionData& VrSkeletalData::skeletal_action_data() const {
  // @@protoc_insertion_point(field_get:VrSkeletalData.skeletal_action_data)
  return _internal_skeletal_action_data();
}
inline void VrSkeletalData::unsafe_arena_set_allocated_skeletal_action_data(
    ::VrInputSkeletalActionData* skeletal_action_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.skeletal_action_data_);
  }
  _impl_.skeletal_action_data_ = skeletal_action_data;
  if (skeletal_action_data) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VrSkeletalData.skeletal_action_data)
}
inline ::VrInputSkeletalActionData* VrSkeletalData::release_skeletal_action_data() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::VrInputSkeletalActionData* temp = _impl_.skeletal_action_data_;
  _impl_.skeletal_action_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VrInputSkeletalActionData* VrSkeletalData::unsafe_arena_release_skeletal_action_data() {
  // @@protoc_insertion_point(field_release:VrSkeletalData.skeletal_action_data)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::VrInputSkeletalActionData* temp = _impl_.skeletal_action_data_;
  _impl_.skeletal_action_data_ = nullptr;
  return temp;
}
inline ::VrInputSkeletalActionData* VrSkeletalData::_internal_mutable_skeletal_action_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.skeletal_action_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::VrInputSkeletalActionData>(GetArenaForAllocation());
    _impl_.skeletal_action_data_ = p;
  }
  return _impl_.skeletal_action_data_;
}
inline ::VrInputSkeletalActionData* VrSkeletalData::mutable_skeletal_action_data() {
  ::VrInputSkeletalActionData* _msg = _internal_mutable_skeletal_action_data();
  // @@protoc_insertion_point(field_mutable:VrSkeletalData.skeletal_action_data)
  return _msg;
}
inline void VrSkeletalData::set_allocated_skeletal_action_data(::VrInputSkeletalActionData* skeletal_action_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.skeletal_action_data_;
  }
  if (skeletal_action_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(skeletal_action_data);
    if (message_arena != submessage_arena) {
      skeletal_action_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, skeletal_action_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.skeletal_action_data_ = skeletal_action_data;
  // @@protoc_insertion_point(field_set_allocated:VrSkeletalData.skeletal_action_data)
}

// optional .VrSkeletalSummaryData skeletal_summary_data = 2;
inline bool VrSkeletalData::_internal_has_skeletal_summary_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.skeletal_summary_data_ != nullptr);
  return value;
}
inline bool VrSkeletalData::has_skeletal_summary_data() const {
  return _internal_has_skeletal_summary_data();
}
inline void VrSkeletalData::clear_skeletal_summary_data() {
  if (_impl_.skeletal_summary_data_ != nullptr) _impl_.skeletal_summary_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::VrSkeletalSummaryData& VrSkeletalData::_internal_skeletal_summary_data() const {
  const ::VrSkeletalSummaryData* p = _impl_.skeletal_summary_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::VrSkeletalSummaryData&>(
      ::_VrSkeletalSummaryData_default_instance_);
}
inline const ::VrSkeletalSummaryData& VrSkeletalData::skeletal_summary_data() const {
  // @@protoc_insertion_point(field_get:VrSkeletalData.skeletal_summary_data)
  return _internal_skeletal_summary_data();
}
inline void VrSkeletalData::unsafe_arena_set_allocated_skeletal_summary_data(
    ::VrSkeletalSummaryData* skeletal_summary_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.skeletal_summary_data_);
  }
  _impl_.skeletal_summary_data_ = skeletal_summary_data;
  if (skeletal_summary_data) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VrSkeletalData.skeletal_summary_data)
}
inline ::VrSkeletalSummaryData* VrSkeletalData::release_skeletal_summary_data() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::VrSkeletalSummaryData* temp = _impl_.skeletal_summary_data_;
  _impl_.skeletal_summary_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VrSkeletalSummaryData* VrSkeletalData::unsafe_arena_release_skeletal_summary_data() {
  // @@protoc_insertion_point(field_release:VrSkeletalData.skeletal_summary_data)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::VrSkeletalSummaryData* temp = _impl_.skeletal_summary_data_;
  _impl_.skeletal_summary_data_ = nullptr;
  return temp;
}
inline ::VrSkeletalSummaryData* VrSkeletalData::_internal_mutable_skeletal_summary_data() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.skeletal_summary_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::VrSkeletalSummaryData>(GetArenaForAllocation());
    _impl_.skeletal_summary_data_ = p;
  }
  return _impl_.skeletal_summary_data_;
}
inline ::VrSkeletalSummaryData* VrSkeletalData::mutable_skeletal_summary_data() {
  ::VrSkeletalSummaryData* _msg = _internal_mutable_skeletal_summary_data();
  // @@protoc_insertion_point(field_mutable:VrSkeletalData.skeletal_summary_data)
  return _msg;
}
inline void VrSkeletalData::set_allocated_skeletal_summary_data(::VrSkeletalSummaryData* skeletal_summary_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.skeletal_summary_data_;
  }
  if (skeletal_summary_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(skeletal_summary_data);
    if (message_arena != submessage_arena) {
      skeletal_summary_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, skeletal_summary_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.skeletal_summary_data_ = skeletal_summary_data;
  // @@protoc_insertion_point(field_set_allocated:VrSkeletalData.skeletal_summary_data)
}

// optional uint32 bone_count = 3;
inline bool VrSkeletalData::_internal_has_bone_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VrSkeletalData::has_bone_count() const {
  return _internal_has_bone_count();
}
inline void VrSkeletalData::clear_bone_count() {
  _impl_.bone_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t VrSkeletalData::_internal_bone_count() const {
  return _impl_.bone_count_;
}
inline uint32_t VrSkeletalData::bone_count() const {
  // @@protoc_insertion_point(field_get:VrSkeletalData.bone_count)
  return _internal_bone_count();
}
inline void VrSkeletalData::_internal_set_bone_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bone_count_ = value;
}
inline void VrSkeletalData::set_bone_count(uint32_t value) {
  _internal_set_bone_count(value);
  // @@protoc_insertion_point(field_set:VrSkeletalData.bone_count)
}

// optional uint32 bone_transform_source = 4;
inline bool VrSkeletalData::_internal_has_bone_transform_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VrSkeletalData::has_bone_transform_source() const {
  return _internal_has_bone_transform_source();
}
inline void VrSkeletalData::clear_bone_transform_source() {
  _impl_.bone_transform_source_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t VrSkeletalData::_internal_bone_transform_source() const {
  return _impl_.bone_transform_source_;
}
inline uint32_t VrSkeletalData::bone_transform_source() const {
  // @@protoc_insertion_point(field_get:VrSkeletalData.bone_transform_source)
  return _internal_bone_transform_source();
}
inline void VrSkeletalData::_internal_set_bone_transform_source(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bone_transform_source_ = value;
}
inline void VrSkeletalData::set_bone_transform_source(uint32_t value) {
  _internal_set_bone_transform_source(value);
  // @@protoc_insertion_point(field_set:VrSkeletalData.bone_transform_source)
}

// optional bytes compressed_bone_transforms = 5;
inline bool VrSkeletalData::_internal_has_compressed_bone_transforms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VrSkeletalData::has_compressed_bone_transforms() const {
  return _internal_has_compressed_bone_transforms();
}
inline void VrSkeletalData::clear_compressed_bone_transforms() {
  _impl_.compressed_bone_transforms_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VrSkeletalData::compressed_bone_transforms() const {
  // @@protoc_insertion_point(field_get:VrSkeletalData.compressed_bone_transforms)
  return _internal_compressed_bone_transforms();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VrSkeletalData::set_compressed_bone_transforms(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.compressed_bone_transforms_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VrSkeletalData.compressed_bone_transforms)
}
inline std::string* VrSkeletalData::mutable_compressed_bone_transforms() {
  std::string* _s = _internal_mutable_compressed_bone_transforms();
  // @@protoc_insertion_point(field_mutable:VrSkeletalData.compressed_bone_transforms)
  return _s;
}
inline const std::string& VrSkeletalData::_internal_compressed_bone_transforms() const {
  return _impl_.compressed_bone_transforms_.Get();
}
inline void VrSkeletalData::_internal_set_compressed_bone_transforms(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.compressed_bone_transforms_.Set(value, GetArenaForAllocation());
}
inline std::string* VrSkeletalData::_internal_mutable_compressed_bone_transforms() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.compressed_bone_transforms_.Mutable(GetArenaForAllocation());
}
inline std::string* VrSkeletalData::release_compressed_bone_transforms() {
  // @@protoc_insertion_point(field_release:VrSkeletalData.compressed_bone_transforms)
  if (!_internal_has_compressed_bone_transforms()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.compressed_bone_transforms_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.compressed_bone_transforms_.IsDefault()) {
    _impl_.compressed_bone_transforms_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VrSkeletalData::set_allocated_compressed_bone_transforms(std::string* compressed_bone_transforms) {
  if (compressed_bone_transforms != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.compressed_bone_transforms_.SetAllocated(compressed_bone_transforms, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.compressed_bone_transforms_.IsDefault()) {
    _impl_.compressed_bone_transforms_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VrSkeletalData.compressed_bone_transforms)
}

// -------------------------------------------------------------------

// CUerMsgVRActions

// repeated .VrInputDigitalActionData digital_action_data = 1;
inline int CUerMsgVRActions::_internal_digital_action_data_size() const {
  return _impl_.digital_action_data_.size();
}
inline int CUerMsgVRActions::digital_action_data_size() const {
  return _internal_digital_action_data_size();
}
inline void CUerMsgVRActions::clear_digital_action_data() {
  _impl_.digital_action_data_.Clear();
}
inline ::VrInputDigitalActionData* CUerMsgVRActions::mutable_digital_action_data(int index) {
  // @@protoc_insertion_point(field_mutable:CUerMsgVRActions.digital_action_data)
  return _impl_.digital_action_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrInputDigitalActionData >*
CUerMsgVRActions::mutable_digital_action_data() {
  // @@protoc_insertion_point(field_mutable_list:CUerMsgVRActions.digital_action_data)
  return &_impl_.digital_action_data_;
}
inline const ::VrInputDigitalActionData& CUerMsgVRActions::_internal_digital_action_data(int index) const {
  return _impl_.digital_action_data_.Get(index);
}
inline const ::VrInputDigitalActionData& CUerMsgVRActions::digital_action_data(int index) const {
  // @@protoc_insertion_point(field_get:CUerMsgVRActions.digital_action_data)
  return _internal_digital_action_data(index);
}
inline ::VrInputDigitalActionData* CUerMsgVRActions::_internal_add_digital_action_data() {
  return _impl_.digital_action_data_.Add();
}
inline ::VrInputDigitalActionData* CUerMsgVRActions::add_digital_action_data() {
  ::VrInputDigitalActionData* _add = _internal_add_digital_action_data();
  // @@protoc_insertion_point(field_add:CUerMsgVRActions.digital_action_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrInputDigitalActionData >&
CUerMsgVRActions::digital_action_data() const {
  // @@protoc_insertion_point(field_list:CUerMsgVRActions.digital_action_data)
  return _impl_.digital_action_data_;
}

// repeated .VrInputAnalogActionData analog_action_data = 2;
inline int CUerMsgVRActions::_internal_analog_action_data_size() const {
  return _impl_.analog_action_data_.size();
}
inline int CUerMsgVRActions::analog_action_data_size() const {
  return _internal_analog_action_data_size();
}
inline void CUerMsgVRActions::clear_analog_action_data() {
  _impl_.analog_action_data_.Clear();
}
inline ::VrInputAnalogActionData* CUerMsgVRActions::mutable_analog_action_data(int index) {
  // @@protoc_insertion_point(field_mutable:CUerMsgVRActions.analog_action_data)
  return _impl_.analog_action_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrInputAnalogActionData >*
CUerMsgVRActions::mutable_analog_action_data() {
  // @@protoc_insertion_point(field_mutable_list:CUerMsgVRActions.analog_action_data)
  return &_impl_.analog_action_data_;
}
inline const ::VrInputAnalogActionData& CUerMsgVRActions::_internal_analog_action_data(int index) const {
  return _impl_.analog_action_data_.Get(index);
}
inline const ::VrInputAnalogActionData& CUerMsgVRActions::analog_action_data(int index) const {
  // @@protoc_insertion_point(field_get:CUerMsgVRActions.analog_action_data)
  return _internal_analog_action_data(index);
}
inline ::VrInputAnalogActionData* CUerMsgVRActions::_internal_add_analog_action_data() {
  return _impl_.analog_action_data_.Add();
}
inline ::VrInputAnalogActionData* CUerMsgVRActions::add_analog_action_data() {
  ::VrInputAnalogActionData* _add = _internal_add_analog_action_data();
  // @@protoc_insertion_point(field_add:CUerMsgVRActions.analog_action_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrInputAnalogActionData >&
CUerMsgVRActions::analog_action_data() const {
  // @@protoc_insertion_point(field_list:CUerMsgVRActions.analog_action_data)
  return _impl_.analog_action_data_;
}

// repeated .VrSkeletalData skeleton = 3;
inline int CUerMsgVRActions::_internal_skeleton_size() const {
  return _impl_.skeleton_.size();
}
inline int CUerMsgVRActions::skeleton_size() const {
  return _internal_skeleton_size();
}
inline void CUerMsgVRActions::clear_skeleton() {
  _impl_.skeleton_.Clear();
}
inline ::VrSkeletalData* CUerMsgVRActions::mutable_skeleton(int index) {
  // @@protoc_insertion_point(field_mutable:CUerMsgVRActions.skeleton)
  return _impl_.skeleton_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrSkeletalData >*
CUerMsgVRActions::mutable_skeleton() {
  // @@protoc_insertion_point(field_mutable_list:CUerMsgVRActions.skeleton)
  return &_impl_.skeleton_;
}
inline const ::VrSkeletalData& CUerMsgVRActions::_internal_skeleton(int index) const {
  return _impl_.skeleton_.Get(index);
}
inline const ::VrSkeletalData& CUerMsgVRActions::skeleton(int index) const {
  // @@protoc_insertion_point(field_get:CUerMsgVRActions.skeleton)
  return _internal_skeleton(index);
}
inline ::VrSkeletalData* CUerMsgVRActions::_internal_add_skeleton() {
  return _impl_.skeleton_.Add();
}
inline ::VrSkeletalData* CUerMsgVRActions::add_skeleton() {
  ::VrSkeletalData* _add = _internal_add_skeleton();
  // @@protoc_insertion_point(field_add:CUerMsgVRActions.skeleton)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::VrSkeletalData >&
CUerMsgVRActions::skeleton() const {
  // @@protoc_insertion_point(field_list:CUerMsgVRActions.skeleton)
  return _impl_.skeleton_;
}

// -------------------------------------------------------------------

// VRSampleUserCmdPB

// optional .CBaseUserCmdPB base = 1;
inline bool VRSampleUserCmdPB::_internal_has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline bool VRSampleUserCmdPB::has_base() const {
  return _internal_has_base();
}
inline void VRSampleUserCmdPB::clear_base() {
  if (_impl_.base_ != nullptr) _impl_.base_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CBaseUserCmdPB& VRSampleUserCmdPB::_internal_base() const {
  const ::CBaseUserCmdPB* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::CBaseUserCmdPB&>(
      ::_CBaseUserCmdPB_default_instance_);
}
inline const ::CBaseUserCmdPB& VRSampleUserCmdPB::base() const {
  // @@protoc_insertion_point(field_get:VRSampleUserCmdPB.base)
  return _internal_base();
}
inline void VRSampleUserCmdPB::unsafe_arena_set_allocated_base(
    ::CBaseUserCmdPB* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VRSampleUserCmdPB.base)
}
inline ::CBaseUserCmdPB* VRSampleUserCmdPB::release_base() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CBaseUserCmdPB* VRSampleUserCmdPB::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:VRSampleUserCmdPB.base)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CBaseUserCmdPB* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::CBaseUserCmdPB* VRSampleUserCmdPB::_internal_mutable_base() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::CBaseUserCmdPB>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::CBaseUserCmdPB* VRSampleUserCmdPB::mutable_base() {
  ::CBaseUserCmdPB* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:VRSampleUserCmdPB.base)
  return _msg;
}
inline void VRSampleUserCmdPB::set_allocated_base(::CBaseUserCmdPB* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:VRSampleUserCmdPB.base)
}

// optional .CUserMsgVRCore hmd = 2;
inline bool VRSampleUserCmdPB::_internal_has_hmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hmd_ != nullptr);
  return value;
}
inline bool VRSampleUserCmdPB::has_hmd() const {
  return _internal_has_hmd();
}
inline void VRSampleUserCmdPB::clear_hmd() {
  if (_impl_.hmd_ != nullptr) _impl_.hmd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CUserMsgVRCore& VRSampleUserCmdPB::_internal_hmd() const {
  const ::CUserMsgVRCore* p = _impl_.hmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::CUserMsgVRCore&>(
      ::_CUserMsgVRCore_default_instance_);
}
inline const ::CUserMsgVRCore& VRSampleUserCmdPB::hmd() const {
  // @@protoc_insertion_point(field_get:VRSampleUserCmdPB.hmd)
  return _internal_hmd();
}
inline void VRSampleUserCmdPB::unsafe_arena_set_allocated_hmd(
    ::CUserMsgVRCore* hmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hmd_);
  }
  _impl_.hmd_ = hmd;
  if (hmd) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VRSampleUserCmdPB.hmd)
}
inline ::CUserMsgVRCore* VRSampleUserCmdPB::release_hmd() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CUserMsgVRCore* temp = _impl_.hmd_;
  _impl_.hmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CUserMsgVRCore* VRSampleUserCmdPB::unsafe_arena_release_hmd() {
  // @@protoc_insertion_point(field_release:VRSampleUserCmdPB.hmd)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CUserMsgVRCore* temp = _impl_.hmd_;
  _impl_.hmd_ = nullptr;
  return temp;
}
inline ::CUserMsgVRCore* VRSampleUserCmdPB::_internal_mutable_hmd() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.hmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::CUserMsgVRCore>(GetArenaForAllocation());
    _impl_.hmd_ = p;
  }
  return _impl_.hmd_;
}
inline ::CUserMsgVRCore* VRSampleUserCmdPB::mutable_hmd() {
  ::CUserMsgVRCore* _msg = _internal_mutable_hmd();
  // @@protoc_insertion_point(field_mutable:VRSampleUserCmdPB.hmd)
  return _msg;
}
inline void VRSampleUserCmdPB::set_allocated_hmd(::CUserMsgVRCore* hmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hmd_;
  }
  if (hmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hmd);
    if (message_arena != submessage_arena) {
      hmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hmd, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.hmd_ = hmd;
  // @@protoc_insertion_point(field_set_allocated:VRSampleUserCmdPB.hmd)
}

// optional .CUerMsgVRActions actions = 3;
inline bool VRSampleUserCmdPB::_internal_has_actions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.actions_ != nullptr);
  return value;
}
inline bool VRSampleUserCmdPB::has_actions() const {
  return _internal_has_actions();
}
inline void VRSampleUserCmdPB::clear_actions() {
  if (_impl_.actions_ != nullptr) _impl_.actions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::CUerMsgVRActions& VRSampleUserCmdPB::_internal_actions() const {
  const ::CUerMsgVRActions* p = _impl_.actions_;
  return p != nullptr ? *p : reinterpret_cast<const ::CUerMsgVRActions&>(
      ::_CUerMsgVRActions_default_instance_);
}
inline const ::CUerMsgVRActions& VRSampleUserCmdPB::actions() const {
  // @@protoc_insertion_point(field_get:VRSampleUserCmdPB.actions)
  return _internal_actions();
}
inline void VRSampleUserCmdPB::unsafe_arena_set_allocated_actions(
    ::CUerMsgVRActions* actions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.actions_);
  }
  _impl_.actions_ = actions;
  if (actions) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VRSampleUserCmdPB.actions)
}
inline ::CUerMsgVRActions* VRSampleUserCmdPB::release_actions() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CUerMsgVRActions* temp = _impl_.actions_;
  _impl_.actions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CUerMsgVRActions* VRSampleUserCmdPB::unsafe_arena_release_actions() {
  // @@protoc_insertion_point(field_release:VRSampleUserCmdPB.actions)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CUerMsgVRActions* temp = _impl_.actions_;
  _impl_.actions_ = nullptr;
  return temp;
}
inline ::CUerMsgVRActions* VRSampleUserCmdPB::_internal_mutable_actions() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.actions_ == nullptr) {
    auto* p = CreateMaybeMessage<::CUerMsgVRActions>(GetArenaForAllocation());
    _impl_.actions_ = p;
  }
  return _impl_.actions_;
}
inline ::CUerMsgVRActions* VRSampleUserCmdPB::mutable_actions() {
  ::CUerMsgVRActions* _msg = _internal_mutable_actions();
  // @@protoc_insertion_point(field_mutable:VRSampleUserCmdPB.actions)
  return _msg;
}
inline void VRSampleUserCmdPB::set_allocated_actions(::CUerMsgVRActions* actions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.actions_;
  }
  if (actions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(actions);
    if (message_arena != submessage_arena) {
      actions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actions, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.actions_ = actions;
  // @@protoc_insertion_point(field_set_allocated:VRSampleUserCmdPB.actions)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_usercmd_2eproto
